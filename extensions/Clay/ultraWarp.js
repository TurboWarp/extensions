// Name: UltraWarp
// ID: clayultrawarp
// Description: Play BeepBox/UltraBox songs in TurboWarp!
// By: ClaytonTDM <https://scratch.mit.edu/users/ClaytonTDM/>
// License: MIT and MPL-2.0

(function (Scratch) {
  // synth module
  var beepbox = (function (exports) {
    "use strict";
    /*!
        Copyright (c) 2012-2022 John Nesky and contributing authors
    
        Permission is hereby granted, free of charge, to any person obtaining a copy of
        this software and associated documentation files (the "Software"), to deal in
        the Software without restriction, including without limitation the rights to
        use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
        of the Software, and to permit persons to whom the Software is furnished to do
        so, subject to the following conditions:
    
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
    
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        */ var __awaiter =
      (exports && exports.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    const TypePresets = [
      "chip",
      "FM",
      "noise",
      "spectrum",
      "drumset",
      "harmonics",
      "pulse width",
      "picked string",
      "supersaw",
      "chip (custom)",
      "mod",
      "FM (6-op)",
    ];
    class SampleLoadingState {
      constructor() {
        (this.statusTable = {}),
          (this.urlTable = {}),
          (this.totalSamples = 0),
          (this.samplesLoaded = 0);
      }
    }
    const sampleLoadingState = new SampleLoadingState();
    class SampleLoadedEvent extends Event {
      constructor(totalSamples, samplesLoaded) {
        super("sampleloaded"),
          (this.totalSamples = totalSamples),
          (this.samplesLoaded = samplesLoaded);
      }
    }
    class SampleLoadEvents extends EventTarget {
      constructor() {
        super();
      }
    }
    const sampleLoadEvents = new SampleLoadEvents();
    function startLoadingSample(
      url,
      chipWaveIndex,
      presetSettings,
      rawLoopOptions,
      customSampleRate
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const sampleLoaderAudioContext = new AudioContext({
          sampleRate: customSampleRate,
        });
        let closedSampleLoaderAudioContext = !1;
        const chipWave = Config.chipWaves[chipWaveIndex],
          rawChipWave = Config.rawChipWaves[chipWaveIndex],
          rawRawChipWave = Config.rawRawChipWaves[chipWaveIndex];
        if (OFFLINE && "file:" === url.slice(0, 5)) {
          const dirname = yield getDirname(),
            joined = yield pathJoin(dirname, url.slice(5));
          url = joined;
        }
        Scratch.fetch(url)
          .then((response) =>
            response.ok
              ? response.arrayBuffer()
              : ((sampleLoadingState.statusTable[chipWaveIndex] = 2),
                Promise.reject(new Error("Couldn't load sample")))
          )
          .then((arrayBuffer) =>
            sampleLoaderAudioContext.decodeAudioData(arrayBuffer)
          )
          .then((audioBuffer) => {
            const samples = centerWave(
                Array.from(audioBuffer.getChannelData(0))
              ),
              integratedSamples = performIntegral(samples);
            (chipWave.samples = integratedSamples),
              (rawChipWave.samples = samples),
              (rawRawChipWave.samples = samples),
              rawLoopOptions.isUsingAdvancedLoopControls &&
                ((presetSettings.chipWaveLoopStart =
                  null != rawLoopOptions.chipWaveLoopStart
                    ? rawLoopOptions.chipWaveLoopStart
                    : 0),
                (presetSettings.chipWaveLoopEnd =
                  null != rawLoopOptions.chipWaveLoopEnd
                    ? rawLoopOptions.chipWaveLoopEnd
                    : samples.length - 1),
                (presetSettings.chipWaveLoopMode =
                  null != rawLoopOptions.chipWaveLoopMode
                    ? rawLoopOptions.chipWaveLoopMode
                    : 0),
                (presetSettings.chipWavePlayBackwards =
                  rawLoopOptions.chipWavePlayBackwards),
                (presetSettings.chipWaveStartOffset =
                  null != rawLoopOptions.chipWaveStartOffset
                    ? rawLoopOptions.chipWaveStartOffset
                    : 0)),
              sampleLoadingState.samplesLoaded++,
              (sampleLoadingState.statusTable[chipWaveIndex] = 1),
              sampleLoadEvents.dispatchEvent(
                new SampleLoadedEvent(
                  sampleLoadingState.totalSamples,
                  sampleLoadingState.samplesLoaded
                )
              ),
              closedSampleLoaderAudioContext ||
                ((closedSampleLoaderAudioContext = !0),
                sampleLoaderAudioContext.close());
          })
          .catch((error) => {
            (sampleLoadingState.statusTable[chipWaveIndex] = 2),
              alert("Failed to load " + url + ":\n" + error),
              closedSampleLoaderAudioContext ||
                ((closedSampleLoaderAudioContext = !0),
                sampleLoaderAudioContext.close());
          });
      });
    }
    function loadScript(url) {
      const result = new Promise((resolve, reject) => {
        if (!Config.willReloadForCustomSamples) {
          const script = document.createElement("script");
          (script.src = url),
            document.head.appendChild(script),
            script.addEventListener("load", (event) => {
              resolve();
            });
        }
      });
      return result;
    }
    function loadBuiltInSamples(set) {
      const defaultIndex = 0,
        defaultIntegratedSamples = Config.chipWaves[0].samples,
        defaultSamples = Config.rawRawChipWaves[0].samples;
      if (0 == set) {
        const chipWaves = [
          {
            name: "paandorasbox kick",
            expression: 4,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox snare",
            expression: 3,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox piano1",
            expression: 3,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 2,
          },
          {
            name: "paandorasbox WOW",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox overdrive",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -2,
          },
          {
            name: "paandorasbox trumpet",
            expression: 3,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 1.2,
          },
          {
            name: "paandorasbox saxophone",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -5,
          },
          {
            name: "paandorasbox orchestrahit",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 4.2,
          },
          {
            name: "paandorasbox detatched violin",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 4.2,
          },
          {
            name: "paandorasbox synth",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -0.8,
          },
          {
            name: "paandorasbox sonic3snare",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox come on",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox choir",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -3,
          },
          {
            name: "paandorasbox overdriveguitar",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -6.2,
          },
          {
            name: "paandorasbox flute",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -6,
          },
          {
            name: "paandorasbox legato violin",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -28,
          },
          {
            name: "paandorasbox tremolo violin",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -33,
          },
          {
            name: "paandorasbox amen break",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -55,
          },
          {
            name: "paandorasbox pizzicato violin",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -11,
          },
          {
            name: "paandorasbox tim allen grunt",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -20,
          },
          {
            name: "paandorasbox tuba",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 44,
          },
          {
            name: "paandorasbox loopingcymbal",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -17,
          },
          {
            name: "paandorasbox standardkick",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -7,
          },
          {
            name: "paandorasbox standardsnare",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "paandorasbox closedhihat",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 5,
          },
          {
            name: "paandorasbox foothihat",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 4,
          },
          {
            name: "paandorasbox openhihat",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -31,
          },
          {
            name: "paandorasbox crashcymbal",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -43,
          },
          {
            name: "paandorasbox pianoC4",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -42.5,
          },
          {
            name: "paandorasbox liver pad",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -22.5,
          },
          {
            name: "paandorasbox marimba",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -15.5,
          },
          {
            name: "paandorasbox susdotwav",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -24.5,
          },
          {
            name: "paandorasbox wackyboxtts",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -17.5,
          },
          {
            name: "paandorasbox peppersteak_1",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -42.2,
          },
          {
            name: "paandorasbox peppersteak_2",
            expression: 2,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -47,
          },
          {
            name: "paandorasbox vinyl_noise",
            expression: 2,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -50,
          },
          {
            name: "paandorasbeta slap bass",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -56,
          },
          {
            name: "paandorasbeta HD EB overdrive guitar",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -60,
          },
          {
            name: "paandorasbeta sunsoft bass",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -18.5,
          },
          {
            name: "paandorasbeta masculine choir",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -50,
          },
          {
            name: "paandorasbeta feminine choir",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -60.5,
          },
          {
            name: "paandorasbeta tololoche",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -29.5,
          },
          {
            name: "paandorasbeta harp",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -54,
          },
          {
            name: "paandorasbeta pan flute",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -58,
          },
          {
            name: "paandorasbeta krumhorn",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -46,
          },
          {
            name: "paandorasbeta timpani",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -50,
          },
          {
            name: "paandorasbeta crowd hey",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -29,
          },
          {
            name: "paandorasbeta wario land 4 brass",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -68,
          },
          {
            name: "paandorasbeta wario land 4 rock organ",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -63,
          },
          {
            name: "paandorasbeta wario land 4 DAOW",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -35,
          },
          {
            name: "paandorasbeta wario land 4 hour chime",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -47.5,
          },
          {
            name: "paandorasbeta wario land 4 tick",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -12.5,
          },
          {
            name: "paandorasbeta kirby kick",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -46.5,
          },
          {
            name: "paandorasbeta kirby snare",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -46.5,
          },
          {
            name: "paandorasbeta kirby bongo",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -46.5,
          },
          {
            name: "paandorasbeta kirby click",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -46.5,
          },
          {
            name: "paandorasbeta sonor kick",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -28.5,
          },
          {
            name: "paandorasbeta sonor snare",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -28.5,
          },
          {
            name: "paandorasbeta sonor snare (left hand)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -22.5,
          },
          {
            name: "paandorasbeta sonor snare (right hand)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -22.5,
          },
          {
            name: "paandorasbeta sonor high tom",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -41.5,
          },
          {
            name: "paandorasbeta sonor low tom",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -41.5,
          },
          {
            name: "paandorasbeta sonor hihat (closed)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -17,
          },
          {
            name: "paandorasbeta sonor hihat (half opened)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -21,
          },
          {
            name: "paandorasbeta sonor hihat (open)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -54.5,
          },
          {
            name: "paandorasbeta sonor hihat (open tip)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -43.5,
          },
          {
            name: "paandorasbeta sonor hihat (pedal)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -28,
          },
          {
            name: "paandorasbeta sonor crash",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -51,
          },
          {
            name: "paandorasbeta sonor crash (tip)",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -50.5,
          },
          {
            name: "paandorasbeta sonor ride",
            expression: 1,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: -46,
          },
        ];
        sampleLoadingState.totalSamples += chipWaves.length;
        const startIndex = Config.rawRawChipWaves.length;
        for (const chipWave of chipWaves) {
          const chipWaveIndex = Config.rawRawChipWaves.length,
            rawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            rawRawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            integratedChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultIntegratedSamples,
            };
          (Config.rawRawChipWaves[chipWaveIndex] = rawRawChipWave),
            (Config.rawRawChipWaves.dictionary[chipWave.name] = rawRawChipWave),
            (Config.rawChipWaves[chipWaveIndex] = rawChipWave),
            (Config.rawChipWaves.dictionary[chipWave.name] = rawChipWave),
            (Config.chipWaves[chipWaveIndex] = integratedChipWave),
            (Config.chipWaves.dictionary[chipWave.name] = rawChipWave),
            (sampleLoadingState.statusTable[chipWaveIndex] = 0),
            (sampleLoadingState.urlTable[chipWaveIndex] = "legacySamples");
        }
        loadScript("samples.js")
          .then(() => loadScript("samples2.js"))
          .then(() => loadScript("samples3.js"))
          .then(() => loadScript("drumsamples.js"))
          .then(() => loadScript("wario_samples.js"))
          .then(() => loadScript("kirby_samples.js"))
          .then(() => {
            const chipWaveSamples = [
              centerWave(kicksample),
              centerWave(snaresample),
              centerWave(pianosample),
              centerWave(WOWsample),
              centerWave(overdrivesample),
              centerWave(trumpetsample),
              centerWave(saxophonesample),
              centerWave(orchhitsample),
              centerWave(detatchedviolinsample),
              centerWave(synthsample),
              centerWave(sonic3snaresample),
              centerWave(comeonsample),
              centerWave(choirsample),
              centerWave(overdrivensample),
              centerWave(flutesample),
              centerWave(legatoviolinsample),
              centerWave(tremoloviolinsample),
              centerWave(amenbreaksample),
              centerWave(pizzicatoviolinsample),
              centerWave(timallengruntsample),
              centerWave(tubasample),
              centerWave(loopingcymbalsample),
              centerWave(kickdrumsample),
              centerWave(snaredrumsample),
              centerWave(closedhihatsample),
              centerWave(foothihatsample),
              centerWave(openhihatsample),
              centerWave(crashsample),
              centerWave(pianoC4sample),
              centerWave(liverpadsample),
              centerWave(marimbasample),
              centerWave(susdotwavsample),
              centerWave(wackyboxttssample),
              centerWave(peppersteak1),
              centerWave(peppersteak2),
              centerWave(vinyl),
              centerWave(slapbass),
              centerWave(hdeboverdrive),
              centerWave(sunsoftbass),
              centerWave(masculinechoir),
              centerWave(femininechoir),
              centerWave(southtololoche),
              centerWave(harp),
              centerWave(panflute),
              centerWave(krumhorn),
              centerWave(timpani),
              centerWave(crowdhey),
              centerWave(warioland4brass),
              centerWave(warioland4organ),
              centerWave(warioland4daow),
              centerWave(warioland4hourchime),
              centerWave(warioland4tick),
              centerWave(kirbykick),
              centerWave(kirbysnare),
              centerWave(kirbybongo),
              centerWave(kirbyclick),
              centerWave(funkkick),
              centerWave(funksnare),
              centerWave(funksnareleft),
              centerWave(funksnareright),
              centerWave(funktomhigh),
              centerWave(funktomlow),
              centerWave(funkhihatclosed),
              centerWave(funkhihathalfopen),
              centerWave(funkhihatopen),
              centerWave(funkhihatopentip),
              centerWave(funkhihatfoot),
              centerWave(funkcrash),
              centerWave(funkcrashtip),
              centerWave(funkride),
            ];
            let chipWaveIndexOffset = 0;
            for (const chipWaveSample of chipWaveSamples) {
              const chipWaveIndex = startIndex + chipWaveIndexOffset;
              (Config.rawChipWaves[chipWaveIndex].samples = chipWaveSample),
                (Config.rawRawChipWaves[chipWaveIndex].samples =
                  chipWaveSample),
                (Config.chipWaves[chipWaveIndex].samples =
                  performIntegral(chipWaveSample)),
                (sampleLoadingState.statusTable[chipWaveIndex] = 1),
                sampleLoadingState.samplesLoaded++,
                sampleLoadEvents.dispatchEvent(
                  new SampleLoadedEvent(
                    sampleLoadingState.totalSamples,
                    sampleLoadingState.samplesLoaded
                  )
                ),
                chipWaveIndexOffset++;
            }
          });
      } else if (1 == set) {
        const chipWaves = [
          {
            name: "chronoperc1final",
            expression: 4,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "synthkickfm",
            expression: 4,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "mcwoodclick1",
            expression: 4,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
          {
            name: "acoustic snare",
            expression: 4,
            isSampled: !0,
            isPercussion: !0,
            extraSampleDetune: 0,
          },
        ];
        sampleLoadingState.totalSamples += chipWaves.length;
        const startIndex = Config.rawRawChipWaves.length;
        for (const chipWave of chipWaves) {
          const chipWaveIndex = Config.rawRawChipWaves.length,
            rawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            rawRawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            integratedChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultIntegratedSamples,
            };
          (Config.rawRawChipWaves[chipWaveIndex] = rawRawChipWave),
            (Config.rawRawChipWaves.dictionary[chipWave.name] = rawRawChipWave),
            (Config.rawChipWaves[chipWaveIndex] = rawChipWave),
            (Config.rawChipWaves.dictionary[chipWave.name] = rawChipWave),
            (Config.chipWaves[chipWaveIndex] = integratedChipWave),
            (Config.chipWaves.dictionary[chipWave.name] = rawChipWave),
            (sampleLoadingState.statusTable[chipWaveIndex] = 0),
            (sampleLoadingState.urlTable[chipWaveIndex] = "nintariboxSamples");
        }
        loadScript("nintaribox_samples.js").then(() => {
          const chipWaveSamples = [
            centerWave(chronoperc1finalsample),
            centerWave(synthkickfmsample),
            centerWave(woodclicksample),
            centerWave(acousticsnaresample),
          ];
          let chipWaveIndexOffset = 0;
          for (const chipWaveSample of chipWaveSamples) {
            const chipWaveIndex = startIndex + chipWaveIndexOffset;
            (Config.rawChipWaves[chipWaveIndex].samples = chipWaveSample),
              (Config.rawRawChipWaves[chipWaveIndex].samples = chipWaveSample),
              (Config.chipWaves[chipWaveIndex].samples =
                performIntegral(chipWaveSample)),
              (sampleLoadingState.statusTable[chipWaveIndex] = 1),
              sampleLoadingState.samplesLoaded++,
              sampleLoadEvents.dispatchEvent(
                new SampleLoadedEvent(
                  sampleLoadingState.totalSamples,
                  sampleLoadingState.samplesLoaded
                )
              ),
              chipWaveIndexOffset++;
          }
        });
      } else if (2 == set) {
        const chipWaves = [
          {
            name: "cat",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -3,
          },
          {
            name: "gameboy",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 7,
          },
          {
            name: "mario",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 0,
          },
          {
            name: "drum",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 4,
          },
          {
            name: "yoshi",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -16,
          },
          {
            name: "star",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -16,
          },
          {
            name: "fire flower",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -1,
          },
          {
            name: "dog",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -1,
          },
          {
            name: "oink",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 3,
          },
          {
            name: "swan",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: 1,
          },
          {
            name: "face",
            expression: 1,
            isSampled: !0,
            isPercussion: !1,
            extraSampleDetune: -12,
          },
        ];
        sampleLoadingState.totalSamples += chipWaves.length;
        const startIndex = Config.rawRawChipWaves.length;
        for (const chipWave of chipWaves) {
          const chipWaveIndex = Config.rawRawChipWaves.length,
            rawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            rawRawChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultSamples,
            },
            integratedChipWave = {
              index: chipWaveIndex,
              name: chipWave.name,
              expression: chipWave.expression,
              isSampled: chipWave.isSampled,
              isPercussion: chipWave.isPercussion,
              extraSampleDetune: chipWave.extraSampleDetune,
              samples: defaultIntegratedSamples,
            };
          (Config.rawRawChipWaves[chipWaveIndex] = rawRawChipWave),
            (Config.rawRawChipWaves.dictionary[chipWave.name] = rawRawChipWave),
            (Config.rawChipWaves[chipWaveIndex] = rawChipWave),
            (Config.rawChipWaves.dictionary[chipWave.name] = rawChipWave),
            (Config.chipWaves[chipWaveIndex] = integratedChipWave),
            (Config.chipWaves.dictionary[chipWave.name] = rawChipWave),
            (sampleLoadingState.statusTable[chipWaveIndex] = 0),
            (sampleLoadingState.urlTable[chipWaveIndex] =
              "marioPaintboxSamples");
        }
        loadScript("mario_paintbox_samples.js").then(() => {
          const chipWaveSamples = [
            centerWave(catpaintboxsample),
            centerWave(gameboypaintboxsample),
            centerWave(mariopaintboxsample),
            centerWave(drumpaintboxsample),
            centerWave(yoshipaintboxsample),
            centerWave(starpaintboxsample),
            centerWave(fireflowerpaintboxsample),
            centerWave(dogpaintbox),
            centerWave(oinkpaintbox),
            centerWave(swanpaintboxsample),
            centerWave(facepaintboxsample),
          ];
          let chipWaveIndexOffset = 0;
          for (const chipWaveSample of chipWaveSamples) {
            const chipWaveIndex = startIndex + chipWaveIndexOffset;
            (Config.rawChipWaves[chipWaveIndex].samples = chipWaveSample),
              (Config.rawRawChipWaves[chipWaveIndex].samples = chipWaveSample),
              (Config.chipWaves[chipWaveIndex].samples =
                performIntegral(chipWaveSample)),
              (sampleLoadingState.statusTable[chipWaveIndex] = 1),
              sampleLoadingState.samplesLoaded++,
              sampleLoadEvents.dispatchEvent(
                new SampleLoadedEvent(
                  sampleLoadingState.totalSamples,
                  sampleLoadingState.samplesLoaded
                )
              ),
              chipWaveIndexOffset++;
          }
        });
      } else console.log("invalid set of built-in samples");
    }
    class Config {}
    function centerWave(wave) {
      let sum = 0;
      for (let i = 0; i < wave.length; i++) sum += wave[i];
      const average = sum / wave.length;
      for (let i = 0; i < wave.length; i++) wave[i] -= average;
      return performIntegral(wave), wave.push(0), new Float32Array(wave);
    }
    function centerAndNormalizeWave(wave) {
      let magn = 0;
      centerWave(wave);
      for (let i = 0; i < wave.length - 1; i++) magn += Math.abs(wave[i]);
      const magnAvg = magn / (wave.length - 1);
      for (let i = 0; i < wave.length - 1; i++) wave[i] = wave[i] / magnAvg;
      return new Float32Array(wave);
    }
    function performIntegral(wave) {
      let cumulative = 0,
        newWave = new Float32Array(wave.length);
      for (let i = 0; i < wave.length; i++)
        (newWave[i] = cumulative), (cumulative += wave[i]);
      return newWave;
    }
    function performIntegralOld(wave) {
      let cumulative = 0;
      for (let i = 0; i < wave.length; i++) {
        const temp = wave[i];
        (wave[i] = cumulative), (cumulative += temp);
      }
    }
    function getPulseWidthRatio(pulseWidth) {
      return pulseWidth / (2 * Config.pulseWidthRange);
    }
    function getDrumWave(
      index,
      inverseRealFourierTransform,
      scaleElementsByFactor
    ) {
      let wave = Config.chipNoises[index].samples;
      if (null == wave) {
        if (
          ((wave = new Float32Array(Config.chipNoiseLength + 1)),
          (Config.chipNoises[index].samples = wave),
          0 == index)
        ) {
          let drumBuffer = 1;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            wave[i] = 2 * (1 & drumBuffer) - 1;
            let newBuffer = drumBuffer >> 1;
            1 == ((drumBuffer + newBuffer) & 1) && (newBuffer += 16384),
              (drumBuffer = newBuffer);
          }
        } else if (1 == index)
          for (let i = 0; i < Config.chipNoiseLength; i++)
            wave[i] = 2 * Math.random() - 1;
        else if (2 == index) {
          let drumBuffer = 1;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            wave[i] = 2 * (1 & drumBuffer) - 1;
            let newBuffer = drumBuffer >> 1;
            1 == ((drumBuffer + newBuffer) & 1) && (newBuffer += 32768),
              (drumBuffer = newBuffer);
          }
        } else if (3 == index) {
          let drumBuffer = 1;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            wave[i] = 2 * (1 & drumBuffer) - 1;
            let newBuffer = drumBuffer >> 1;
            1 == ((drumBuffer + newBuffer) & 1) && (newBuffer += 40),
              (drumBuffer = newBuffer);
          }
        } else if (4 == index)
          drawNoiseSpectrum(wave, Config.chipNoiseLength, 10, 11, 1, 1, 0),
            drawNoiseSpectrum(
              wave,
              Config.chipNoiseLength,
              11,
              14,
              0.6578,
              0.6578,
              0
            ),
            inverseRealFourierTransform(wave, Config.chipNoiseLength),
            scaleElementsByFactor(wave, 1 / Math.sqrt(Config.chipNoiseLength));
        else if (5 == index)
          for (var drumBuffer = 1, i = 0; i < Config.chipNoiseLength; i++) {
            var newBuffer;
            (wave[i] = 2 * (1 & drumBuffer) - 1),
              1 == ((drumBuffer + (newBuffer = drumBuffer >> 1)) & 1) &&
                (newBuffer += 40),
              (drumBuffer = newBuffer);
          }
        else if (6 == index)
          drawNoiseSpectrum(wave, Config.chipNoiseLength, 1, 10, 1, 1, 0),
            drawNoiseSpectrum(wave, Config.chipNoiseLength, 20, 14, -2, -2, 0),
            inverseRealFourierTransform(wave, Config.chipNoiseLength),
            scaleElementsByFactor(wave, 1 / Math.sqrt(Config.chipNoiseLength));
        else if (7 == index)
          for (var drumBuffer = 1, i = 0; i < Config.chipNoiseLength; i++) {
            var newBuffer;
            (wave[i] = 4 * (1 & drumBuffer) * (14 * Math.random() + 1) - 8),
              1 == ((drumBuffer + (newBuffer = drumBuffer >> 1)) & 1) &&
                (newBuffer += 60),
              (drumBuffer = newBuffer);
          }
        else if (8 == index)
          for (var drumBuffer = 1, i = 0; i < Config.chipNoiseLength; i++) {
            var newBuffer;
            (wave[i] = (1 & drumBuffer) / 2 - 0.5),
              1 == ((drumBuffer + (newBuffer = drumBuffer >> 1)) & 1) &&
                (newBuffer -= 40),
              (drumBuffer = newBuffer);
          }
        else if (9 == index) {
          let drumBuffer = 1;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            wave[i] = 2 * (1 & drumBuffer) - 1.1;
            let newBuffer = drumBuffer >> 1;
            1 == ((drumBuffer + newBuffer) & 1) && (newBuffer += 131080),
              (drumBuffer = newBuffer);
          }
        } else if (10 == index)
          for (let i = 0; i < Config.chipNoiseLength; i++)
            wave[i] = Math.round(Math.random());
        else if (11 == index)
          for (var drumBuffer = 1, i = 0; i < Config.chipNoiseLength; i++) {
            var newBuffer;
            (wave[i] = Math.round(1 & drumBuffer)),
              1 == ((drumBuffer + (newBuffer = drumBuffer >> 1)) & 1) &&
                (newBuffer -= 40),
              (drumBuffer = newBuffer);
          }
        else if (12 == index)
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            var ultraboxnewchipnoiserand = Math.random();
            wave[i] = Math.pow(
              ultraboxnewchipnoiserand,
              Math.clz32(ultraboxnewchipnoiserand)
            );
          }
        else if (13 == index) {
          var b0 = 0,
            b1 = 0,
            b2 = 0,
            b3,
            b4,
            b5,
            b6;
          b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            var white;
            (b0 = 0.99886 * b0 + 0.0555179 * (white = 2 * Math.random() - 1)),
              (b1 = 0.99332 * b1 + 0.0750759 * white),
              (b2 = 0.969 * b2 + 0.153852 * white),
              (b3 = 0.8665 * b3 + 0.3104856 * white),
              (b4 = 0.55 * b4 + 0.5329522 * white),
              (b5 = -0.7616 * b5 - 0.016898 * white),
              (wave[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + 0.5362 * white),
              (wave[i] *= 0.44),
              (b6 = 0.115926 * white);
          }
        } else {
          if (14 != index) throw new Error("Unrecognized drum index: " + index);
          var lastOut = 0;
          for (let i = 0; i < Config.chipNoiseLength; i++) {
            var white = 2 * Math.random() - 1;
            (wave[i] = (lastOut + 0.02 * white) / 1.02),
              (lastOut = wave[i]),
              (wave[i] *= 14);
          }
        }
        wave[Config.chipNoiseLength] = wave[0];
      }
      return wave;
    }
    function drawNoiseSpectrum(
      wave,
      waveLength,
      lowOctave,
      highOctave,
      lowPower,
      highPower,
      overallSlope
    ) {
      const referenceOctave = 11,
        referenceIndex = 2048,
        lowIndex = 0 | Math.pow(2, lowOctave),
        highIndex = Math.min(waveLength >> 1, 0 | Math.pow(2, highOctave)),
        retroWave = getDrumWave(0, null, null);
      let combinedAmplitude = 0;
      for (let i = lowIndex; i < highIndex; i++) {
        let lerped =
            lowPower +
            ((highPower - lowPower) * (Math.log2(i) - lowOctave)) /
              (highOctave - lowOctave),
          amplitude = Math.pow(2, 7 * (lerped - 1) + 1) * lerped;
        (amplitude *= Math.pow(i / 2048, overallSlope)),
          (combinedAmplitude += amplitude),
          (amplitude *= retroWave[i]);
        const radians = 0.61803398875 * i * i * Math.PI * 2;
        (wave[i] = Math.cos(radians) * amplitude),
          (wave[waveLength - i] = Math.sin(radians) * amplitude);
      }
      return combinedAmplitude;
    }
    function generateSineWave() {
      const wave = new Float32Array(Config.sineWaveLength + 1);
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        wave[i] = Math.sin((i * Math.PI * 2) / Config.sineWaveLength);
      return wave;
    }
    function generateTriWave() {
      const wave = new Float32Array(Config.sineWaveLength + 1);
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        wave[i] =
          Math.asin(Math.sin((i * Math.PI * 2) / Config.sineWaveLength)) /
          (Math.PI / 2);
      return wave;
    }
    function generateTrapezoidWave(drive = 2) {
      const wave = new Float32Array(Config.sineWaveLength + 1);
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        wave[i] = Math.max(
          -1,
          Math.min(
            1,
            Math.asin(Math.sin((i * Math.PI * 2) / Config.sineWaveLength)) *
              drive
          )
        );
      return wave;
    }
    function generateSquareWave(phaseWidth = 0) {
      const wave = new Float32Array(Config.sineWaveLength + 1),
        centerPoint = Config.sineWaveLength / 4;
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        wave[i] =
          2 *
            +(
              Math.abs(i - centerPoint) <
                (phaseWidth * Config.sineWaveLength) / 2 ||
              Math.abs(i - Config.sineWaveLength - centerPoint) <
                (phaseWidth * Config.sineWaveLength) / 2
            ) -
          1;
      return wave;
    }
    function generateSawWave(inverse = !1) {
      const wave = new Float32Array(Config.sineWaveLength + 1);
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        (wave[i] =
          (((2 * (i + Config.sineWaveLength / 4)) / Config.sineWaveLength) %
            2) -
          1),
          (wave[i] = inverse ? -wave[i] : wave[i]);
      return wave;
    }
    function generateRoundedSineWave() {
      const wave = new Float32Array(Config.sineWaveLength + 1);
      for (let i = 0; i < Config.sineWaveLength + 1; i++)
        wave[i] = Math.round(
          Math.sin((i * Math.PI * 2) / Config.sineWaveLength)
        );
      return wave;
    }
    function getArpeggioPitchIndex(pitchCount, useFastTwoNoteArp, arpeggio) {
      let arpeggioPattern = Config.arpeggioPatterns[pitchCount - 1];
      return null != arpeggioPattern
        ? (2 == pitchCount &&
            0 == useFastTwoNoteArp &&
            (arpeggioPattern = [0, 0, 1, 1]),
          arpeggioPattern[arpeggio % arpeggioPattern.length])
        : arpeggio % pitchCount;
    }
    function toNameMap(array) {
      const dictionary = {};
      for (let i = 0; i < array.length; i++) {
        const value = array[i];
        (value.index = i), (dictionary[value.name] = value);
      }
      const result = array;
      return (result.dictionary = dictionary), result;
    }
    function effectsIncludeTransition(effects) {
      return 0 != (1024 & effects);
    }
    function effectsIncludeChord(effects) {
      return 0 != (2048 & effects);
    }
    function effectsIncludePitchShift(effects) {
      return 0 != (128 & effects);
    }
    function effectsIncludeDetune(effects) {
      return 0 != (256 & effects);
    }
    function effectsIncludeVibrato(effects) {
      return 0 != (512 & effects);
    }
    function effectsIncludeNoteFilter(effects) {
      return 0 != (32 & effects);
    }
    function effectsIncludeDistortion(effects) {
      return 0 != (8 & effects);
    }
    function effectsIncludeBitcrusher(effects) {
      return 0 != (16 & effects);
    }
    function effectsIncludePanning(effects) {
      return 0 != (4 & effects);
    }
    function effectsIncludeChorus(effects) {
      return 0 != (2 & effects);
    }
    function effectsIncludeEcho(effects) {
      return 0 != (64 & effects);
    }
    function effectsIncludeReverb(effects) {
      return 0 != (1 & effects);
    }
    function rawChipToIntegrated(raw) {
      const newArray = new Array(raw.length),
        dictionary = {};
      for (let i = 0; i < newArray.length; i++) {
        newArray[i] = Object.assign([], raw[i]);
        const value = newArray[i];
        (value.index = i), (dictionary[value.name] = value);
      }
      for (let key in dictionary)
        dictionary[key].samples = performIntegral(dictionary[key].samples);
      const result = newArray;
      return (result.dictionary = dictionary), result;
    }
    (Config.thresholdVal = -10),
      (Config.kneeVal = 40),
      (Config.ratioVal = 12),
      (Config.attackVal = 0),
      (Config.releaseVal = 0.25),
      (Config.willReloadForCustomSamples = !1),
      (Config.jsonFormat = "UltraBox"),
      (Config.scales = toNameMap([
        {
          name: "Free",
          realName: "chromatic",
          flags: [!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0],
        },
        {
          name: "Major",
          realName: "ionian",
          flags: [!0, !1, !0, !1, !0, !0, !1, !0, !1, !0, !1, !0],
        },
        {
          name: "Minor",
          realName: "aeolian",
          flags: [!0, !1, !0, !0, !1, !0, !1, !0, !0, !1, !0, !1],
        },
        {
          name: "Mixolydian",
          realName: "mixolydian",
          flags: [!0, !1, !0, !1, !0, !0, !1, !0, !1, !0, !0, !1],
        },
        {
          name: "Lydian",
          realName: "lydian",
          flags: [!0, !1, !0, !1, !0, !1, !0, !0, !1, !0, !1, !0],
        },
        {
          name: "Dorian",
          realName: "dorian",
          flags: [!0, !1, !0, !0, !1, !0, !1, !0, !1, !0, !0, !1],
        },
        {
          name: "Phrygian",
          realName: "phrygian",
          flags: [!0, !0, !1, !0, !1, !0, !1, !0, !0, !1, !0, !1],
        },
        {
          name: "Locrian",
          realName: "locrian",
          flags: [!0, !0, !1, !0, !1, !0, !0, !1, !0, !1, !0, !1],
        },
        {
          name: "Lydian Dominant",
          realName: "lydian dominant",
          flags: [!0, !1, !0, !1, !0, !1, !0, !0, !1, !0, !0, !1],
        },
        {
          name: "Phrygian Dominant",
          realName: "phrygian dominant",
          flags: [!0, !0, !1, !1, !0, !0, !1, !0, !0, !1, !0, !1],
        },
        {
          name: "Harmonic Major",
          realName: "harmonic major",
          flags: [!0, !1, !0, !1, !0, !0, !1, !0, !0, !1, !1, !0],
        },
        {
          name: "Harmonic Minor",
          realName: "harmonic minor",
          flags: [!0, !1, !0, !0, !1, !0, !1, !0, !0, !1, !1, !0],
        },
        {
          name: "Melodic Minor",
          realName: "melodic minor",
          flags: [!0, !1, !0, !0, !1, !0, !1, !0, !1, !0, !1, !0],
        },
        {
          name: "Blues",
          realName: "blues",
          flags: [!0, !1, !1, !0, !1, !0, !0, !0, !1, !1, !0, !1],
        },
        {
          name: "Altered",
          realName: "altered",
          flags: [!0, !0, !1, !0, !0, !1, !0, !1, !0, !1, !0, !1],
        },
        {
          name: "Major Pentatonic",
          realName: "major pentatonic",
          flags: [!0, !1, !0, !1, !0, !1, !1, !0, !1, !0, !1, !1],
        },
        {
          name: "Minor Pentatonic",
          realName: "minor pentatonic",
          flags: [!0, !1, !1, !0, !1, !0, !1, !0, !1, !1, !0, !1],
        },
        {
          name: "Whole Tone",
          realName: "whole tone",
          flags: [!0, !1, !0, !1, !0, !1, !0, !1, !0, !1, !0, !1],
        },
        {
          name: "Octatonic",
          realName: "octatonic",
          flags: [!0, !1, !0, !0, !1, !0, !0, !1, !0, !0, !1, !0],
        },
        {
          name: "Hexatonic",
          realName: "hexatonic",
          flags: [!0, !1, !1, !0, !0, !1, !1, !0, !0, !1, !1, !0],
        },
        {
          name: "No Dabbing",
          realName: "no dabbing",
          flags: [!0, !0, !1, !0, !0, !0, !0, !0, !0, !1, !0, !1],
        },
        {
          name: "Jacked Toad",
          realName: "jacked toad",
          flags: [!0, !1, !0, !0, !1, !0, !0, !0, !0, !1, !0, !0],
        },
        {
          name: "Dumb",
          realName:
            "Originally named, currently named, and will always be named 'dumb.'",
          flags: [!0, !1, !1, !1, !1, !0, !0, !0, !0, !1, !1, !0],
        },
        {
          name: "Test Scale",
          realName: "**t",
          flags: [!0, !0, !1, !1, !1, !0, !0, !1, !1, !0, !0, !1],
        },
        {
          name: "die",
          realName: "death",
          flags: [!0, !1, !1, !1, !1, !1, !1, !1, !0, !1, !1, !1],
        },
        {
          name: "Custom",
          realName: "custom",
          flags: [!0, !1, !0, !0, !1, !1, !1, !0, !0, !1, !0, !0],
        },
      ])),
      (Config.keys = toNameMap([
        { name: "C", isWhiteKey: !0, basePitch: 12 },
        { name: "C♯", isWhiteKey: !1, basePitch: 13 },
        { name: "D", isWhiteKey: !0, basePitch: 14 },
        { name: "D♯", isWhiteKey: !1, basePitch: 15 },
        { name: "E", isWhiteKey: !0, basePitch: 16 },
        { name: "F", isWhiteKey: !0, basePitch: 17 },
        { name: "F♯", isWhiteKey: !1, basePitch: 18 },
        { name: "G", isWhiteKey: !0, basePitch: 19 },
        { name: "G♯", isWhiteKey: !1, basePitch: 20 },
        { name: "A", isWhiteKey: !0, basePitch: 21 },
        { name: "A♯", isWhiteKey: !1, basePitch: 22 },
        { name: "B", isWhiteKey: !0, basePitch: 23 },
      ])),
      (Config.blackKeyNameParents = [
        -1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1,
      ]),
      (Config.tempoMin = 1),
      (Config.tempoMax = 500),
      (Config.octaveMin = -2),
      (Config.octaveMax = 2),
      (Config.echoDelayRange = 24),
      (Config.echoDelayStepTicks = 4),
      (Config.echoSustainRange = 8),
      (Config.echoShelfHz = 4e3),
      (Config.echoShelfGain = Math.pow(2, -0.5)),
      (Config.reverbShelfHz = 8e3),
      (Config.reverbShelfGain = Math.pow(2, -1.5)),
      (Config.reverbRange = 32),
      (Config.reverbDelayBufferSize = 16384),
      (Config.reverbDelayBufferMask = Config.reverbDelayBufferSize - 1),
      (Config.beatsPerBarMin = 1),
      (Config.beatsPerBarMax = 64),
      (Config.barCountMin = 1),
      (Config.barCountMax = 1024),
      (Config.instrumentCountMin = 1),
      (Config.layeredInstrumentCountMax = 10),
      (Config.patternInstrumentCountMax = 10),
      (Config.partsPerBeat = 24),
      (Config.ticksPerPart = 2),
      (Config.ticksPerArpeggio = 3),
      (Config.arpeggioPatterns = [
        [0],
        [0, 1],
        [0, 1, 2, 1],
        [0, 1, 2, 3],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5, 6],
        [0, 1, 2, 3, 4, 5, 6, 7],
      ]),
      (Config.rhythms = toNameMap([
        { name: "÷1 (whole notes)", stepsPerBeat: 1, roundUpThresholds: [3] },
        { name: "÷2 (half notes)", stepsPerBeat: 2, roundUpThresholds: [3, 9] },
        {
          name: "÷3 (triplets)",
          stepsPerBeat: 3,
          roundUpThresholds: [5, 12, 18],
        },
        {
          name: "÷4 (standard)",
          stepsPerBeat: 4,
          roundUpThresholds: [3, 9, 17, 21],
        },
        { name: "÷6 (sextuplets)", stepsPerBeat: 6, roundUpThresholds: null },
        { name: "÷8 (eighth notes)", stepsPerBeat: 8, roundUpThresholds: null },
        {
          name: "÷12 (twelfth notes)",
          stepsPerBeat: 12,
          roundUpThresholds: null,
        },
        { name: "freehand", stepsPerBeat: 24, roundUpThresholds: null },
      ])),
      (Config.instrumentTypeNames = [
        "chip",
        "FM",
        "noise",
        "spectrum",
        "drumset",
        "harmonics",
        "PWM",
        "Picked String",
        "supersaw",
        "custom chip",
        "mod",
        "FM6op",
      ]),
      (Config.instrumentTypeHasSpecialInterval = [
        !0,
        !0,
        !1,
        !1,
        !1,
        !0,
        !1,
        !1,
        !1,
        !1,
        !1,
      ]),
      (Config.chipBaseExpression = 0.03375),
      (Config.fmBaseExpression = 0.03),
      (Config.noiseBaseExpression = 0.19),
      (Config.spectrumBaseExpression = 0.3),
      (Config.drumsetBaseExpression = 0.45),
      (Config.harmonicsBaseExpression = 0.025),
      (Config.pwmBaseExpression = 0.04725),
      (Config.supersawBaseExpression = 0.061425),
      (Config.pickedStringBaseExpression = 0.025),
      (Config.distortionBaseVolume = 0.011),
      (Config.bitcrusherBaseVolume = 0.01),
      (Config.rawChipWaves = toNameMap([
        {
          name: "rounded",
          expression: 0.94,
          samples: centerWave([
            0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4,
            0.2, 0, -0.2, -0.4, -0.5, -0.6, -0.7, -0.8, -0.85, -0.9, -0.95, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -0.95, -0.9, -0.85, -0.8,
            -0.7, -0.6, -0.5, -0.4, -0.2,
          ]),
        },
        {
          name: "triangle",
          expression: 1,
          samples: centerWave([
            1 / 15,
            0.2,
            5 / 15,
            7 / 15,
            0.6,
            11 / 15,
            13 / 15,
            1,
            1,
            13 / 15,
            11 / 15,
            0.6,
            7 / 15,
            5 / 15,
            0.2,
            1 / 15,
            -1 / 15,
            -0.2,
            -5 / 15,
            -7 / 15,
            -0.6,
            -11 / 15,
            -13 / 15,
            -1,
            -1,
            -13 / 15,
            -11 / 15,
            -0.6,
            -7 / 15,
            -5 / 15,
            -0.2,
            -1 / 15,
          ]),
        },
        { name: "square", expression: 0.5, samples: centerWave([1, -1]) },
        {
          name: "1/4 pulse",
          expression: 0.5,
          samples: centerWave([1, -1, -1, -1]),
        },
        {
          name: "1/8 pulse",
          expression: 0.5,
          samples: centerWave([1, -1, -1, -1, -1, -1, -1, -1]),
        },
        {
          name: "sawtooth",
          expression: 0.65,
          samples: centerWave([
            1 / 31,
            3 / 31,
            5 / 31,
            7 / 31,
            9 / 31,
            11 / 31,
            13 / 31,
            15 / 31,
            17 / 31,
            19 / 31,
            21 / 31,
            23 / 31,
            25 / 31,
            27 / 31,
            29 / 31,
            1,
            -1,
            -29 / 31,
            -27 / 31,
            -25 / 31,
            -23 / 31,
            -21 / 31,
            -19 / 31,
            -17 / 31,
            -15 / 31,
            -13 / 31,
            -11 / 31,
            -9 / 31,
            -7 / 31,
            -5 / 31,
            -3 / 31,
            -1 / 31,
          ]),
        },
        {
          name: "double saw",
          expression: 0.5,
          samples: centerWave([
            0, -0.2, -0.4, -0.6, -0.8, -1, 1, -0.8, -0.6, -0.4, -0.2, 1, 0.8,
            0.6, 0.4, 0.2,
          ]),
        },
        {
          name: "double pulse",
          expression: 0.4,
          samples: centerWave([
            1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1,
          ]),
        },
        {
          name: "spiky",
          expression: 0.4,
          samples: centerWave([1, -1, 1, -1, 1, 0]),
        },
        {
          name: "sine",
          expression: 0.88,
          samples: centerAndNormalizeWave([
            8, 9, 11, 12, 13, 14, 15, 15, 15, 15, 14, 14, 13, 11, 10, 9, 7, 6,
            4, 3, 2, 1, 0, 0, 0, 0, 1, 1, 2, 4, 5, 6,
          ]),
        },
        {
          name: "flute",
          expression: 0.8,
          samples: centerAndNormalizeWave([
            3, 4, 6, 8, 10, 11, 13, 14, 15, 15, 14, 13, 11, 8, 5, 3,
          ]),
        },
        {
          name: "harp",
          expression: 0.8,
          samples: centerAndNormalizeWave([
            0, 3, 3, 3, 4, 5, 5, 6, 7, 8, 9, 11, 11, 13, 13, 15, 15, 14, 12, 11,
            10, 9, 8, 7, 7, 5, 4, 3, 2, 1, 0, 0,
          ]),
        },
        {
          name: "sharp clarinet",
          expression: 0.38,
          samples: centerAndNormalizeWave([
            0, 0, 0, 1, 1, 8, 8, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 7, 9, 9, 10, 4,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          ]),
        },
        {
          name: "soft clarinet",
          expression: 0.45,
          samples: centerAndNormalizeWave([
            0, 1, 5, 8, 9, 9, 9, 9, 9, 9, 9, 11, 11, 12, 13, 12, 10, 9, 7, 6, 4,
            3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1,
          ]),
        },
        {
          name: "alto sax",
          expression: 0.3,
          samples: centerAndNormalizeWave([
            5, 5, 6, 4, 3, 6, 8, 7, 2, 1, 5, 6, 5, 4, 5, 7, 9, 11, 13, 14, 14,
            14, 14, 13, 10, 8, 7, 7, 4, 3, 4, 2,
          ]),
        },
        {
          name: "bassoon",
          expression: 0.35,
          samples: centerAndNormalizeWave([
            9, 9, 7, 6, 5, 4, 4, 4, 4, 5, 7, 8, 9, 10, 11, 13, 13, 11, 10, 9, 7,
            6, 4, 2, 1, 1, 1, 2, 2, 5, 11, 14,
          ]),
        },
        {
          name: "trumpet",
          expression: 0.22,
          samples: centerAndNormalizeWave([
            10, 11, 8, 6, 5, 5, 5, 6, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 6, 6, 6,
            6, 6, 6, 6, 6, 7, 8, 9, 11, 14,
          ]),
        },
        {
          name: "electric guitar",
          expression: 0.2,
          samples: centerAndNormalizeWave([
            11, 12, 12, 10, 6, 6, 8, 0, 2, 4, 8, 10, 9, 10, 1, 7, 11, 3, 6, 6,
            8, 13, 14, 2, 0, 12, 8, 4, 13, 11, 10, 13,
          ]),
        },
        {
          name: "organ",
          expression: 0.2,
          samples: centerAndNormalizeWave([
            11, 10, 12, 11, 14, 7, 5, 5, 12, 10, 10, 9, 12, 6, 4, 5, 13, 12, 12,
            10, 12, 5, 2, 2, 8, 6, 6, 5, 8, 3, 2, 1,
          ]),
        },
        {
          name: "pan flute",
          expression: 0.35,
          samples: centerAndNormalizeWave([
            1, 4, 7, 6, 7, 9, 7, 7, 11, 12, 13, 15, 13, 11, 11, 12, 13, 10, 7,
            5, 3, 6, 10, 7, 3, 3, 1, 0, 1, 0, 1, 0,
          ]),
        },
        {
          name: "glitch",
          expression: 0.5,
          samples: centerWave([
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1,
            -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1,
            -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1,
          ]),
        },
        {
          name: "trapezoid",
          expression: 1,
          samples: centerWave([
            1 / 15,
            0.4,
            10 / 15,
            14 / 15,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            14 / 15,
            10 / 15,
            0.4,
            1 / 15,
            -1 / 15,
            -0.4,
            -10 / 15,
            -14 / 15,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -14 / 15,
            -10 / 15,
            -0.4,
            -1 / 15,
          ]),
        },
        {
          name: "modbox 10% pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          ]),
        },
        {
          name: "modbox sunsoft bass",
          expression: 1,
          samples: centerAndNormalizeWave([
            0, 0.1875, 0.3125, 0.5625, 0.5, 0.75, 0.875, 1, 1, 0.6875, 0.5,
            0.625, 0.625, 0.5, 0.375, 0.5625, 0.4375, 0.5625, 0.4375, 0.4375,
            0.3125, 0.1875, 0.1875, 0.375, 0.5625, 0.5625, 0.5625, 0.5625,
            0.5625, 0.4375, 0.25, 0,
          ]),
        },
        {
          name: "modbox loud pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, 0.7, 0.1, 0.1, 0, 0, 0, 0, 0, 0.1, 0.2, 0.15, 0.25, 0.125, 0.215,
            0.345, 4,
          ]),
        },
        {
          name: "modbox sax",
          expression: 0.5,
          samples: centerAndNormalizeWave([1 / 15, 0.2, 5 / 15, 9, 0.06]),
        },
        {
          name: "modbox guitar",
          expression: 0.5,
          samples: centerAndNormalizeWave([-0.5, 3.5, 3, -0.5, -0.25, -1]),
        },
        {
          name: "modbox sine",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            0, 0.05, 0.125, 0.2, 0.25, 0.3, 0.425, 0.475, 0.525, 0.625, 0.675,
            0.725, 0.775, 0.8, 0.825, 0.875, 0.9, 0.925, 0.95, 0.975, 0.98,
            0.99, 0.995, 1, 0.995, 0.99, 0.98, 0.975, 0.95, 0.925, 0.9, 0.875,
            0.825, 0.8, 0.775, 0.725, 0.675, 0.625, 0.525, 0.475, 0.425, 0.3,
            0.25, 0.2, 0.125, 0.05, 0, -0.05, -0.125, -0.2, -0.25, -0.3, -0.425,
            -0.475, -0.525, -0.625, -0.675, -0.725, -0.775, -0.8, -0.825,
            -0.875, -0.9, -0.925, -0.95, -0.975, -0.98, -0.99, -0.995, -1,
            -0.995, -0.99, -0.98, -0.975, -0.95, -0.925, -0.9, -0.875, -0.825,
            -0.8, -0.775, -0.725, -0.675, -0.625, -0.525, -0.475, -0.425, -0.3,
            -0.25, -0.2, -0.125, -0.05,
          ]),
        },
        {
          name: "modbox atari bass",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0,
          ]),
        },
        {
          name: "modbox atari pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          ]),
        },
        {
          name: "modbox 1% pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          ]),
        },
        {
          name: "modbox curved sawtooth",
          expression: 0.5,
          samples: centerAndNormalizeWave([1, 0.5, 1 / 3, 0.25]),
        },
        {
          name: "modbox viola",
          expression: 0.45,
          samples: centerAndNormalizeWave([
            -0.9, -1, -0.85, -0.775, -0.7, -0.6, -0.5, -0.4, -0.325, -0.225,
            -0.2, -0.125, -0.1, -0.11, -0.125, -0.15, -0.175, -0.18, -0.2,
            -0.21, -0.22, -0.21, -0.2, -0.175, -0.15, -0.1, -0.5, 0.75, 0.11,
            0.175, 0.2, 0.25, 0.26, 0.275, 0.26, 0.25, 0.225, 0.2, 0.19, 0.18,
            0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.275, 0.28, 0.29,
            0.3, 0.29, 0.28, 0.27, 0.26, 0.25, 0.225, 0.2, 0.175, 0.15, 0.1,
            0.075, 0, -0.01, -0.025, 0.025, 0.075, 0.2, 0.3, 0.475, 0.6, 0.75,
            0.85, 0.85, 1, 0.99, 0.95, 0.8, 0.675, 0.475, 0.275, 0.01, -0.15,
            -0.3, -0.475, -0.5, -0.6, -0.71, -0.81, -0.9, -1, -0.9,
          ]),
        },
        {
          name: "modbox brass",
          expression: 0.45,
          samples: centerAndNormalizeWave([
            -1, -0.95, -0.975, -0.9, -0.85, -0.8, -0.775, -0.65, -0.6, -0.5,
            -0.475, -0.35, -0.275, -0.2, -0.125, -0.05, 0, 0.075, 0.125, 0.15,
            0.2, 0.21, 0.225, 0.25, 0.225, 0.21, 0.2, 0.19, 0.175, 0.125, 0.1,
            0.075, 0.06, 0.05, 0.04, 0.025, 0.04, 0.05, 0.1, 0.15, 0.225, 0.325,
            0.425, 0.575, 0.7, 0.85, 0.95, 1, 0.9, 0.675, 0.375, 0.2, 0.275,
            0.4, 0.5, 0.55, 0.6, 0.625, 0.65, 0.65, 0.65, 0.65, 0.64, 0.6, 0.55,
            0.5, 0.4, 0.325, 0.25, 0.15, 0.05, -0.05, -0.15, -0.275, -0.35,
            -0.45, -0.55, -0.65, -0.7, -0.78, -0.825, -0.9, -0.925, -0.95,
            -0.975,
          ]),
        },
        {
          name: "modbox acoustic bass",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, 0, 0.1, -0.1, -0.2, -0.4, -0.3, -1,
          ]),
        },
        {
          name: "modbox lyre",
          expression: 0.45,
          samples: centerAndNormalizeWave([
            1, -1, 4, 2.15, 4.13, 5.15, 0, -0.05, 1,
          ]),
        },
        {
          name: "modbox ramp pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([6.1, -2.9, 1.4, -2.9]),
        },
        {
          name: "modbox piccolo",
          expression: 0.5,
          samples: centerAndNormalizeWave([1, 4, 2, 1, -0.1, -1, -0.12]),
        },
        {
          name: "modbox squaretooth",
          expression: 0.5,
          samples: centerAndNormalizeWave([0.2, 1, 2.6, 1, 0, -2.4]),
        },
        {
          name: "modbox flatline",
          expression: 1,
          samples: centerAndNormalizeWave([
            1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0, 0.1, 0.2, 0.3,
            0.4, 0.5, 0.6, 0.7, 0.8, 0.9,
          ]),
        },
        {
          name: "modbox pnryshk a (u5)",
          expression: 0.4,
          samples: centerAndNormalizeWave([
            1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0,
          ]),
        },
        {
          name: "modbox pnryshk b (riff)",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -0.9, 0.8, -0.7, 0.6, -0.5, 0.4, -0.3, 0.2, -0.1, 0, -0.1, 0.2,
            -0.3, 0.4, -0.5, 0.6, -0.7, 0.8, -0.9, 1,
          ]),
        },
        {
          name: "sandbox shrill lute",
          expression: 0.94,
          samples: centerAndNormalizeWave([1, 1.5, 1.25, 1.2, 1.3, 1.5]),
        },
        {
          name: "sandbox bassoon",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
          ]),
        },
        {
          name: "sandbox shrill bass",
          expression: 0.5,
          samples: centerAndNormalizeWave([0, 1, 0, 0, 1, 0, 1, 0, 0, 0]),
        },
        {
          name: "sandbox nes pulse",
          expression: 0.4,
          samples: centerAndNormalizeWave([2.1, -2.2, 1.2, 3]),
        },
        {
          name: "sandbox saw bass",
          expression: 0.25,
          samples: centerAndNormalizeWave([
            1, 1, 1, 1, 0, 2, 1, 2, 3, 1, -2, 1, 4, 1, 4, 2, 1, 6, -3, 4, 2, 1,
            5, 1, 4, 1, 5, 6, 7, 1, 6, 1, 4, 1, 9,
          ]),
        },
        {
          name: "sandbox euphonium",
          expression: 0.3,
          samples: centerAndNormalizeWave([
            0, 1, 2, 1, 2, 1, 4, 2, 5, 0, -2, 1, 5, 1, 2, 1, 2, 4, 5, 1, 5, -2,
            5, 10, 1,
          ]),
        },
        {
          name: "sandbox shrill pulse",
          expression: 0.3,
          samples: centerAndNormalizeWave([2, 0, 4, 1, 4, 6, 7, 3]),
        },
        {
          name: "sandbox r-sawtooth",
          expression: 0.2,
          samples: centerAndNormalizeWave([6.1, -2.9, 1.4, -2.9]),
        },
        {
          name: "sandbox recorder",
          expression: 0.2,
          samples: centerAndNormalizeWave([
            5, -5.1, 4, -4.1, 3, -3.1, 2, -2.1, 1, -1.1, 6,
          ]),
        },
        {
          name: "sandbox narrow saw",
          expression: 1.2,
          samples: centerAndNormalizeWave([
            0.1,
            -1.3,
            0.13 / -0.3,
            -0.26,
            0.13 / -0.7,
            0.13 / -0.9,
            0.13 / -0.11,
            0.13 / -0.31,
            0.13 / -0.51,
            0.13 / -0.71,
            0.13 / -0.91,
            0.13 / -0.12,
            -0.40625,
            -0.25,
            0.13 / -0.72,
            0.13 / -0.92,
            -1,
            1,
            0.13 / 0.92,
            0.13 / 0.72,
            0.25,
            0.40625,
            0.13 / 0.12,
            0.13 / 0.91,
            0.13 / 0.71,
            0.13 / 0.51,
            0.13 / 0.31,
            0.13 / 0.11,
            0.13 / 0.9,
            0.13 / 0.7,
            0.26,
            0.13 / 0.3,
            0.13,
          ]),
        },
        {
          name: "sandbox deep square",
          expression: 1,
          samples: centerAndNormalizeWave([1, 2.25, 1, -1, -2.25, -1]),
        },
        {
          name: "sandbox ring pulse",
          expression: 1,
          samples: centerAndNormalizeWave([
            1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1,
            -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1,
            -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1,
            -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1,
            -1, -1, -1,
          ]),
        },
        {
          name: "sandbox double sine",
          expression: 1,
          samples: centerAndNormalizeWave([
            1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.8, 1.7, 1.6, 1.5,
            1.4, 1.3, 1.2, 1.1, 1, 0, -1, -1.1, -1.2, -1.3, -1.4, -1.5, -1.6,
            -1.7, -1.8, -1.9, -1.8, -1.7, -1.6, -1.5, -1.4, -1.3, -1.2, -1.1,
            -1,
          ]),
        },
        {
          name: "sandbox contrabass",
          expression: 0.5,
          samples: centerAndNormalizeWave([4.2, 6.9, 1.337, 6.66]),
        },
        {
          name: "sandbox double bass",
          expression: 0.4,
          samples: centerAndNormalizeWave([
            0, 0.1875, 0.3125, 0.5625, 0.5, 0.75, 0.875, 1, -1, -0.6875, -0.5,
            -0.625, -0.625, -0.5, -0.375, -0.5625, -0.4375, -0.5625, -0.4375,
            -0.4375, -0.3125, -0.1875, 0.1875, 0.375, 0.5625, -0.5625, 0.5625,
            0.5625, 0.5625, 0.4375, 0.25, 0,
          ]),
        },
        {
          name: "haileybox test1",
          expression: 0.5,
          samples: centerAndNormalizeWave([1, 0.5, -1]),
        },
        {
          name: "brucebox pokey 4bit lfsr",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -1, -1, -1, 1, 1, 1, 1, -1, 1, -1, 1, 1, -1, -1,
          ]),
        },
        {
          name: "brucebox pokey 5step bass",
          expression: 0.5,
          samples: centerAndNormalizeWave([1, -1, 1, -1, 1]),
        },
        {
          name: "brucebox isolated spiky",
          expression: 0.5,
          samples: centerAndNormalizeWave([1, -1, 1, -1, 1, -1]),
        },
        {
          name: "nerdbox unnamed 1",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            0.2,
            4,
            0.7,
            -0.4,
            -1,
            0.5,
            -0.5 / 0.6,
          ]),
        },
        {
          name: "nerdbox unnamed 2",
          expression: 0.5,
          samples: centerAndNormalizeWave([2, 5 / 55, -9, 1, -55, 18.5 / -26]),
        },
        {
          name: "zefbox semi-square",
          expression: 1,
          samples: centerAndNormalizeWave([
            1, 1.5, 2, 2.5, 2.5, 2.5, 2, 1.5, 1,
          ]),
        },
        {
          name: "zefbox deep square",
          expression: 1,
          samples: centerAndNormalizeWave([1, 2.25, 1, -1, -2.25, -1]),
        },
        {
          name: "zefbox squaretal",
          expression: 0.7,
          samples: centerAndNormalizeWave([1.5, 1, 1.5, -1.5, -1, -1.5]),
        },
        {
          name: "zefbox saw wide",
          expression: 0.65,
          samples: centerAndNormalizeWave([
            0, -0.4, -0.8, -1.2, -1.6, -2, 0, -0.4, -0.8, -1.2, -1.6,
          ]),
        },
        {
          name: "zefbox saw narrow",
          expression: 0.65,
          samples: centerAndNormalizeWave([
            1, 0.5, 1, 0.5, 1, 0.5, 1, 2, 1, 2, 1,
          ]),
        },
        {
          name: "zefbox deep sawtooth",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            0, 2, 3, 4, 4.5, 5, 5.5, 6, 6.25, 6.5, 6.75, 7, 6.75, 6.5, 6.25, 6,
            5.5, 5, 4.5, 4, 3, 2, 1,
          ]),
        },
        {
          name: "zefbox sawtal",
          expression: 0.3,
          samples: centerAndNormalizeWave([
            1.5, 1, 1.25, -0.5, 1.5, -0.5, 0, -1.5, 1.5, 0, 0.5, -1.5, 0.5,
            1.25, -1, -1.5,
          ]),
        },
        {
          name: "zefbox deep sawtal",
          expression: 0.7,
          samples: centerAndNormalizeWave([
            0.75, 0.25, 0.5, -0.5, 0.5, -0.5, -0.25, -0.75,
          ]),
        },
        {
          name: "zefbox pulse",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, -2, -2, -1.5, -1.5, -1.25, -1.25, -1, -1,
          ]),
        },
        {
          name: "zefbox triple pulse",
          expression: 0.4,
          samples: centerAndNormalizeWave([
            1, 1, 1, 1, 1, -1, -1, 1.5, 1, 1, 1, 1, -1, -1, -1, 1.5,
          ]),
        },
        {
          name: "zefbox high pulse",
          expression: 0.2,
          samples: centerAndNormalizeWave([
            1, -2, 2, -3, 3, -4, 5, -4, 3, -3, 2, -2, 1,
          ]),
        },
        {
          name: "zefbox deep pulse",
          expression: 0.2,
          samples: centerAndNormalizeWave([
            1, 2, 2, -2, -2, -3, -4, -4, -5, -5, -5, -5, 0, -1, -2,
          ]),
        },
        {
          name: "wackybox guitar string",
          expression: 0.6,
          samples: centerAndNormalizeWave([
            0, 63, 63, 63, 63, 19, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 11,
            63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
            63, 63, 63, 63, 63, 63, 63, 27, 63, 63, 63, 63, 63, 63, 63, 63, 63,
            63, 63, 63, 63, 63, 63, 63, 63, 34, 63, 63, 63, 63,
          ]),
        },
        {
          name: "wackybox intense",
          expression: 0.6,
          samples: centerAndNormalizeWave([
            36, 25, 33, 35, 18, 51, 22, 40, 27, 37, 31, 33, 25, 29, 41, 23, 31,
            31, 45, 20, 37, 23, 29, 26, 42, 29, 33, 26, 31, 27, 40, 25, 40, 26,
            37, 24, 41, 32, 0, 32, 33, 29, 32, 31, 31, 31, 31, 31, 31, 31, 31,
            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
          ]),
        },
        {
          name: "wackybox buzz wave",
          expression: 0.6,
          samples: centerAndNormalizeWave([
            0, 1, 1, 2, 4, 4, 4, 4, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9,
            8, 8, 8, 11, 15, 23, 62, 61, 60, 58, 56, 56, 54, 53, 52, 50, 49, 48,
            47, 47, 45, 45, 45, 44, 44, 43, 43, 42, 42, 42, 42, 42, 42, 42, 42,
            42, 42, 42, 43, 43, 53,
          ]),
        },
        {
          name: "todbox 1/3 pulse",
          expression: 0.5,
          samples: centerWave([1, -1, -1]),
        },
        {
          name: "todbox 1/5 pulse",
          expression: 0.5,
          samples: centerWave([1, -1, -1, -1, -1]),
        },
        {
          name: "todbox slap bass",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            1, 0.5, 0, 0.5, 1.25, 0.5, -0.25, 0.1, -0.1, 0.1, 1.1, 2.1, 3, 3.5,
            2.9, 3.3, 2.7, 2.9, 2.3, 2, 1.9, 1.8, 1, 0.7, 0.9, 0.8, 0.4, 0.1, 0,
            0.2, 0.4, 0.6, 0.5, 0.8,
          ]),
        },
        {
          name: "todbox harsh wave",
          expression: 0.45,
          samples: centerAndNormalizeWave([
            1, -1, -1, -1, 0.5, 0.5, 0.5, 0.7, 0.39, 1.3, 0, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          ]),
        },
        {
          name: "todbox accordian",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            0, 1, 1, 2, 2, 1.5, 1.5, 0.8, 0, -2, -3.25, -4, -4.5, -5.5, -6,
            -5.75, -5.5, -5, -5, -5, -6, -6, -6, -5, -4, -3, -2, -1, 0.75, 1, 2,
            3, 4, 5, 6, 6.5, 7.5, 8, 7.75, 6, 5.25, 5, 5, 5, 5, 5, 4.25, 3.75,
            3.25, 2.75, 1.25, -0.75, -2, -0.75, 1.25, 1.25, 2, 2, 2, 2, 1.5, -1,
            -2, -1, 1.5, 2, 2.75, 2.75, 2.75, 3, 2.75, -1, -2, -2.5, -2, -1,
            -2.25, -2.75, -2, -3, -1.75, 1, 2, 3.5, 4, 5.25, 6, 8, 9.75, 10,
            9.5, 9, 8.5, 7.5, 6.5, 5.25, 5, 4.5, 4, 4, 4, 3.25, 2.5, 2, 1, -0.5,
            -2, -3.5, -4, -4, -4, -3.75, -3, -2, -1,
          ]),
        },
        {
          name: "todbox beta banana wave",
          expression: 0.8,
          samples: centerAndNormalizeWave([
            0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4,
            0.2, 0,
          ]),
        },
        {
          name: "todbox beta test wave",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            56, 0, -52, 16, 3, 3, 2, -35, 20, 147, -53, 0, 0, 5, -6,
          ]),
        },
        {
          name: "todbox beta real snare",
          expression: 1,
          samples: centerAndNormalizeWave([
            0, -0.01208, -0.02997, -0.04382, -0.06042, -0.07529, -0.09116,
            -0.10654, -0.12189, -0.13751, -0.15289, -0.16849, -0.18387,
            -0.19974, -0.21484, -0.23071, -0.24557, -0.26144, -0.27731,
            -0.29141, -0.3035, -0.32416, -0.34406, -0.32947, -0.31158, -0.33725,
            -0.37579, -0.39746, -0.40201, -0.40906, -0.4418, -0.47229, -0.47379,
            -0.47733, -0.45239, -0.33954, -0.22894, -0.22443, -0.32138,
            -0.46371, -0.57178, -0.61081, -0.59998, -0.61459, -0.62189,
            -0.43979, -0.19217, -0.12643, -0.17252, -0.20956, -0.20981,
            -0.19217, -0.22845, -0.34332, -0.50629, -0.64307, -0.72922,
            -0.81384, -0.87857, -0.90149, -0.88687, -0.86169, -0.87781,
            -0.80478, -0.52493, -0.31308, -0.33249, -0.39395, -0.39017,
            -0.30301, -0.19949, -0.13071, -0.02493, 0.14307, 0.34961, 0.52542,
            0.63223, 0.68613, 0.7471, 0.87305, 0.98184, 0.98889, 0.97052,
            0.99066, 0.99747, 0.99344, 0.99469, 0.99393, 0.9957, 0.99393,
            0.99521, 0.99469, 0.9942, 0.99521, 0.9942, 0.99521, 0.99469,
            0.99469, 0.99521, 0.9942, 0.99545, 0.99445, 0.99469, 0.99493,
            0.9942, 0.99521, 0.99393, 0.99493, 0.99469, 0.99445, 0.9957,
            0.99445, 0.99521, 0.99469, 0.99469, 0.99521, 0.9942, 0.99545,
            0.99445, 0.99445, 0.99493, 0.9942, 0.99545, 0.9942, 0.99493,
            0.99493, 0.9942, 0.99545, 0.99445, 0.99521, 0.99469, 0.99445,
            0.99545, 0.99368, 0.99393, 0.99445, 0.99268, 0.97983, 0.97229,
            0.95944, 0.88486, 0.76773, 0.64481, 0.53098, 0.39847, 0.19318,
            -0.03827, -0.20325, -0.39319, -0.68765, -0.88461, -0.93448,
            -0.96069, -0.97681, -0.98715, -0.99042, -0.99142, -0.99091,
            -0.99142, -0.99219, -0.99091, -0.99219, -0.99066, -0.99142,
            -0.99142, -0.99118, -0.99191, -0.99066, -0.99191, -0.99142,
            -0.99142, -0.99191, -0.99091, -0.99219, -0.99118, -0.99142,
            -0.99167, -0.99091, -0.99219, -0.99091, -0.99167, -0.99142,
            -0.99091, -0.99191, -0.99091, -0.99191, -0.99142, -0.99118,
            -0.99191, -0.99066, -0.99191, -0.99118, -0.99142, -0.99191,
            -0.99066, -0.99191, -0.99091, -0.99167, -0.99191, -0.99118,
            -0.99219, -0.99091, -0.99191, -0.99142, -0.99142, -0.99243,
            -0.98865, -0.98764, -0.99219, -0.98083, -0.92517, -0.9277, -0.91486,
            -0.59042, -0.15189, 0.02945, 0.05667, 0.06195, 0.00629, -0.18008,
            -0.56497, -0.8801, -0.9277, -0.92871, -0.97705, -0.99167, -0.98663,
            -0.99118, -0.99042, -0.99219, -0.99142, -0.99118, -0.98941,
            -0.99219, -1, -0.9758, -0.95993, -0.99948, -0.98236, -0.84659,
            -0.7486, -0.70679, -0.59747, -0.48035, -0.41687, -0.36826, -0.29745,
            -0.18185, -0.06219, 0.02164, 0.07907, 0.13123, 0.18033, 0.1962,
            0.15692, 0.14053, 0.20251, 0.2753, 0.30905, 0.29092, 0.27252,
            0.30402, 0.32416, 0.32214, 0.35239, 0.3967, 0.43198, 0.4942,
            0.58487, 0.64154, 0.65967, 0.6705, 0.67026, 0.66522, 0.6554,
            0.66119, 0.70627, 0.75842, 0.78738, 0.7894, 0.78763, 0.80402,
            0.85944, 0.94559, 0.9899, 0.9816, 0.98007, 0.99368, 0.99393,
            0.98538, 0.9758, 0.97101, 0.93802, 0.81812, 0.64633, 0.46649,
            0.28613, 0.14685, 0.08966, 0.12543, 0.20325, 0.24557, 0.18866,
            0.02795, -0.20175, -0.44205, -0.58713, -0.57629, -0.41385, -0.14255,
            0.18033, 0.47882, 0.68311, 0.72314, 0.62064, 0.48309, 0.43073,
            0.53577, 0.72794, 0.9025, 0.97354, 0.97, 0.98083, 0.99191, 0.99319,
            0.99493, 0.99393, 0.99521, 0.99393, 0.99545, 0.9942, 0.99493,
            0.99493, 0.99445, 0.99545, 0.9942, 0.99545, 0.99243, 0.98917,
            0.98386, 0.97781, 0.95844, 0.89066, 0.81561, 0.78134, 0.77277,
            0.75995, 0.73022, 0.67126, 0.57178, 0.47, 0.38361, 0.29419, 0.20703,
            0.14734, 0.15866, 0.25162, 0.35818, 0.45062, 0.5675, 0.69748,
            0.81232, 0.89697, 0.95062, 0.97656, 0.98615, 0.99191, 0.99219,
            0.99243, 0.99368, 0.99368, 0.97028, 0.95566, 0.94559, 0.82617,
            0.59973, 0.38361, 0.23901, 0.15338, 0.12921, 0.11206, 0.04382,
            -0.12946, -0.43552, -0.72644, -0.89847, -0.95465, -0.95541,
            -0.97229, -0.99268, -0.99319, -0.9884, -0.99142, -0.99167, -0.99091,
            -0.9884, -0.98965, -0.99368, -0.97455, -0.9501, -0.94684, -0.96219,
            -0.98514, -0.99243, -0.98889, -0.98917, -0.99142, -0.99219,
            -0.99091, -0.99191, -0.99142, -0.99142, -0.99191, -0.99066,
            -0.99167, -0.99091, -0.99142, -0.99191, -0.99091, -0.99191,
            -0.99091, -0.99167, -0.99167, -0.99091, -0.99219, -0.99091,
            -0.99191, -0.99142, -0.99118, -0.99191, -0.99066, -0.99191,
            -0.99091, -0.99118, -0.99243, -0.98941, -0.98462, -0.96976, -0.9632,
            -0.96194, -0.87305, -0.66196, -0.44809, -0.29495, -0.18085,
            -0.11813, -0.11334, -0.18564, -0.34885, -0.58237, -0.8045, -0.93726,
            -0.97806, -0.97354, -0.97531, -0.9899, -0.99368, -0.98941, -0.99219,
            -0.99091, -0.99142, -0.99167, -0.99091, -0.99191, -0.99118,
            -0.99219, -0.98236, -0.97781, -0.97656, -0.95135, -0.87204,
            -0.71335, -0.52139, -0.34232, -0.17783, -0.00906, 0.14886, 0.3045,
            0.48889, 0.67404, 0.8403, 0.94128, 0.97681, 0.98462, 0.98337,
            0.99142, 0.99521, 0.99493, 0.9942, 0.99445, 0.99521, 0.99393,
            0.99545, 0.99445, 0.99521, 0.99521, 0.99445, 0.9957, 0.99445,
            0.99521, 0.99469, 0.99445, 0.99521, 0.9942, 0.99521, 0.99445,
            0.99445, 0.99521, 0.99445, 0.99545, 0.99445, 0.99469, 0.99493,
            0.99393, 0.99493, 0.99445, 0.99393, 0.98285, 0.97781, 0.97479,
            0.92844, 0.82114, 0.66095, 0.52417, 0.46826, 0.46722, 0.47934,
            0.47379, 0.47076, 0.48209, 0.42014, 0.25439, 0.10074, -0.00302,
            -0.08966, -0.16068, -0.21436, -0.2204, -0.15137, -0.00476, 0.18536,
            0.37631, 0.52292, 0.62164, 0.70425, 0.74835, 0.72366, 0.63928,
            0.52567, 0.40805, 0.35666, 0.42896, 0.60175, 0.802, 0.92743,
            0.96548, 0.97632, 0.98337, 0.99066, 0.99521, 0.9942, 0.99368,
            0.99292, 0.9884, 0.98083, 0.96774, 0.93323, 0.8544, 0.6947, 0.47202,
            0.20425, -0.0889, -0.36423, -0.60025, -0.77481, -0.90173, -0.96017,
            -0.97028, -0.98108, -0.9884, -0.99219, -0.9899, -0.99219, -0.99142,
            -0.99142, -0.99219, -0.99091, -0.99243, -0.99066, -0.99142,
            -0.99142, -0.99118, -0.99191, -0.99066, -0.99167, -0.99142,
            -0.99142, -0.99219, -0.99091, -0.99191, -0.99118, -0.99142,
            -0.99191, -0.99091, -0.99191, -0.99091, -0.99167, -0.99191,
            -0.99118, -0.99219, -0.99091, -0.99167, -0.99142, -0.99142,
            -0.99219, -0.99091, -0.99191, -0.99142, -0.99118, -0.98917,
            -0.99042, -0.99445, -0.9733, -0.9559, -0.96219, -0.8967, -0.72241,
            -0.55112, -0.44809, -0.39319, -0.37833, -0.35641, -0.2627, -0.1423,
            -0.11282, -0.13525, -0.11536, -0.09671, -0.11511, -0.1806, -0.26874,
            -0.33374, -0.42215, -0.51358, -0.44785, -0.3045, -0.28613, -0.30527,
            -0.25037, -0.1539, -0.08286, -0.11157, -0.12592, -0.00327, 0.13803,
            0.19141, 0.1282, 0.01788, -0.03952, -0.12592, -0.26773, -0.34634,
            -0.31384, -0.1806, -0.0108, 0.13574, 0.2612, 0.36975, 0.46573,
            0.55087, 0.63626, 0.73022, 0.83072, 0.92014, 0.97177, 0.98587,
            0.98413, 0.99167, 0.99445, 0.99292, 0.99219, 0.9874, 0.98007,
            0.96472, 0.92239, 0.82166, 0.69067, 0.57959, 0.54962, 0.59695,
            0.64255, 0.64633, 0.60629, 0.55942, 0.5491, 0.58966, 0.61887,
            0.56952, 0.54181, 0.59518, 0.63248, 0.63876, 0.65463, 0.73398,
            0.88312, 0.96927, 0.97101, 0.97958, 0.99344, 0.9942, 0.99268,
            0.99493, 0.99469, 0.99445, 0.99521, 0.99445, 0.99545, 0.9942,
            0.99493, 0.99493, 0.9942, 0.99545, 0.9942, 0.99493, 0.9942, 0.99393,
            0.9942, 0.9884, 0.98309, 0.98309, 0.96069, 0.88461, 0.7937, 0.72064,
            0.65765, 0.59998, 0.53247, 0.49268, 0.48615, 0.44205, 0.38034,
            0.36447, 0.38715, 0.39294, 0.32645, 0.19595, 0.07782, -0.05893,
            -0.27832, -0.48309, -0.62619, -0.72995, -0.79999, -0.84583,
            -0.82166, -0.73575, -0.67227, -0.65491, -0.6496, -0.66397, -0.70175,
            -0.72894, -0.74658, -0.76724, -0.7952, -0.82846, -0.86523, -0.90527,
            -0.94382, -0.89948, -0.69849, -0.47479, -0.31662, -0.15414,
            -0.00729, 0.07077, 0.08237, 0.04431, -0.02292, -0.11761, -0.24307,
            -0.36926, -0.45087, -0.4617, -0.4025, -0.30679, -0.17529, 0,
            0.14331, 0.24179, 0.36774, 0.49545, 0.56522, 0.57907, 0.56775,
            0.53851, 0.51132, 0.48688, 0.41913, 0.26044, 0.00955, -0.26297,
            -0.46396, -0.62341, -0.82214, -0.94684, -0.96774, -0.97531,
            -0.98413, -0.99017, -0.9899, -0.99219, -0.99066, -0.99142, -0.99167,
            -0.99118, -0.99219, -0.9899, -0.99118, -0.99368, -0.99142, -0.97757,
            -0.97403, -0.98007, -0.9617, -0.86826, -0.67783, -0.52719, -0.48788,
            -0.4549, -0.43146, -0.47681, -0.54105, -0.57983, -0.60904, -0.62317,
            -0.59949, -0.55566, -0.52063, -0.52115, -0.55112, -0.56244,
            -0.58337, -0.6554, -0.73373, -0.77228, -0.74759, -0.6889, -0.64609,
            -0.61887, -0.5806, -0.50351, -0.40729, -0.33929, -0.3511, -0.42944,
            -0.47028, -0.42267, -0.32718, -0.20224, -0.0564, 0.04556, 0.10529,
            0.1763, 0.26169, 0.33197, 0.32138, 0.23776, 0.20956, 0.23148,
            0.20352, 0.23325, 0.39267, 0.52719, 0.58438, 0.62289, 0.66345,
            0.70023, 0.66296, 0.5433, 0.42618, 0.33475, 0.24533, 0.14105,
            0.03851, 0.01358, 0.09143, 0.22845, 0.34961, 0.41711, 0.4874,
            0.58914, 0.69519, 0.78186, 0.84357, 0.89822, 0.95389, 0.98135,
            0.98615, 0.99167, 0.99243, 0.99445, 0.9942, 0.99469, 0.99493,
            0.99393, 0.99545, 0.99445, 0.99521, 0.99469, 0.99445, 0.99521,
            0.9942, 0.99469, 0.98965, 0.98715, 0.98563, 0.96295, 0.91736,
            0.86624, 0.82367, 0.77554, 0.68411, 0.53549, 0.38916, 0.2612,
            0.11435, -0.04053, -0.18161, -0.23172, -0.19394, -0.15237, -0.1073,
            -0.02997, 0.08588, 0.2262, 0.34305, 0.44104, 0.5574, 0.65765,
            0.71259, 0.69217, 0.65363, 0.69748, 0.79572, 0.89368, 0.95514,
            0.97733, 0.98413, 0.98816, 0.99243, 0.99445, 0.99243, 0.97302,
            0.96674, 0.97983, 0.90378, 0.71005, 0.51056, 0.40451, 0.40982,
            0.41559, 0.32996, 0.24356, 0.18866, 0.11411, 0.05365, 0.01157,
            -0.03247, -0.09216, -0.16095, -0.23248, -0.31662, -0.39771,
            -0.48663, -0.59647, -0.71536, -0.82013, -0.85287, -0.82947,
            -0.84937, -0.92215, -0.97177, -0.98663, -0.98816, -0.98438,
            -0.99091, -0.99219, -0.99091, -0.99191, -0.99042, -0.99191,
            -0.99091, -0.99142, -0.99191, -0.99091, -0.99191, -0.99091,
            -0.99167, -0.99142,
          ]),
        },
        {
          name: "ultrabox shortened od guitar",
          expression: 0.5,
          samples: centerAndNormalizeWave([
            -0.82785, -0.67621, -0.40268, -0.43817, -0.45468, -0.22531,
            -0.18329, 0.2475, 0.71246, 0.52155, 0.56082, 0.48395, 0.3399,
            0.46957, 0.27744, 0.42313, 0.47104, 0.18796, 0.1293, -0.13901,
            -0.07431, -0.16348, -0.74857, -0.73206, -0.35181, -0.26227,
            -0.41882, -0.27786, -0.19806, -0.19867, 0.18643, 0.24808, 0.08847,
            -0.06964, 0.06912, 0.20474, -0.05304, 0.29416, 0.31967, 0.14243,
            0.27521, -0.23932, -0.14752, 0.1236, -0.26123, -0.26111, 0.06616,
            0.2652, 0.0809, 0.1524, 0.16254, -0.12061, 0.04562, 0.00131, 0.0405,
            0.08182, -0.21729, -0.17041, -0.16312, -0.08563, 0.0639, 0.05099,
            0.05627, 0.02728, 0.00726, -0.13028, -0.05673, -0.14969, -0.17645,
            0.35492, 0.16766, -0.00897, 0.24326, -0.00461, -0.04456, 0.01776,
            -0.0495, -0.01221, 0.02039, 0.07684, 0.13397, 0.3985, 0.35962,
            0.13754, 0.4231, 0.27161, -0.17609, 0.03659, 0.10635, -0.21909,
            -0.22046, -0.20258, -0.40973, -0.4028, -0.40521, -0.66284,
          ]),
        },
      ])),
      (Config.chipWaves = rawChipToIntegrated(Config.rawChipWaves)),
      (Config.rawRawChipWaves = Config.rawChipWaves),
      (Config.firstIndexForSamplesInChipWaveList = Config.chipWaves.length),
      (Config.chipNoises = toNameMap([
        {
          name: "retro",
          expression: 0.25,
          basePitch: 69,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "white",
          expression: 1,
          basePitch: 69,
          pitchFilterMult: 8,
          isSoft: !0,
          samples: null,
        },
        {
          name: "clang",
          expression: 0.4,
          basePitch: 69,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "buzz",
          expression: 0.3,
          basePitch: 69,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "hollow",
          expression: 1.5,
          basePitch: 96,
          pitchFilterMult: 1,
          isSoft: !0,
          samples: null,
        },
        {
          name: "shine",
          expression: 1,
          basePitch: 69,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "deep",
          expression: 1.5,
          basePitch: 120,
          pitchFilterMult: 1024,
          isSoft: !0,
          samples: null,
        },
        {
          name: "cutter",
          expression: 0.005,
          basePitch: 96,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "metallic",
          expression: 1,
          basePitch: 96,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "static",
          expression: 1,
          basePitch: 96,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "1-bit white",
          expression: 0.5,
          basePitch: 74.41,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "1-bit metallic",
          expression: 0.5,
          basePitch: 86.41,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "crackling",
          expression: 0.9,
          basePitch: 69,
          pitchFilterMult: 1024,
          isSoft: !1,
          samples: null,
        },
        {
          name: "pink",
          expression: 1,
          basePitch: 69,
          pitchFilterMult: 8,
          isSoft: !0,
          samples: null,
        },
        {
          name: "brownian",
          expression: 1,
          basePitch: 69,
          pitchFilterMult: 8,
          isSoft: !0,
          samples: null,
        },
      ])),
      (Config.filterFreqStep = 0.25),
      (Config.filterFreqRange = 34),
      (Config.filterFreqReferenceSetting = 28),
      (Config.filterFreqReferenceHz = 8e3),
      (Config.filterFreqMaxHz =
        Config.filterFreqReferenceHz *
        Math.pow(
          2,
          Config.filterFreqStep *
            (Config.filterFreqRange - 1 - Config.filterFreqReferenceSetting)
        )),
      (Config.filterFreqMinHz = 8),
      (Config.filterGainRange = 15),
      (Config.filterGainCenter = 7),
      (Config.filterGainStep = 0.5),
      (Config.filterMaxPoints = 8),
      (Config.filterTypeNames = ["low-pass", "high-pass", "peak"]),
      (Config.filterMorphCount = 10),
      (Config.filterSimpleCutRange = 11),
      (Config.filterSimplePeakRange = 8),
      (Config.fadeInRange = 10),
      (Config.fadeOutTicks = [-24, -12, -6, -3, -1, 6, 12, 24, 48, 72, 96]),
      (Config.fadeOutNeutral = 4),
      (Config.drumsetFadeOutTicks = 48),
      (Config.transitions = toNameMap([
        {
          name: "normal",
          isSeamless: !1,
          continues: !1,
          slides: !1,
          slideTicks: 3,
          includeAdjacentPatterns: !1,
        },
        {
          name: "interrupt",
          isSeamless: !0,
          continues: !1,
          slides: !1,
          slideTicks: 3,
          includeAdjacentPatterns: !0,
        },
        {
          name: "continue",
          isSeamless: !0,
          continues: !0,
          slides: !1,
          slideTicks: 3,
          includeAdjacentPatterns: !0,
        },
        {
          name: "slide",
          isSeamless: !0,
          continues: !1,
          slides: !0,
          slideTicks: 3,
          includeAdjacentPatterns: !0,
        },
        {
          name: "slide in pattern",
          isSeamless: !0,
          continues: !1,
          slides: !0,
          slideTicks: 3,
          includeAdjacentPatterns: !1,
        },
      ])),
      (Config.vibratos = toNameMap([
        { name: "none", amplitude: 0, type: 0, delayTicks: 0 },
        { name: "light", amplitude: 0.15, type: 0, delayTicks: 0 },
        { name: "delayed", amplitude: 0.3, type: 0, delayTicks: 37 },
        { name: "heavy", amplitude: 0.45, type: 0, delayTicks: 0 },
        { name: "shaky", amplitude: 0.1, type: 1, delayTicks: 0 },
      ])),
      (Config.vibratoTypes = toNameMap([
        { name: "normal", periodsSeconds: [0.14], period: 0.14 },
        {
          name: "shaky",
          periodsSeconds: [0.11, 0.17798, 0.33],
          period: 266.97,
        },
      ])),
      (Config.arpSpeedScale = [
        0,
        0.0625,
        0.125,
        0.2,
        0.25,
        1 / 3,
        0.4,
        0.5,
        2 / 3,
        0.75,
        0.8,
        0.9,
        1,
        1.1,
        1.2,
        1.3,
        1.4,
        1.5,
        1.6,
        1.7,
        1.8,
        1.9,
        2,
        2.1,
        2.2,
        2.3,
        2.4,
        2.5,
        2.6,
        2.7,
        2.8,
        2.9,
        3,
        3.1,
        3.2,
        3.3,
        3.4,
        3.5,
        3.6,
        3.7,
        3.8,
        3.9,
        4,
        4.15,
        4.3,
        4.5,
        4.8,
        5,
        5.5,
        6,
        8,
      ]),
      (Config.unisons = toNameMap([
        {
          name: "none",
          voices: 1,
          spread: 0,
          offset: 0,
          expression: 1.4,
          sign: 1,
        },
        {
          name: "shimmer",
          voices: 2,
          spread: 0.018,
          offset: 0,
          expression: 0.8,
          sign: 1,
        },
        {
          name: "hum",
          voices: 2,
          spread: 0.045,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "honky tonk",
          voices: 2,
          spread: 0.09,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "dissonant",
          voices: 2,
          spread: 0.25,
          offset: 0,
          expression: 0.9,
          sign: 1,
        },
        {
          name: "fifth",
          voices: 2,
          spread: 3.5,
          offset: 3.5,
          expression: 0.9,
          sign: 1,
        },
        {
          name: "octave",
          voices: 2,
          spread: 6,
          offset: 6,
          expression: 0.8,
          sign: 1,
        },
        {
          name: "bowed",
          voices: 2,
          spread: 0.02,
          offset: 0,
          expression: 1,
          sign: -1,
        },
        {
          name: "piano",
          voices: 2,
          spread: 0.01,
          offset: 0,
          expression: 1,
          sign: 0.7,
        },
        {
          name: "warbled",
          voices: 2,
          spread: 0.25,
          offset: 0.05,
          expression: 0.9,
          sign: -0.8,
        },
        {
          name: "hecking gosh",
          voices: 2,
          spread: 6.25,
          offset: -6,
          expression: 0.8,
          sign: -0.7,
        },
        {
          name: "spinner",
          voices: 2,
          spread: 0.02,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "detune",
          voices: 1,
          spread: 0,
          offset: 0.25,
          expression: 1,
          sign: 1,
        },
        {
          name: "rising",
          voices: 2,
          spread: 1,
          offset: 0.7,
          expression: 0.95,
          sign: 1,
        },
        {
          name: "vibrate",
          voices: 2,
          spread: 3.5,
          offset: 7,
          expression: 0.975,
          sign: 1,
        },
        {
          name: "fourths",
          voices: 2,
          spread: 4,
          offset: 4,
          expression: 0.95,
          sign: 1,
        },
        {
          name: "bass",
          voices: 1,
          spread: 0,
          offset: -7,
          expression: 1,
          sign: 1,
        },
        {
          name: "dirty",
          voices: 2,
          spread: 0,
          offset: 0.1,
          expression: 0.975,
          sign: 1,
        },
        {
          name: "stationary",
          voices: 2,
          spread: 3.5,
          offset: 0,
          expression: 0.9,
          sign: 1,
        },
        {
          name: "recurve",
          voices: 2,
          spread: 0.005,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "voiced",
          voices: 2,
          spread: 9.5,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "fluctuate",
          voices: 2,
          spread: 12,
          offset: 0,
          expression: 1,
          sign: 1,
        },
        {
          name: "thin",
          voices: 1,
          spread: 0,
          offset: 50,
          expression: 1,
          sign: 1,
        },
        {
          name: "inject",
          voices: 2,
          spread: 6,
          offset: 0.4,
          expression: 1,
          sign: 1,
        },
        {
          name: "askewed",
          voices: 2,
          spread: 0,
          offset: 0.42,
          expression: 0.7,
          sign: 1,
        },
        {
          name: "resonance",
          voices: 2,
          spread: 0.0025,
          offset: 0.1,
          expression: 0.8,
          sign: -1.5,
        },
        {
          name: "FART",
          voices: 2,
          spread: 13,
          offset: -5,
          expression: 1,
          sign: -3,
        },
      ])),
      (Config.effectNames = [
        "reverb",
        "chorus",
        "panning",
        "distortion",
        "bitcrusher",
        "note filter",
        "echo",
        "pitch shift",
        "detune",
        "vibrato",
        "transition type",
        "chord type",
      ]),
      (Config.effectOrder = [2, 10, 11, 7, 8, 9, 5, 3, 4, 1, 6, 0]),
      (Config.noteSizeMax = 6),
      (Config.volumeRange = 50),
      (Config.volumeLogScale = 0.1428),
      (Config.panCenter = 50),
      (Config.panMax = 2 * Config.panCenter),
      (Config.panDelaySecondsMax = 0.001),
      (Config.chorusRange = 8),
      (Config.chorusPeriodSeconds = 2),
      (Config.chorusDelayRange = 0.0034),
      (Config.chorusDelayOffsets = [
        [1.51, 2.1, 3.35],
        [1.47, 2.15, 3.25],
      ]),
      (Config.chorusPhaseOffsets = [
        [0, 2.1, 4.2],
        [3.2, 5.3, 1],
      ]),
      (Config.chorusMaxDelay =
        Config.chorusDelayRange *
        (1 +
          Config.chorusDelayOffsets[0]
            .concat(Config.chorusDelayOffsets[1])
            .reduce((x, y) => Math.max(x, y)))),
      (Config.chords = toNameMap([
        {
          name: "simultaneous",
          customInterval: !1,
          arpeggiates: !1,
          strumParts: 0,
          singleTone: !1,
        },
        {
          name: "strum",
          customInterval: !1,
          arpeggiates: !1,
          strumParts: 1,
          singleTone: !1,
        },
        {
          name: "arpeggio",
          customInterval: !1,
          arpeggiates: !0,
          strumParts: 0,
          singleTone: !0,
        },
        {
          name: "custom interval",
          customInterval: !0,
          arpeggiates: !1,
          strumParts: 0,
          singleTone: !0,
        },
      ])),
      (Config.maxChordSize = 9),
      (Config.operatorCount = 4),
      (Config.maxPitchOrOperatorCount = Math.max(
        Config.maxChordSize,
        Config.operatorCount + 2
      )),
      (Config.algorithms = toNameMap([
        {
          name: "1←(2 3 4)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1],
          modulatedBy: [[2, 3, 4], [], [], []],
        },
        {
          name: "1←(2 3←4)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1],
          modulatedBy: [[2, 3], [], [4], []],
        },
        {
          name: "1←2←(3 4)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1],
          modulatedBy: [[2], [3, 4], [], []],
        },
        {
          name: "1←(2 3)←4",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1],
          modulatedBy: [[2, 3], [4], [4], []],
        },
        {
          name: "1←2←3←4",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1],
          modulatedBy: [[2], [3], [4], []],
        },
        {
          name: "1←3 2←4",
          carrierCount: 2,
          associatedCarrier: [1, 2, 1, 2],
          modulatedBy: [[3], [4], [], []],
        },
        {
          name: "1 2←(3 4)",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2],
          modulatedBy: [[], [3, 4], [], []],
        },
        {
          name: "1 2←3←4",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2],
          modulatedBy: [[], [3], [4], []],
        },
        {
          name: "(1 2)←3←4",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2],
          modulatedBy: [[3], [3], [4], []],
        },
        {
          name: "(1 2)←(3 4)",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2],
          modulatedBy: [[3, 4], [3, 4], [], []],
        },
        {
          name: "1 2 3←4",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 3],
          modulatedBy: [[], [], [4], []],
        },
        {
          name: "(1 2 3)←4",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 3],
          modulatedBy: [[4], [4], [4], []],
        },
        {
          name: "1 2 3 4",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4],
          modulatedBy: [[], [], [], []],
        },
        {
          name: "1←(2 3) 2←4",
          carrierCount: 2,
          associatedCarrier: [1, 2, 1, 2],
          modulatedBy: [[2, 3], [4], [], []],
        },
        {
          name: "1←(2 (3 (4",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 3],
          modulatedBy: [[2, 3, 4], [3, 4], [4], []],
        },
      ])),
      (Config.algorithms6Op = toNameMap([
        {
          name: "Custom",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [[2, 3, 4, 5, 6], [], [], [], [], []],
        },
        {
          name: "1←2←3←4←5←6",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [[2], [3], [4], [5], [6], []],
        },
        {
          name: "1←3 2←4←5←6",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3], [4], [], [5], [6], []],
        },
        {
          name: "1←3←4 2←5←6",
          carrierCount: 2,
          associatedCarrier: [1, 1, 1, 2, 2, 2],
          modulatedBy: [[3], [5], [4], [], [6], []],
        },
        {
          name: "1←4 2←5 3←6",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[4], [5], [6], [], [], []],
        },
        {
          name: "1←3 2←(4 5←6)",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3], [4, 5], [], [], [6], []],
        },
        {
          name: "1←(3 4) 2←5←6",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3, 4], [5], [], [], [6], []],
        },
        {
          name: "1←3 2←(4 5 6)",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3], [4, 5, 6], [], [], [], []],
        },
        {
          name: "1←3 2←(4 5)←6",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3], [4, 5], [], [6], [6], []],
        },
        {
          name: "1←3 2←4←(5 6)",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3], [4], [], [5, 6], [], []],
        },
        {
          name: "1←(2 3 4 5 6)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [[2, 3, 4, 5, 6], [], [], [], [], []],
        },
        {
          name: "1←(2 3←5 4←6)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [[2, 3, 4], [], [5], [6], [], []],
        },
        {
          name: "1←(2 3 4←5←6)",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [[2, 3, 4], [], [], [5], [6], []],
        },
        {
          name: "1←4←5 (2 3)←6",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[4], [6], [6], [5], [], []],
        },
        {
          name: "1←(3 4)←5 2←6",
          carrierCount: 2,
          associatedCarrier: [1, 2, 2, 2, 2, 2],
          modulatedBy: [[3, 4], [6], [5], [5], [], []],
        },
        {
          name: "(1 2)←4 3←(5 6)",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[4], [4], [5, 6], [], [], []],
        },
        {
          name: "(1 2)←5 (3 4)←6",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[5], [5], [6], [6], [], []],
        },
        {
          name: "(1 2 3)←(4 5 6)",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[4, 5, 6], [4, 5, 6], [4, 5, 6], [], [], []],
        },
        {
          name: "1←5 (2 3 4)←6",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[5], [6], [6], [6], [], []],
        },
        {
          name: "1 2←5 (3 4)←6",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[], [5], [6], [6], [], []],
        },
        {
          name: "1 2 (3 4 5)←6",
          carrierCount: 5,
          associatedCarrier: [1, 2, 3, 4, 5, 5],
          modulatedBy: [[], [], [6], [6], [6], []],
        },
        {
          name: "1 2 3 (4 5)←6",
          carrierCount: 5,
          associatedCarrier: [1, 2, 3, 4, 5, 5],
          modulatedBy: [[], [], [], [6], [6], []],
        },
        {
          name: "1 2←4 3←(5 6)",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 3, 3, 3],
          modulatedBy: [[], [4], [5, 6], [], [], []],
        },
        {
          name: "1←4 2←(5 6) 3",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 3, 3, 3],
          modulatedBy: [[4], [5, 6], [], [], [], []],
        },
        {
          name: "1 2 3←5 4←6",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[], [], [5], [6], [], []],
        },
        {
          name: "1 (2 3)←5←6 4",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[], [5], [5], [], [6], []],
        },
        {
          name: "1 2 3←5←6 4",
          carrierCount: 4,
          associatedCarrier: [1, 2, 3, 4, 4, 4],
          modulatedBy: [[], [], [5, 6], [], [], []],
        },
        {
          name: "(1 2 3 4 5)←6",
          carrierCount: 5,
          associatedCarrier: [1, 2, 3, 4, 5, 5],
          modulatedBy: [[6], [6], [6], [6], [6], []],
        },
        {
          name: "1 2 3 4 5←6",
          carrierCount: 5,
          associatedCarrier: [1, 2, 3, 4, 5, 5],
          modulatedBy: [[], [], [], [], [6], []],
        },
        {
          name: "1 2 3 4 5 6",
          carrierCount: 6,
          associatedCarrier: [1, 2, 3, 4, 5, 6],
          modulatedBy: [[], [], [], [], [], []],
        },
        {
          name: "1←(2 (3 (4 (5 (6",
          carrierCount: 5,
          associatedCarrier: [1, 2, 3, 4, 5, 5],
          modulatedBy: [
            [2, 3, 4, 5, 6],
            [3, 4, 5, 6],
            [4, 5, 6],
            [5, 6],
            [6],
            [],
          ],
        },
        {
          name: "1←(2(3(4(5(6",
          carrierCount: 1,
          associatedCarrier: [1, 1, 1, 1, 1, 1],
          modulatedBy: [
            [2, 3, 4, 5, 6],
            [3, 4, 5, 6],
            [4, 5, 6],
            [5, 6],
            [6],
            [],
          ],
        },
        {
          name: "1←4(2←5(3←6",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[2, 3, 4], [3, 5], [6], [], [], []],
        },
        {
          name: "1←4(2←5 3←6",
          carrierCount: 3,
          associatedCarrier: [1, 2, 3, 1, 2, 3],
          modulatedBy: [[2, 3, 4], [5], [6], [], [], []],
        },
      ])),
      (Config.operatorCarrierInterval = [0, 0.04, -0.073, 0.091, 0.061, 0.024]),
      (Config.operatorAmplitudeMax = 15),
      (Config.operatorFrequencies = toNameMap([
        { name: "0.12×", mult: 0.125, hzOffset: 0, amplitudeSign: 1 },
        { name: "0.25×", mult: 0.25, hzOffset: 0, amplitudeSign: 1 },
        { name: "0.5×", mult: 0.5, hzOffset: 0, amplitudeSign: 1 },
        { name: "0.75×", mult: 0.75, hzOffset: 0, amplitudeSign: 1 },
        { name: "1×", mult: 1, hzOffset: 0, amplitudeSign: 1 },
        { name: "~1×", mult: 1, hzOffset: 1.5, amplitudeSign: -1 },
        { name: "2×", mult: 2, hzOffset: 0, amplitudeSign: 1 },
        { name: "~2×", mult: 2, hzOffset: -1.3, amplitudeSign: -1 },
        { name: "3×", mult: 3, hzOffset: 0, amplitudeSign: 1 },
        { name: "3.5×", mult: 3.5, hzOffset: -0.05, amplitudeSign: 1 },
        { name: "4×", mult: 4, hzOffset: 0, amplitudeSign: 1 },
        { name: "~4×", mult: 4, hzOffset: -2.4, amplitudeSign: -1 },
        { name: "5×", mult: 5, hzOffset: 0, amplitudeSign: 1 },
        { name: "6×", mult: 6, hzOffset: 0, amplitudeSign: 1 },
        { name: "7×", mult: 7, hzOffset: 0, amplitudeSign: 1 },
        { name: "8×", mult: 8, hzOffset: 0, amplitudeSign: 1 },
        { name: "9×", mult: 9, hzOffset: 0, amplitudeSign: 1 },
        { name: "10×", mult: 10, hzOffset: 0, amplitudeSign: 1 },
        { name: "11×", mult: 11, hzOffset: 0, amplitudeSign: 1 },
        { name: "12×", mult: 12, hzOffset: 0, amplitudeSign: 1 },
        { name: "13×", mult: 13, hzOffset: 0, amplitudeSign: 1 },
        { name: "14×", mult: 14, hzOffset: 0, amplitudeSign: 1 },
        { name: "15×", mult: 15, hzOffset: 0, amplitudeSign: 1 },
        { name: "16×", mult: 16, hzOffset: 0, amplitudeSign: 1 },
        { name: "17×", mult: 17, hzOffset: 0, amplitudeSign: 1 },
        { name: "18×", mult: 18, hzOffset: 0, amplitudeSign: 1 },
        { name: "19×", mult: 19, hzOffset: 0, amplitudeSign: 1 },
        { name: "20×", mult: 20, hzOffset: 0, amplitudeSign: 1 },
        { name: "~20×", mult: 20, hzOffset: -5, amplitudeSign: -1 },
        { name: "25×", mult: 25, hzOffset: 0, amplitudeSign: 1 },
        { name: "50×", mult: 50, hzOffset: 0, amplitudeSign: 1 },
        { name: "75×", mult: 75, hzOffset: 0, amplitudeSign: 1 },
        { name: "100×", mult: 100, hzOffset: 0, amplitudeSign: 1 },
      ])),
      (Config.envelopes = toNameMap([
        { name: "none", type: 1, speed: 0 },
        { name: "note size", type: 0, speed: 0 },
        { name: "punch", type: 2, speed: 0 },
        { name: "flare -1", type: 3, speed: 128 },
        { name: "flare 1", type: 3, speed: 32 },
        { name: "flare 2", type: 3, speed: 8 },
        { name: "flare 3", type: 3, speed: 2 },
        { name: "twang -1", type: 4, speed: 128 },
        { name: "twang 1", type: 4, speed: 32 },
        { name: "twang 2", type: 4, speed: 8 },
        { name: "twang 3", type: 4, speed: 2 },
        { name: "swell -1", type: 5, speed: 128 },
        { name: "swell 1", type: 5, speed: 32 },
        { name: "swell 2", type: 5, speed: 8 },
        { name: "swell 3", type: 5, speed: 2 },
        { name: "tremolo0", type: 6, speed: 8 },
        { name: "tremolo1", type: 6, speed: 4 },
        { name: "tremolo2", type: 6, speed: 2 },
        { name: "tremolo3", type: 6, speed: 1 },
        { name: "tremolo4", type: 7, speed: 4 },
        { name: "tremolo5", type: 7, speed: 2 },
        { name: "tremolo6", type: 7, speed: 1 },
        { name: "decay -1", type: 8, speed: 40 },
        { name: "decay 1", type: 8, speed: 10 },
        { name: "decay 2", type: 8, speed: 7 },
        { name: "decay 3", type: 8, speed: 4 },
        { name: "wibble-1", type: 9, speed: 96 },
        { name: "wibble 1", type: 9, speed: 24 },
        { name: "wibble 2", type: 9, speed: 12 },
        { name: "wibble 3", type: 9, speed: 4 },
        { name: "linear-2", type: 11, speed: 256 },
        { name: "linear-1", type: 11, speed: 128 },
        { name: "linear 1", type: 11, speed: 32 },
        { name: "linear 2", type: 11, speed: 8 },
        { name: "linear 3", type: 11, speed: 2 },
        { name: "rise -2", type: 12, speed: 256 },
        { name: "rise -1", type: 12, speed: 128 },
        { name: "rise 1", type: 12, speed: 32 },
        { name: "rise 2", type: 12, speed: 8 },
        { name: "rise 3", type: 12, speed: 2 },
        { name: "flute 1", type: 9, speed: 16 },
        { name: "flute 2", type: 9, speed: 8 },
        { name: "flute 3", type: 9, speed: 4 },
        { name: "tripolo1", type: 6, speed: 9 },
        { name: "tripolo2", type: 6, speed: 6 },
        { name: "tripolo3", type: 6, speed: 3 },
        { name: "tripolo4", type: 7, speed: 9 },
        { name: "tripolo5", type: 7, speed: 6 },
        { name: "tripolo6", type: 7, speed: 3 },
        { name: "pentolo1", type: 6, speed: 10 },
        { name: "pentolo2", type: 6, speed: 5 },
        { name: "pentolo3", type: 6, speed: 2.5 },
        { name: "pentolo4", type: 7, speed: 10 },
        { name: "pentolo5", type: 7, speed: 5 },
        { name: "pentolo6", type: 7, speed: 2.5 },
        { name: "flutter 1", type: 6, speed: 14 },
        { name: "flutter 2", type: 7, speed: 11 },
        { name: "water-y flutter", type: 6, speed: 9 },
        { name: "blip 1", type: 13, speed: 6 },
        { name: "blip 2", type: 13, speed: 16 },
        { name: "blip 3", type: 13, speed: 32 },
      ])),
      (Config.feedbacks = toNameMap([
        { name: "1⟲", indices: [[1], [], [], []] },
        { name: "2⟲", indices: [[], [2], [], []] },
        { name: "3⟲", indices: [[], [], [3], []] },
        { name: "4⟲", indices: [[], [], [], [4]] },
        { name: "1⟲ 2⟲", indices: [[1], [2], [], []] },
        { name: "3⟲ 4⟲", indices: [[], [], [3], [4]] },
        { name: "1⟲ 2⟲ 3⟲", indices: [[1], [2], [3], []] },
        { name: "2⟲ 3⟲ 4⟲", indices: [[], [2], [3], [4]] },
        { name: "1⟲ 2⟲ 3⟲ 4⟲", indices: [[1], [2], [3], [4]] },
        { name: "1→2", indices: [[], [1], [], []] },
        { name: "1→3", indices: [[], [], [1], []] },
        { name: "1→4", indices: [[], [], [], [1]] },
        { name: "2→3", indices: [[], [], [2], []] },
        { name: "2→4", indices: [[], [], [], [2]] },
        { name: "3→4", indices: [[], [], [], [3]] },
        { name: "1→3 2→4", indices: [[], [], [1], [2]] },
        { name: "1→4 2→3", indices: [[], [], [2], [1]] },
        { name: "1→2→3→4", indices: [[], [1], [2], [3]] },
        { name: "1↔2 3↔4", indices: [[2], [1], [4], [3]] },
        { name: "1↔4 2↔3", indices: [[4], [3], [2], [1]] },
        { name: "2→1→4→3→2", indices: [[2], [3], [4], [1]] },
        { name: "1→2→3→4→1", indices: [[4], [1], [2], [3]] },
        { name: "(1 2 3)→4", indices: [[], [], [], [1, 2, 3]] },
        {
          name: "ALL",
          indices: [
            [1, 2, 3, 4],
            [1, 2, 3, 4],
            [1, 2, 3, 4],
            [1, 2, 3, 4],
          ],
        },
      ])),
      (Config.feedbacks6Op = toNameMap([
        { name: "Custom", indices: [[2, 3, 4, 5, 6], [], [], [], [], []] },
        { name: "1⟲", indices: [[1], [], [], [], [], []] },
        { name: "2⟲", indices: [[], [2], [], [], [], []] },
        { name: "3⟲", indices: [[], [], [3], [], [], []] },
        { name: "4⟲", indices: [[], [], [], [4], [], []] },
        { name: "5⟲", indices: [[], [], [], [], [5], []] },
        { name: "6⟲", indices: [[], [], [], [], [], [6]] },
        { name: "1⟲ 2⟲", indices: [[1], [2], [], [], [], []] },
        { name: "3⟲ 4⟲", indices: [[], [], [3], [4], [], []] },
        { name: "1⟲ 2⟲ 3⟲", indices: [[1], [2], [3], [], [], []] },
        { name: "2⟲ 3⟲ 4⟲", indices: [[], [2], [3], [4], [], []] },
        { name: "1⟲ 2⟲ 3⟲ 4⟲", indices: [[1], [2], [3], [4], [], []] },
        { name: "1⟲ 2⟲ 3⟲ 4⟲ 5⟲", indices: [[1], [2], [3], [4], [5], []] },
        { name: "1⟲ 2⟲ 3⟲ 4⟲ 5⟲ 6⟲", indices: [[1], [2], [3], [4], [5], [6]] },
        { name: "1→2", indices: [[], [1], [], [], [], []] },
        { name: "1→3", indices: [[], [], [1], [], [], []] },
        { name: "1→4", indices: [[], [], [], [1], [], []] },
        { name: "1→5", indices: [[], [], [], [], [1], []] },
        { name: "1→6", indices: [[], [], [], [], [], [1]] },
        { name: "2→3", indices: [[], [], [2], [], [], []] },
        { name: "2→4", indices: [[], [], [], [2], [], []] },
        { name: "3→4", indices: [[], [], [], [3], [], []] },
        { name: "4→5", indices: [[], [], [], [], [4], []] },
        { name: "1→4 2→5 3→6", indices: [[], [], [], [1], [2], [3]] },
        { name: "1→5 2→6 3→4", indices: [[], [], [], [3], [1], [2]] },
        { name: "1→2→3→4→5→6", indices: [[], [1], [2], [3], [4], [5]] },
        { name: "2→1→6→5→4→3→2", indices: [[2], [3], [4], [5], [6], [1]] },
        { name: "1→2→3→4→5→6→1", indices: [[6], [1], [2], [3], [4], [5]] },
        { name: "1↔2 3↔4 5↔6", indices: [[2], [1], [4], [3], [6], [5]] },
        { name: "1↔4 2↔5 3↔6", indices: [[4], [5], [6], [1], [2], [3]] },
        {
          name: "(1,2,3,4,5)→6",
          indices: [[], [], [], [], [], [1, 2, 3, 4, 5]],
        },
        {
          name: "ALL",
          indices: [
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6],
          ],
        },
      ])),
      (Config.chipNoiseLength = 32768),
      (Config.spectrumNoiseLength = 32768),
      (Config.spectrumBasePitch = 24),
      (Config.spectrumControlPoints = 30),
      (Config.spectrumControlPointsPerOctave = 7),
      (Config.spectrumControlPointBits = 3),
      (Config.spectrumMax = (1 << Config.spectrumControlPointBits) - 1),
      (Config.harmonicsControlPoints = 28),
      (Config.harmonicsRendered = 64),
      (Config.harmonicsRenderedForPickedString = 256),
      (Config.harmonicsControlPointBits = 3),
      (Config.harmonicsMax = (1 << Config.harmonicsControlPointBits) - 1),
      (Config.harmonicsWavelength = 2048),
      (Config.pulseWidthRange = 50),
      (Config.pulseWidthStepPower = 0.5),
      (Config.supersawVoiceCount = 7),
      (Config.supersawDynamismMax = 6),
      (Config.supersawSpreadMax = 12),
      (Config.supersawShapeMax = 6),
      (Config.pitchChannelCountMin = 1),
      (Config.pitchChannelCountMax = 60),
      (Config.noiseChannelCountMin = 0),
      (Config.noiseChannelCountMax = 32),
      (Config.modChannelCountMin = 0),
      (Config.modChannelCountMax = 24),
      (Config.noiseInterval = 6),
      (Config.pitchesPerOctave = 12),
      (Config.drumCount = 12),
      (Config.pitchOctaves = 8),
      (Config.modCount = 6),
      (Config.maxPitch = Config.pitchOctaves * Config.pitchesPerOctave),
      (Config.maximumTonesPerChannel = 2 * Config.maxChordSize),
      (Config.justIntonationSemitones = [
        0.5,
        8 / 15,
        9 / 16,
        0.6,
        5 / 8,
        2 / 3,
        32 / 45,
        0.75,
        0.8,
        5 / 6,
        8 / 9,
        0.9375,
        1,
        16 / 15,
        9 / 8,
        1.2,
        5 / 4,
        4 / 3,
        45 / 32,
        1.5,
        1.6,
        5 / 3,
        16 / 9,
        15 / 8,
        2,
      ].map((x) => Math.log2(x) * Config.pitchesPerOctave)),
      (Config.pitchShiftRange = Config.justIntonationSemitones.length),
      (Config.pitchShiftCenter = Config.pitchShiftRange >> 1),
      (Config.detuneCenter = 200),
      (Config.detuneMax = 400),
      (Config.detuneMin = 0),
      (Config.songDetuneMin = 0),
      (Config.songDetuneMax = 500),
      (Config.unisonVoicesMin = 1),
      (Config.unisonVoicesMax = 2),
      (Config.unisonSpreadMin = -96),
      (Config.unisonSpreadMax = 96),
      (Config.unisonOffsetMin = -96),
      (Config.unisonOffsetMax = 96),
      (Config.unisonExpressionMin = -2),
      (Config.unisonExpressionMax = 2),
      (Config.unisonSignMin = -2),
      (Config.unisonSignMax = 2),
      (Config.sineWaveLength = 256),
      (Config.sineWaveMask = Config.sineWaveLength - 1),
      (Config.sineWave = generateSineWave()),
      (Config.pickedStringDispersionCenterFreq = 6e3),
      (Config.pickedStringDispersionFreqScale = 0.3),
      (Config.pickedStringDispersionFreqMult = 4),
      (Config.pickedStringShelfHz = 4e3),
      (Config.distortionRange = 8),
      (Config.stringSustainRange = 15),
      (Config.stringDecayRate = 0.12),
      (Config.enableAcousticSustain = !1),
      (Config.sustainTypeNames = ["bright", "acoustic"]),
      (Config.bitcrusherFreqRange = 14),
      (Config.bitcrusherOctaveStep = 0.5),
      (Config.bitcrusherQuantizationRange = 8),
      (Config.maxEnvelopeCount = 12),
      (Config.defaultAutomationRange = 13),
      (Config.instrumentAutomationTargets = toNameMap([
        {
          name: "none",
          computeIndex: null,
          displayName: "none",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: null,
        },
        {
          name: "noteVolume",
          computeIndex: 0,
          displayName: "note volume",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: null,
        },
        {
          name: "pulseWidth",
          computeIndex: 2,
          displayName: "pulse width",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [6, 8],
        },
        {
          name: "stringSustain",
          computeIndex: 3,
          displayName: "sustain",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [7],
        },
        {
          name: "unison",
          computeIndex: 4,
          displayName: "unison",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [0, 5, 7, 9, 6, 2, 3],
        },
        {
          name: "operatorFrequency",
          computeIndex: 5,
          displayName: "fm# freq",
          interleave: !0,
          isFilter: !1,
          maxCount: Config.operatorCount + 2,
          effect: null,
          compatibleInstruments: [1, 11],
        },
        {
          name: "operatorAmplitude",
          computeIndex: 11,
          displayName: "fm# volume",
          interleave: !1,
          isFilter: !1,
          maxCount: Config.operatorCount + 2,
          effect: null,
          compatibleInstruments: [1, 11],
        },
        {
          name: "feedbackAmplitude",
          computeIndex: 17,
          displayName: "fm feedback",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [1, 11],
        },
        {
          name: "pitchShift",
          computeIndex: 18,
          displayName: "pitch shift",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: 7,
          compatibleInstruments: null,
        },
        {
          name: "detune",
          computeIndex: 19,
          displayName: "detune",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: 8,
          compatibleInstruments: null,
        },
        {
          name: "vibratoDepth",
          computeIndex: 20,
          displayName: "vibrato range",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: 9,
          compatibleInstruments: null,
        },
        {
          name: "noteFilterAllFreqs",
          computeIndex: 1,
          displayName: "n. filter freqs",
          interleave: !1,
          isFilter: !0,
          maxCount: 1,
          effect: 5,
          compatibleInstruments: null,
        },
        {
          name: "noteFilterFreq",
          computeIndex: 21,
          displayName: "n. filter # freq",
          interleave: !1,
          isFilter: !0,
          maxCount: Config.filterMaxPoints,
          effect: 5,
          compatibleInstruments: null,
        },
        {
          name: "decimalOffset",
          computeIndex: 37,
          displayName: "decimal offset",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [6, 8],
        },
        {
          name: "supersawDynamism",
          computeIndex: 38,
          displayName: "dynamism",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [8],
        },
        {
          name: "supersawSpread",
          computeIndex: 39,
          displayName: "spread",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [8],
        },
        {
          name: "supersawShape",
          computeIndex: 40,
          displayName: "saw↔pulse",
          interleave: !1,
          isFilter: !1,
          maxCount: 1,
          effect: null,
          compatibleInstruments: [8],
        },
      ])),
      (Config.operatorWaves = toNameMap([
        { name: "sine", samples: Config.sineWave },
        { name: "triangle", samples: generateTriWave() },
        { name: "pulse width", samples: generateSquareWave() },
        { name: "sawtooth", samples: generateSawWave() },
        { name: "ramp", samples: generateSawWave(!0) },
        { name: "trapezoid", samples: generateTrapezoidWave(2) },
        { name: "rounded", samples: generateRoundedSineWave() },
      ])),
      (Config.pwmOperatorWaves = toNameMap([
        { name: "1%", samples: generateSquareWave(0.01) },
        { name: "5%", samples: generateSquareWave(0.05) },
        { name: "12.5%", samples: generateSquareWave(0.125) },
        { name: "25%", samples: generateSquareWave(0.25) },
        { name: "33%", samples: generateSquareWave(1 / 3) },
        { name: "50%", samples: generateSquareWave(0.5) },
        { name: "66%", samples: generateSquareWave(2 / 3) },
        { name: "75%", samples: generateSquareWave(0.75) },
        { name: "87.5%", samples: generateSquareWave(0.875) },
        { name: "95%", samples: generateSquareWave(0.95) },
        { name: "99%", samples: generateSquareWave(0.99) },
      ])),
      (Config.barEditorHeight = 10),
      (Config.modulators = toNameMap([
        {
          name: "none",
          pianoName: "None",
          maxRawVol: 6,
          newNoteVol: 6,
          forSong: !0,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "No Mod Setting",
          promptDesc: [
            "No setting has been chosen yet, so this modulator will have no effect. Try choosing a setting with the dropdown, then click this '?' again for more info.",
            "[$LO - $HI]",
          ],
        },
        {
          name: "song volume",
          pianoName: "Volume",
          maxRawVol: 100,
          newNoteVol: 100,
          forSong: !0,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Song Volume",
          promptDesc: [
            "This setting affects the overall volume of the song, just like the main volume slider.",
            "At $HI, the volume will be unchanged from default, and it will get gradually quieter down to $LO.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "tempo",
          pianoName: "Tempo",
          maxRawVol: Config.tempoMax - Config.tempoMin,
          newNoteVol: Math.ceil((Config.tempoMax - Config.tempoMin) / 2),
          forSong: !0,
          convertRealFactor: Config.tempoMin,
          associatedEffect: 12,
          promptName: "Song Tempo",
          promptDesc: [
            "This setting controls the speed your song plays at, just like the tempo slider.",
            "When you first make a note for this setting, it will default to your current tempo. Raising it speeds up the song, up to $HI BPM, and lowering it slows it down, to a minimum of $LO BPM.",
            "Note that you can make a 'swing' effect by rapidly changing between two tempo values.",
            "[OVERWRITING] [$LO - $HI] [BPM]",
          ],
        },
        {
          name: "song reverb",
          pianoName: "Reverb",
          maxRawVol: 2 * Config.reverbRange,
          newNoteVol: Config.reverbRange,
          forSong: !0,
          convertRealFactor: -Config.reverbRange,
          associatedEffect: 12,
          promptName: "Song Reverb",
          promptDesc: [
            "This setting affects the overall reverb of your song. It works by multiplying existing reverb for instruments, so those with no reverb set will be unaffected.",
            "At $MID, all instruments' reverb will be unchanged from default. This increases up to double the reverb value at $HI, or down to no reverb at $LO.",
            "[MULTIPLICATIVE] [$LO - $HI]",
          ],
        },
        {
          name: "next bar",
          pianoName: "Next Bar",
          maxRawVol: 1,
          newNoteVol: 1,
          forSong: !0,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Go To Next Bar",
          promptDesc: [
            "This setting functions a little different from most. Wherever a note is placed, the song will jump immediately to the next bar when it is encountered.",
            "This jump happens at the very start of the note, so the length of a next-bar note is irrelevant. Also, the note can be value 0 or 1, but the value is also irrelevant - wherever you place a note, the song will jump.",
            "You can make mixed-meter songs or intro sections by cutting off unneeded beats with a next-bar modulator.",
            "[$LO - $HI]",
          ],
        },
        {
          name: "note volume",
          pianoName: "Note Vol.",
          maxRawVol: Config.volumeRange,
          newNoteVol: Math.ceil(Config.volumeRange / 2),
          forSong: !1,
          convertRealFactor: Math.ceil(-Config.volumeRange / 2),
          associatedEffect: 12,
          promptName: "Note Volume",
          promptDesc: [
            "This setting affects the volume of your instrument as if its note size had been scaled.",
            "At $MID, an instrument's volume will be unchanged from default. This means you can still use the volume sliders to mix the base volume of instruments. The volume gradually increases up to $HI, or decreases down to mute at $LO.",
            "This setting was the default for volume modulation in JummBox for a long time. Due to some new effects like distortion and bitcrush, note volume doesn't always allow fine volume control. Also, this modulator affects the value of FM modulator waves instead of just carriers. This can distort the sound which may be useful, but also may be undesirable. In those cases, use the 'mix volume' modulator instead, which will always just scale the volume with no added effects.",
            "For display purposes, this mod will show up on the instrument volume slider, as long as there is not also an active 'mix volume' modulator anyhow. However, as mentioned, it works more like changing note volume.",
            "[MULTIPLICATIVE] [$LO - $HI]",
          ],
        },
        {
          name: "pan",
          pianoName: "Pan",
          maxRawVol: Config.panMax,
          newNoteVol: Math.ceil(Config.panMax / 2),
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 2,
          promptName: "Instrument Panning",
          promptDesc: [
            "This setting controls the panning of your instrument, just like the panning slider.",
            "At $LO, your instrument will sound like it is coming fully from the left-ear side. At $MID it will be right in the middle, and at $HI, it will sound like it's on the right.",
            "[OVERWRITING] [$LO - $HI] [L-R]",
          ],
        },
        {
          name: "reverb",
          pianoName: "Reverb",
          maxRawVol: Config.reverbRange,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 0,
          promptName: "Instrument Reverb",
          promptDesc: [
            "This setting controls the reverb of your insturment, just like the reverb slider.",
            "At $LO, your instrument will have no reverb. At $HI, it will be at maximum.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "distortion",
          pianoName: "Distortion",
          maxRawVol: Config.distortionRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 3,
          promptName: "Instrument Distortion",
          promptDesc: [
            "This setting controls the amount of distortion for your instrument, just like the distortion slider.",
            "At $LO, your instrument will have no distortion. At $HI, it will be at maximum.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "fm slider 1",
          pianoName: "FM 1",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 1",
          promptDesc: [
            "This setting affects the strength of the first FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "fm slider 2",
          pianoName: "FM 2",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 2",
          promptDesc: [
            "This setting affects the strength of the second FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "fm slider 3",
          pianoName: "FM 3",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 3",
          promptDesc: [
            "This setting affects the strength of the third FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "fm slider 4",
          pianoName: "FM 4",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 4",
          promptDesc: [
            "This setting affects the strength of the fourth FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "fm feedback",
          pianoName: "FM Feedback",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Feedback",
          promptDesc: [
            "This setting affects the strength of the FM feedback slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "pulse width",
          pianoName: "Pulse Width",
          maxRawVol: Config.pulseWidthRange,
          newNoteVol: Config.pulseWidthRange,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Pulse Width",
          promptDesc: [
            "This setting controls the width of this instrument's pulse wave, just like the pulse width slider.",
            "At $HI, your instrument will sound like a pure square wave (on 50% of the time). It will gradually sound narrower down to $LO, where it will be inaudible (as it is on 0% of the time).",
            "Changing pulse width randomly between a few values is a common strategy in chiptune music to lend some personality to a lead instrument.",
            "[OVERWRITING] [$LO - $HI] [%Duty]",
          ],
        },
        {
          name: "detune",
          pianoName: "Detune",
          maxRawVol: Config.detuneMax - Config.detuneMin,
          newNoteVol: Config.detuneCenter,
          forSong: !1,
          convertRealFactor: -Config.detuneCenter,
          associatedEffect: 8,
          promptName: "Instrument Detune",
          promptDesc: [
            "This setting controls the detune for this instrument, just like the detune slider.",
            "At $MID, your instrument will have no detune applied. Each tick corresponds to one cent, or one-hundredth of a pitch. Thus, each change of 100 ticks corresponds to one half-step of detune, up to two half-steps up at $HI, or two half-steps down at $LO.",
            "[OVERWRITING] [$LO - $HI] [cents]",
          ],
        },
        {
          name: "vibrato depth",
          pianoName: "Vibrato Depth",
          maxRawVol: 50,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 9,
          promptName: "Vibrato Depth",
          promptDesc: [
            "This setting controls the amount that your pitch moves up and down by during vibrato, just like the vibrato depth slider.",
            "At $LO, your instrument will have no vibrato depth so its vibrato would be inaudible. This increases up to $HI, where an extreme pitch change will be noticeable.",
            "[OVERWRITING] [$LO - $HI] [pitch ÷25]",
          ],
        },
        {
          name: "song detune",
          pianoName: "Detune",
          maxRawVol: Config.songDetuneMax - Config.songDetuneMin,
          newNoteVol: Math.ceil(
            (Config.songDetuneMax - Config.songDetuneMin) / 2
          ),
          forSong: !0,
          convertRealFactor: -250,
          associatedEffect: 12,
          promptName: "Song Detune",
          promptDesc: [
            "This setting controls the overall detune of the entire song. There is no associated slider.",
            "At $MID, your song will have no extra detune applied and sound unchanged from default. Each tick corresponds to four cents, or four hundredths of a pitch. Thus, each change of 25 ticks corresponds to one half-step of detune, up to 10 half-steps up at $HI, or 10 half-steps down at $LO.",
            "[MULTIPLICATIVE] [$LO - $HI] [cents x4]",
          ],
        },
        {
          name: "vibrato speed",
          pianoName: "Vibrato Speed",
          maxRawVol: 30,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 9,
          promptName: "Vibrato Speed",
          promptDesc: [
            "This setting controls the speed your instrument will vibrato at, just like the slider.",
            "A setting of $LO means there will be no oscillation, and vibrato will be disabled. Higher settings will increase the speed, up to a dramatic trill at the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "vibrato delay",
          pianoName: "Vibrato Delay",
          maxRawVol: 50,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 9,
          promptName: "Vibrato Delay",
          promptDesc: [
            "This setting controls the amount of time vibrato will be held off for before triggering for every new note, just like the slider.",
            "A setting of $LO means there will be no delay. A setting of 24 corresponds to one full beat of delay. As a sole exception to this scale, setting delay to $HI will completely disable vibrato (as if it had infinite delay).",
            "[OVERWRITING] [$LO - $HI] [beats ÷24]",
          ],
        },
        {
          name: "arp speed",
          pianoName: "Arp Speed",
          maxRawVol: 50,
          newNoteVol: 12,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 11,
          promptName: "Arpeggio Speed",
          promptDesc: [
            "This setting controls the speed at which your instrument's chords arpeggiate, just like the arpeggio speed slider.",
            "Each setting corresponds to a different speed, from the slowest to the fastest. The speeds are listed below.",
            "[0-4]: x0, x1/16, x⅛, x⅕, x¼,",
            "[5-9]: x⅓, x⅖, x½, x⅔, x¾,",
            "[10-14]: x⅘, x0.9, x1, x1.1, x1.2,",
            "[15-19]: x1.3, x1.4, x1.5, x1.6, x1.7,",
            "[20-24]: x1.8, x1.9, x2, x2.1, x2.2,",
            "[25-29]: x2.3, x2.4, x2.5, x2.6, x2.7,",
            "[30-34]: x2.8, x2.9, x3, x3.1, x3.2,",
            "[35-39]: x3.3, x3.4, x3.5, x3.6, x3.7,",
            "[40-44]: x3.8, x3.9, x4, x4.15, x4.3,",
            "[45-50]: x4.5, x4.8, x5, x5.5, x6, x8",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "pan delay",
          pianoName: "Pan Delay",
          maxRawVol: 20,
          newNoteVol: 10,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 2,
          promptName: "Panning Delay",
          promptDesc: [
            "This setting controls the delay applied to panning for your instrument, just like the pan delay slider.",
            "With more delay, the panning effect will generally be more pronounced. $MID is the default value, whereas $LO will remove any delay at all. No delay can be desirable for chiptune songs.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "reset arp",
          pianoName: "Reset Arp",
          maxRawVol: 1,
          newNoteVol: 1,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 11,
          promptName: "Reset Arpeggio",
          promptDesc: [
            "This setting functions a little different from most. Wherever a note is placed, the arpeggio of this instrument will reset at the very start of that note. This is most noticeable with lower arpeggio speeds. The lengths and values of notes for this setting don't matter, just the note start times.",
            "This mod can be used to sync up your apreggios so that they always sound the same, even if you are using an odd-ratio arpeggio speed or modulating arpeggio speed.",
            "[$LO - $HI]",
          ],
        },
        {
          name: "eq filter",
          pianoName: "EQFlt",
          maxRawVol: 10,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "EQ Filter",
          promptDesc: [
            "This setting controls a few separate things for your instrument's EQ filter.",
            "When the option 'morph' is selected, your modulator values will indicate a sub-filter index of your EQ filter to 'morph' to over time. For example, a change from 0 to 1 means your main filter (default) will morph to sub-filter 1 over the specified duration. You can shape the main filter and sub-filters in the large filter editor ('+' button). If your two filters' number, type, and order of filter dots all match up, the morph will happen smoothly and you'll be able to hear them changing. If they do not match up, the filters will simply jump between each other.",
            "Note that filters will morph based on endpoints in the pattern editor. So, if you specify a morph from sub-filter 1 to 4 but do not specifically drag in new endpoints for 2 and 3, it will morph directly between 1 and 4 without going through the others.",
            "If you target Dot X or Dot Y, you can finely tune the coordinates of a single dot for your filter. The number of available dots to choose is dependent on your main filter's dot count.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "note filter",
          pianoName: "N.Flt",
          maxRawVol: 10,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 5,
          promptName: "Note Filter",
          promptDesc: [
            "This setting controls a few separate things for your instrument's note filter.",
            "When the option 'morph' is selected, your modulator values will indicate a sub-filter index of your note filter to 'morph' to over time. For example, a change from 0 to 1 means your main filter (default) will morph to sub-filter 1 over the specified duration. You can shape the main filter and sub-filters in the large filter editor ('+' button). If your two filters' number, type, and order of filter dots all match up, the morph will happen smoothly and you'll be able to hear them changing. If they do not match up, the filters will simply jump between each other.",
            "Note that filters will morph based on endpoints in the pattern editor. So, if you specify a morph from sub-filter 1 to 4 but do not specifically drag in new endpoints for 2 and 3, it will morph directly between 1 and 4 without going through the others.",
            "If you target Dot X or Dot Y, you can finely tune the coordinates of a single dot for your filter. The number of available dots to choose is dependent on your main filter's dot count.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "bit crush",
          pianoName: "Bitcrush",
          maxRawVol: Config.bitcrusherQuantizationRange - 1,
          newNoteVol: Math.round(Config.bitcrusherQuantizationRange / 2),
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 4,
          promptName: "Instrument Bit Crush",
          promptDesc: [
            "This setting controls the bit crush of your instrument, just like the bit crush slider.",
            "At a value of $LO, no bit crush will be applied. This increases and the bit crush effect gets more noticeable up to the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "freq crush",
          pianoName: "Freq Crush",
          maxRawVol: Config.bitcrusherFreqRange - 1,
          newNoteVol: Math.round(Config.bitcrusherFreqRange / 2),
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 4,
          promptName: "Instrument Frequency Crush",
          promptDesc: [
            "This setting controls the frequency crush of your instrument, just like the freq crush slider.",
            "At a value of $LO, no frequency crush will be applied. This increases and the frequency crush effect gets more noticeable up to the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "echo",
          pianoName: "Echo",
          maxRawVol: Config.echoSustainRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 6,
          promptName: "Instrument Echo Sustain",
          promptDesc: [
            "This setting controls the echo sustain (echo loudness) of your instrument, just like the echo slider.",
            "At $LO, your instrument will have no echo sustain and echo will not be audible. Echo sustain increases and the echo effect gets more noticeable up to the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "echo delay",
          pianoName: "Echo Delay",
          maxRawVol: Config.echoDelayRange,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Instrument Echo Delay",
          promptDesc: [
            "This setting controls the echo delay of your instrument, just like the echo delay slider.",
            "At $LO, your instrument will have very little echo delay, and this increases up to 2 beats of delay at $HI.",
            "[OVERWRITING] [$LO - $HI] [~beats ÷12]",
          ],
        },
        {
          name: "chorus",
          pianoName: "Chorus",
          maxRawVol: Config.chorusRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 1,
          promptName: "Instrument Chorus",
          promptDesc: [
            "This setting controls the chorus strength of your instrument, just like the chorus slider.",
            "At $LO, the chorus effect will be disabled. The strength of the chorus effect increases up to the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "eq filt cut",
          pianoName: "EQFlt Cut",
          maxRawVol: Config.filterSimpleCutRange - 1,
          newNoteVol: Config.filterSimpleCutRange - 1,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "EQ Filter Cutoff Frequency",
          promptDesc: [
            "This setting controls the filter cut position of your instrument, just like the filter cut slider.",
            "This setting is roughly analagous to the horizontal position of a single low-pass dot on the advanced filter editor. At lower values, a wider range of frequencies is cut off.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "eq filt peak",
          pianoName: "EQFlt Peak",
          maxRawVol: Config.filterSimplePeakRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "EQ Filter Peak Gain",
          promptDesc: [
            "This setting controls the filter peak position of your instrument, just like the filter peak slider.",
            "This setting is roughly analagous to the vertical position of a single low-pass dot on the advanced filter editor. At lower values, the cutoff frequency will not be emphasized, and at higher values you will hear emphasis on the cutoff frequency.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "note filt cut",
          pianoName: "N.Flt Cut",
          maxRawVol: Config.filterSimpleCutRange - 1,
          newNoteVol: Config.filterSimpleCutRange - 1,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 5,
          promptName: "Note Filter Cutoff Frequency",
          promptDesc: [
            "This setting controls the filter cut position of your instrument, just like the filter cut slider.",
            "This setting is roughly analagous to the horizontal position of a single low-pass dot on the advanced filter editor. At lower values, a wider range of frequencies is cut off.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "note filt peak",
          pianoName: "N.Flt Peak",
          maxRawVol: Config.filterSimplePeakRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 5,
          promptName: "Note Filter Peak Gain",
          promptDesc: [
            "This setting controls the filter peak position of your instrument, just like the filter peak slider.",
            "This setting is roughly analagous to the vertical position of a single low-pass dot on the advanced filter editor. At lower values, the cutoff frequency will not be emphasized, and at higher values you will hear emphasis on the cutoff frequency.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "pitch shift",
          pianoName: "Pitch Shift",
          maxRawVol: Config.pitchShiftRange - 1,
          newNoteVol: Config.pitchShiftCenter,
          forSong: !1,
          convertRealFactor: -Config.pitchShiftCenter,
          associatedEffect: 7,
          promptName: "Pitch Shift",
          promptDesc: [
            "This setting controls the pitch offset of your instrument, just like the pitch shift slider.",
            "At $MID your instrument will have no pitch shift. This increases as you decrease toward $LO pitches (half-steps) at the low end, or increases towards +$HI pitches at the high end.",
            "[OVERWRITING] [$LO - $HI] [pitch]",
          ],
        },
        {
          name: "sustain",
          pianoName: "Sustain",
          maxRawVol: Config.stringSustainRange - 1,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Picked String Sustain",
          promptDesc: [
            "This setting controls the sustain of your picked string instrument, just like the sustain slider.",
            "At $LO, your instrument will have minimum sustain and sound 'plucky'. This increases to a more held sound as your modulator approaches the maximum, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "mix volume",
          pianoName: "Mix Vol.",
          maxRawVol: Config.volumeRange,
          newNoteVol: Math.ceil(Config.volumeRange / 2),
          forSong: !1,
          convertRealFactor: Math.ceil(-Config.volumeRange / 2),
          associatedEffect: 12,
          promptName: "Mix Volume",
          promptDesc: [
            "This setting affects the volume of your instrument as if its volume slider had been moved.",
            "At $MID, an instrument's volume will be unchanged from default. This means you can still use the volume sliders to mix the base volume of instruments, since this setting and the default value work multiplicatively. The volume gradually increases up to $HI, or decreases down to mute at $LO.",
            "Unlike the 'note volume' setting, mix volume is very straightforward and simply affects the resultant instrument volume after all effects are applied.",
            "[MULTIPLICATIVE] [$LO - $HI]",
          ],
        },
        {
          name: "fm slider 5",
          pianoName: "FM 5",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 5",
          promptDesc: [
            "This setting affects the strength of the fifth FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "fm slider 6",
          pianoName: "FM 6",
          maxRawVol: 15,
          newNoteVol: 15,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "FM Slider 6",
          promptDesc: [
            "This setting affects the strength of the sixth FM slider, just like the corresponding slider on your instrument.",
            "It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.",
            "For the full range of control with this mod, move your underlying slider all the way to the right.",
            "[MULTIPLICATIVE] [$LO - $HI] [%]",
          ],
        },
        {
          name: "decimal offset",
          pianoName: "Decimal Offset",
          maxRawVol: 99,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          invertSliderIndicator: !0,
          associatedEffect: 12,
          promptName: "Decimal Offset",
          promptDesc: [
            "This setting controls the decimal offset that is subtracted from the pulse width; use this for creating values like 12.5 or 6.25.",
            "[$LO - $HI]",
          ],
        },
        {
          name: "envelope speed",
          pianoName: "EnvelopeSpd",
          maxRawVol: 50,
          newNoteVol: 12,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Envelope Speed",
          promptDesc: [
            "This setting controls how fast all of the envelopes for the instrument play.",
            "At $LO, your instrument's envelopes will be frozen, and at values near there they will change very slowly. At 12, the envelopes will work as usual, performing at normal speed. This increases up to $HI, where the envelopes will change very quickly. The speeds are given below:",
            "[0-4]: x0, x1/16, x⅛, x⅕, x¼,",
            "[5-9]: x⅓, x⅖, x½, x⅔, x¾,",
            "[10-14]: x⅘, x0.9, x1, x1.1, x1.2,",
            "[15-19]: x1.3, x1.4, x1.5, x1.6, x1.7,",
            "[20-24]: x1.8, x1.9, x2, x2.1, x2.2,",
            "[25-29]: x2.3, x2.4, x2.5, x2.6, x2.7,",
            "[30-34]: x2.8, x2.9, x3, x3.1, x3.2,",
            "[35-39]: x3.3, x3.4, x3.5, x3.6, x3.7,",
            "[40-44]: x3.8, x3.9, x4, x4.15, x4.3,",
            "[45-50]: x4.5, x4.8, x5, x5.5, x6, x8",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "dynamism",
          pianoName: "Dynamism",
          maxRawVol: Config.supersawDynamismMax,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Supersaw Dynamism",
          promptDesc: [
            "This setting controls the supersaw dynamism of your instrument, just like the dynamism slider.",
            "At $LO, your instrument will have only a single pulse contributing. Increasing this will raise the contribution of other waves which is similar to a chorus effect. The effect gets more noticeable up to the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "spread",
          pianoName: "Spread",
          maxRawVol: Config.supersawSpreadMax,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Supersaw Spread",
          promptDesc: [
            "This setting controls the supersaw spread of your instrument, just like the spread slider.",
            "At $LO, all the pulses in your supersaw will be at the same frequency. Increasing this value raises the frequency spread of the contributing waves, up to a dissonant spread at the max value, $HI.",
            "[OVERWRITING] [$LO - $HI]",
          ],
        },
        {
          name: "saw shape",
          pianoName: "Saw Shape",
          maxRawVol: Config.supersawShapeMax,
          newNoteVol: 0,
          forSong: !1,
          convertRealFactor: 0,
          associatedEffect: 12,
          promptName: "Supersaw Shape",
          promptDesc: [
            "This setting controls the supersaw shape of your instrument, just like the Saw↔Pulse slider.",
            "As the slider's name implies, this effect will give you a sawtooth wave at $LO, and a full pulse width wave at $HI. Values in between will be a blend of the two.",
            "[OVERWRITING] [$LO - $HI] [%]",
          ],
        },
      ])),
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|android|ipad|playbook|silk/i.test(
        navigator.userAgent
      );
    class EditorConfig {
      static valueToPreset(presetValue) {
        var _a;
        const categoryIndex = presetValue >> 6,
          presetIndex = 63 & presetValue;
        return null === (_a = EditorConfig.presetCategories[categoryIndex]) ||
          void 0 === _a
          ? void 0
          : _a.presets[presetIndex];
      }
      static midiProgramToPresetValue(program) {
        for (
          let categoryIndex = 0;
          categoryIndex < EditorConfig.presetCategories.length;
          categoryIndex++
        ) {
          const category = EditorConfig.presetCategories[categoryIndex];
          for (
            let presetIndex = 0;
            presetIndex < category.presets.length;
            presetIndex++
          ) {
            const preset = category.presets[presetIndex];
            if (preset.generalMidi && preset.midiProgram == program)
              return (categoryIndex << 6) + presetIndex;
          }
        }
        return null;
      }
      static nameToPresetValue(presetName) {
        for (
          let categoryIndex = 0;
          categoryIndex < EditorConfig.presetCategories.length;
          categoryIndex++
        ) {
          const category = EditorConfig.presetCategories[categoryIndex];
          for (
            let presetIndex = 0;
            presetIndex < category.presets.length;
            presetIndex++
          ) {
            const preset = category.presets[presetIndex];
            if (preset.name == presetName)
              return (categoryIndex << 6) + presetIndex;
          }
        }
        return null;
      }
      static instrumentToPreset(instrument) {
        var _a;
        return null ===
          (_a = EditorConfig.presetCategories[0].presets.dictionary) ||
          void 0 === _a
          ? void 0
          : _a[null == TypePresets ? void 0 : TypePresets[instrument]];
      }
    }
    function scaleElementsByFactor(array, factor) {
      for (let i = 0; i < array.length; i++) array[i] *= factor;
    }
    function isPowerOf2(n) {
      return !(!n || n & (n - 1));
    }
    function countBits(n) {
      if (!isPowerOf2(n))
        throw new Error("FFT array length must be a power of 2.");
      return Math.round(Math.log(n) / Math.log(2));
    }
    function reverseIndexBits(array, fullArrayLength) {
      const bitCount = countBits(fullArrayLength);
      if (bitCount > 16)
        throw new Error("FFT array length must not be greater than 2^16.");
      const finalShift = 16 - bitCount;
      for (let i = 0; i < fullArrayLength; i++) {
        let j;
        if (
          ((j = ((43690 & i) >> 1) | ((21845 & i) << 1)),
          (j = ((52428 & j) >> 2) | ((13107 & j) << 2)),
          (j = ((61680 & j) >> 4) | ((3855 & j) << 4)),
          (j = ((j >> 8) | ((255 & j) << 8)) >> finalShift),
          j > i)
        ) {
          let temp = array[i];
          (array[i] = array[j]), (array[j] = temp);
        }
      }
    }
    function inverseRealFourierTransform(array, fullArrayLength) {
      const totalPasses = countBits(fullArrayLength);
      if (fullArrayLength < 4)
        throw new Error("FFT array length must be at least 4.");
      for (let pass = totalPasses - 1; pass >= 2; pass--) {
        const subStride = 1 << pass,
          midSubStride = subStride >> 1,
          stride = subStride << 1,
          radiansIncrement = (2 * Math.PI) / stride,
          cosIncrement = Math.cos(radiansIncrement),
          sinIncrement = Math.sin(radiansIncrement),
          oscillatorMultiplier = 2 * cosIncrement;
        for (
          let startIndex = 0;
          startIndex < fullArrayLength;
          startIndex += stride
        ) {
          const startIndexA = startIndex,
            midIndexA = startIndexA + midSubStride,
            startIndexB = startIndexA + subStride,
            midIndexB = startIndexB + midSubStride,
            stopIndex = startIndexB + subStride,
            realStartA = array[startIndexA],
            imagStartB = array[startIndexB];
          (array[startIndexA] = realStartA + imagStartB),
            (array[midIndexA] *= 2),
            (array[startIndexB] = realStartA - imagStartB),
            (array[midIndexB] *= 2);
          let c = cosIncrement,
            s = -sinIncrement,
            cPrev = 1,
            sPrev = 0;
          for (let index = 1; index < midSubStride; index++) {
            const indexA0 = startIndexA + index,
              indexA1 = startIndexB - index,
              indexB0 = startIndexB + index,
              indexB1 = stopIndex - index,
              real0 = array[indexA0],
              real1 = array[indexA1],
              imag0 = array[indexB0],
              imag1 = array[indexB1],
              tempA = real0 - real1,
              tempB = imag0 + imag1;
            (array[indexA0] = real0 + real1),
              (array[indexA1] = imag1 - imag0),
              (array[indexB0] = tempA * c - tempB * s),
              (array[indexB1] = tempB * c + tempA * s);
            const cTemp = oscillatorMultiplier * c - cPrev,
              sTemp = oscillatorMultiplier * s - sPrev;
            (cPrev = c), (sPrev = s), (c = cTemp), (s = sTemp);
          }
        }
      }
      for (let index = 0; index < fullArrayLength; index += 4) {
        const index1 = index + 1,
          index2 = index + 2,
          index3 = index + 3,
          real0 = array[index],
          real1 = 2 * array[index1],
          imag2 = array[index2],
          imag3 = 2 * array[index3],
          tempA = real0 + imag2,
          tempB = real0 - imag2;
        (array[index] = tempA + real1),
          (array[index1] = tempA - real1),
          (array[index2] = tempB + imag3),
          (array[index3] = tempB - imag3);
      }
      reverseIndexBits(array, fullArrayLength);
    }
    (EditorConfig.version = "2.2.9"),
      (EditorConfig.versionDisplayName = "UltraBox " + EditorConfig.version),
      (EditorConfig.releaseNotesURL = "./patch_notes.html"),
      (EditorConfig.isOnMac =
        /^Mac/i.test(navigator.platform) ||
        /Mac OS X/i.test(navigator.userAgent) ||
        /^(iPhone|iPad|iPod)/i.test(navigator.platform) ||
        /(iPhone|iPad|iPod)/i.test(navigator.userAgent)),
      (EditorConfig.ctrlSymbol = EditorConfig.isOnMac ? "⌘" : "Ctrl+"),
      (EditorConfig.ctrlName = EditorConfig.isOnMac ? "command" : "control"),
      (EditorConfig.presetCategories = toNameMap([
        {
          name: "Custom Instruments",
          presets: toNameMap([
            { name: TypePresets[0], customType: 0 },
            { name: TypePresets[1], customType: 1 },
            { name: TypePresets[2], customType: 2 },
            { name: TypePresets[3], customType: 3 },
            { name: TypePresets[4], customType: 4 },
            { name: TypePresets[5], customType: 5 },
            { name: TypePresets[6], customType: 6 },
            { name: TypePresets[7], customType: 7 },
            { name: TypePresets[8], customType: 8 },
            { name: TypePresets[9], customType: 9 },
            { name: TypePresets[11], customType: 11 },
          ]),
        },
        {
          name: "Retro Presets",
          presets: toNameMap([
            {
              name: "square wave",
              midiProgram: 80,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["aliasing"],
                transition: "interrupt",
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                chord: "arpeggio",
                wave: "square",
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "triangle wave",
              midiProgram: 71,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["aliasing"],
                transition: "interrupt",
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                chord: "arpeggio",
                wave: "triangle",
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "square lead",
              midiProgram: 80,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.3536 },
                ],
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                wave: "square",
                unison: "hum",
                envelopes: [],
              },
            },
            {
              name: "sawtooth lead 1",
              midiProgram: 81,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.5 },
                ],
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "shimmer",
                envelopes: [],
              },
            },
            {
              name: "sawtooth lead 2",
              midiProgram: 81,
              settings: {
                type: "chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 1 },
                ],
                effects: ["vibrato", "aliasing"],
                vibrato: "light",
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "hum",
                envelopes: [],
              },
            },
            {
              name: "chip noise",
              midiProgram: 116,
              isNoise: !0,
              settings: {
                type: "noise",
                transition: "hard",
                effects: ["aliasing"],
                chord: "arpeggio",
                filterCutoffHz: 4e3,
                filterResonance: 0,
                filterEnvelope: "steady",
                wave: "retro",
              },
            },
            {
              name: "supersaw lead",
              midiProgram: 81,
              settings: {
                type: "supersaw",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 2 },
                ],
                effects: ["reverb"],
                reverb: 67,
                fadeInSeconds: 0,
                fadeOutTicks: -6,
                pulseWidth: 50,
                dynamism: 100,
                spread: 58,
                shape: 0,
                envelopes: [],
              },
            },
            {
              name: "FM twang",
              midiProgram: 32,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 1,
                  },
                ],
              },
            },
            {
              name: "FM bass",
              midiProgram: 36,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "custom interval",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "2×", amplitude: 11 },
                  { frequency: "1×", amplitude: 7 },
                  { frequency: "1×", amplitude: 9 },
                  { frequency: "20×", amplitude: 3 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "FM flute",
              midiProgram: 73,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 6 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 1,
                  },
                ],
              },
            },
            {
              name: "FM organ",
              midiProgram: 16,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["vibrato"],
                vibrato: "delayed",
                transition: "normal",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "custom interval",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "1×", amplitude: 14 },
                  { frequency: "2×", amplitude: 14 },
                  { frequency: "1×", amplitude: 11 },
                  { frequency: "2×", amplitude: 11 },
                ],
                envelopes: [],
              },
            },
            {
              name: "FM sine",
              midiProgram: 55,
              settings: {
                type: "FM",
                transition: "seemless",
                effects: "none",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 0,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "NES Pulse",
              midiProgram: 80,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.5 },
                ],
                unison: "none",
                vibrato: "none",
                envelopes: [],
                customChipWave: [
                  -24, -24, -24, -24, -23, -23, -23, -23, -22, -22, -22, -22,
                  -21, -21, -21, -21, -20, -20, -20, -20, -19, -19, -19, -19,
                  -18, -18, -18, -18, -17, -17, -17, -17, 24, 24, 24, 24, 23,
                  23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 21, 20, 20, 20, 20,
                  19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17,
                ],
              },
            },
            {
              name: "Gameboy Pulse",
              midiProgram: 80,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.5 },
                ],
                unison: "none",
                envelopes: [],
                customChipWave: [
                  -24, -20, -17, -15, -13, -13, -11, -11, -11, -9, -9, -9, -9,
                  -7, -7, -7, -7, -7, -5, -5, -5, -5, -5, -5, -3, -3, -3, -3,
                  -3, -3, -3, -3, 24, 20, 17, 15, 13, 13, 11, 11, 11, 9, 9, 9,
                  9, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3,
                ],
              },
            },
            {
              name: "VRC6 Sawtooth",
              midiProgram: 81,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.5 },
                ],
                unison: "none",
                envelopes: [],
                customChipWave: [
                  -24, -20, -16, -13, -10, -8, -6, -5, -4, -4, 0, 0, 0, 0, 4, 4,
                  4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 12, 12, 12, 12, 12, 12,
                  12, 12, 16, 16, 16, 16, 16, 16, 16, 16, 20, 20, 20, 20, 20,
                  20, 20, 20, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                ],
              },
            },
            {
              name: "Atari Square",
              midiProgram: 80,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.5 },
                ],
                unison: "none",
                envelopes: [],
                customChipWave: [
                  -24, -24, -24, -23, -23, -23, -22, -22, -22, -21, -21, -21,
                  -20, -20, -20, -19, -19, -19, -18, -18, -18, -17, -17, -17,
                  -16, -16, -16, -15, -15, -15, -14, -14, -14, -13, -13, -13,
                  24, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 20, 20, 20,
                  19, 19, 19, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15,
                ],
              },
            },
            {
              name: "Atari Bass",
              midiProgram: 36,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "interrupt",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.5 },
                ],
                unison: "none",
                envelopes: [],
                customChipWave: [
                  -24, -24, -24, -24, -24, -24, -24, -24, -24, 24, 24, 24, 24,
                  24, 24, -24, -24, -24, 24, 24, 24, -24, -24, -24, 24, 24, 24,
                  -24, -24, -24, 24, 24, -24, -24, -24, -24, -24, -24, -24, -24,
                  -24, 24, 24, 24, 24, 24, 24, -24, -24, 24, 24, 24, 24, 24,
                  -24, -24, -24, -24, 24, 24, -24, -24, 24, 24,
                ],
              },
            },
            {
              name: "Sunsoft Bass",
              midiProgram: 36,
              settings: {
                type: "custom chip",
                effects: ["aliasing"],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "arpeggio",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.5 },
                ],
                unison: "none",
                envelopes: [],
                customChipWave: [
                  24, 24, 15, 15, 9, 9, -4, -4, 0, 0, -13, -13, -19, -19, -24,
                  -24, -24, -24, -10, -10, 0, 0, -7, -7, -7, -7, 0, 0, 6, 6, -4,
                  -4, 3, 3, -4, -4, 3, 3, 3, 3, 9, 9, 15, 15, 15, 15, 6, 6, -4,
                  -4, -4, -4, -4, -4, -4, -4, -4, -4, 3, 3, 12, 12, 24, 24,
                ],
              },
            },
          ]),
        },
        {
          name: "Keyboard Presets",
          presets: toNameMap([
            {
              name: "grand piano 1",
              midiProgram: 0,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.7071 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 2.8284 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.125 },
                ],
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                harmonics: [
                  100, 100, 86, 86, 86, 71, 71, 71, 0, 86, 71, 71, 71, 57, 57,
                  71, 57, 14, 57, 57, 57, 57, 57, 57, 57, 57, 29, 57,
                ],
                unison: "piano",
                stringSustain: 79,
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "note size" },
                ],
              },
            },
            {
              name: "bright piano",
              midiProgram: 1,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 1681.79, linearGain: 0.7071 },
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.5 },
                  { type: "peak", cutoffHz: 3363.59, linearGain: 1.4142 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 24,
                chord: "simultaneous",
                harmonics: [
                  100, 100, 86, 86, 71, 71, 0, 71, 71, 71, 71, 71, 71, 14, 57,
                  57, 57, 57, 57, 57, 29, 57, 57, 57, 57, 57, 57, 57,
                ],
                unison: "piano",
                stringSustain: 86,
                envelopes: [],
              },
            },
            {
              name: "electric grand",
              midiProgram: 2,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 0.5 },
                ],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                wave: "1/8 pulse",
                unison: "shimmer",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "honky-tonk piano",
              midiProgram: 3,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 5656.85, linearGain: 0.3536 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                harmonics: [
                  100, 100, 86, 71, 86, 71, 43, 71, 43, 43, 57, 57, 57, 29, 57,
                  57, 57, 57, 57, 57, 43, 57, 57, 57, 43, 43, 43, 43,
                ],
                unison: "honky tonk",
                stringSustain: 71,
                envelopes: [],
              },
            },
            {
              name: "electric piano 1",
              midiProgram: 4,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 3363.59, linearGain: 0.5 },
                ],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                harmonics: [
                  86, 100, 100, 71, 71, 57, 57, 43, 43, 43, 29, 29, 29, 14, 14,
                  14, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0,
                ],
                unison: "none",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 2" },
                ],
              },
            },
            {
              name: "electric piano 2",
              midiProgram: 5,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 13454.34, linearGain: 0.25 },
                ],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "1×", amplitude: 12 },
                  { frequency: "1×", amplitude: 6 },
                  { frequency: "1×", amplitude: 9 },
                  { frequency: "16×", amplitude: 6 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "harpsichord",
              midiProgram: 6,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 250, linearGain: 0.3536 },
                  { type: "peak", cutoffHz: 11313.71, linearGain: 2.8284 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 24,
                chord: "simultaneous",
                harmonics: [
                  100, 100, 100, 86, 57, 86, 86, 86, 86, 57, 57, 71, 71, 86, 86,
                  71, 71, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71,
                ],
                unison: "none",
                stringSustain: 79,
                envelopes: [],
              },
            },
            {
              name: "clavinet",
              midiProgram: 7,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.3536 },
                ],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "3⟲",
                feedbackAmplitude: 6,
                operators: [
                  { frequency: "3×", amplitude: 15 },
                  { frequency: "~1×", amplitude: 6 },
                  { frequency: "8×", amplitude: 4 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 2" },
                  { target: "feedbackAmplitude", envelope: "twang 2" },
                ],
              },
            },
            {
              name: "dulcimer",
              midiProgram: 15,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.3536 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "strum",
                harmonics: [
                  100, 100, 100, 86, 100, 86, 57, 100, 100, 86, 100, 86, 100,
                  86, 100, 71, 57, 71, 71, 100, 86, 71, 86, 86, 100, 86, 86, 86,
                ],
                unison: "piano",
                stringSustain: 79,
                envelopes: [],
              },
            },
            {
              name: "grand piano 2",
              midiProgram: 0,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.7071 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 2.8284 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.125 },
                ],
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                harmonics: [
                  100, 86, 86, 86, 86, 71, 71, 57, 0, 57, 29, 43, 57, 57, 57,
                  43, 43, 0, 29, 43, 43, 43, 43, 43, 43, 29, 0, 29,
                ],
                unison: "piano",
                stringSustain: 79,
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "note size" },
                ],
              },
            },
            {
              name: "grand piano 3",
              midiProgram: 0,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.7071 },
                  { type: "peak", cutoffHz: 1681.79, linearGain: 4 },
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.1768 },
                  { type: "peak", cutoffHz: 3363.59, linearGain: 4 },
                  { type: "peak", cutoffHz: 2378.41, linearGain: 0.25 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.3536 },
                  { type: "high-pass", cutoffHz: 125, linearGain: 0.0884 },
                ],
                reverb: 67,
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                harmonics: [
                  100, 100, 86, 86, 86, 71, 71, 71, 0, 71, 71, 71, 71, 57, 57,
                  71, 57, 14, 57, 57, 57, 57, 57, 57, 57, 57, 29, 57,
                ],
                unison: "piano",
                stringSustain: 86,
                stringSustainType: "acoustic",
                envelopes: [
                  { target: "noteFilterFreq", envelope: "note size", index: 0 },
                  { target: "noteFilterFreq", envelope: "twang 1", index: 1 },
                  { target: "noteFilterFreq", envelope: "twang 1", index: 1 },
                ],
              },
            },
          ]),
        },
        {
          name: "Idiophone Presets",
          presets: toNameMap([
            {
              name: "celesta",
              midiProgram: 8,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 5657,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "~1×", amplitude: 11, envelope: "custom" },
                  { frequency: "8×", amplitude: 6, envelope: "custom" },
                  { frequency: "20×", amplitude: 3, envelope: "twang 1" },
                  { frequency: "3×", amplitude: 1, envelope: "twang 2" },
                ],
              },
            },
            {
              name: "glockenspiel",
              midiProgram: 9,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 5657,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "decay 1",
                operators: [
                  { frequency: "1×", amplitude: 7, envelope: "custom" },
                  { frequency: "5×", amplitude: 11, envelope: "custom" },
                  { frequency: "8×", amplitude: 7, envelope: "custom" },
                  { frequency: "20×", amplitude: 2, envelope: "twang 1" },
                ],
              },
            },
            {
              name: "music box 1",
              midiProgram: 10,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.5 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "strum",
                harmonics: [
                  100, 0, 0, 100, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0,
                  86, 0, 0, 0, 0, 0, 0, 71, 0,
                ],
                unison: "none",
                stringSustain: 64,
                envelopes: [],
              },
            },
            {
              name: "music box 2",
              midiProgram: 10,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 0.7071 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "strum",
                harmonics: [
                  100, 57, 57, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  43, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                unison: "none",
                stringSustain: 29,
                envelopes: [],
              },
            },
            {
              name: "vibraphone",
              midiProgram: 11,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1→2→3→4",
                feedbackAmplitude: 3,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 9, envelope: "custom" },
                  { frequency: "~1×", amplitude: 9, envelope: "custom" },
                  { frequency: "9×", amplitude: 3, envelope: "custom" },
                  { frequency: "4×", amplitude: 9, envelope: "custom" },
                ],
              },
            },
            {
              name: "marimba",
              midiProgram: 12,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "decay 1",
                vibrato: "none",
                algorithm: "1 2←(3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 10, envelope: "custom" },
                  { frequency: "4×", amplitude: 6, envelope: "custom" },
                  { frequency: "13×", amplitude: 6, envelope: "twang 1" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "kalimba",
              midiProgram: 108,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "decay 1",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 11, envelope: "custom" },
                  { frequency: "5×", amplitude: 3, envelope: "twang 2" },
                  { frequency: "20×", amplitude: 3, envelope: "twang 1" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "xylophone",
              midiProgram: 13,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 9, envelope: "custom" },
                  { frequency: "6×", amplitude: 9, envelope: "custom" },
                  { frequency: "11×", amplitude: 9, envelope: "custom" },
                  { frequency: "20×", amplitude: 6, envelope: "twang 1" },
                ],
              },
            },
            {
              name: "tubular bell",
              midiProgram: 14,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.5 },
                  { type: "high-pass", cutoffHz: 105.11, linearGain: 0.3536 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 96,
                chord: "strum",
                harmonics: [
                  43, 71, 0, 100, 0, 100, 0, 86, 0, 0, 86, 0, 14, 71, 14, 14,
                  57, 14, 14, 43, 14, 14, 43, 14, 14, 43, 14, 14,
                ],
                unison: "shimmer",
                stringSustain: 86,
                envelopes: [],
              },
            },
            {
              name: "bell synth",
              midiProgram: 14,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "twang 3",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "~2×", amplitude: 10, envelope: "custom" },
                  { frequency: "7×", amplitude: 6, envelope: "twang 3" },
                  { frequency: "20×", amplitude: 1, envelope: "twang 1" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "rain drop",
              midiProgram: 96,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 12, envelope: "custom" },
                  { frequency: "6×", amplitude: 4, envelope: "custom" },
                  { frequency: "20×", amplitude: 3, envelope: "twang 1" },
                  { frequency: "1×", amplitude: 6, envelope: "tremolo1" },
                ],
              },
            },
            {
              name: "crystal",
              midiProgram: 98,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "delayed",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 10, envelope: "custom" },
                  { frequency: "3×", amplitude: 7, envelope: "custom" },
                  { frequency: "6×", amplitude: 4, envelope: "custom" },
                  { frequency: "13×", amplitude: 4, envelope: "custom" },
                ],
              },
            },
            {
              name: "tinkle bell",
              midiProgram: 112,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1→2→3→4",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "~2×", amplitude: 7, envelope: "custom" },
                  { frequency: "5×", amplitude: 7, envelope: "custom" },
                  { frequency: "7×", amplitude: 7, envelope: "custom" },
                  { frequency: "16×", amplitude: 7, envelope: "custom" },
                ],
              },
            },
            {
              name: "agogo",
              midiProgram: 113,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "decay 1",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1→4",
                feedbackAmplitude: 15,
                feedbackEnvelope: "decay 1",
                operators: [
                  { frequency: "2×", amplitude: 9, envelope: "custom" },
                  { frequency: "5×", amplitude: 6, envelope: "custom" },
                  { frequency: "8×", amplitude: 9, envelope: "custom" },
                  { frequency: "13×", amplitude: 11, envelope: "custom" },
                ],
              },
            },
          ]),
        },
        {
          name: "Guitar Presets",
          presets: toNameMap([
            {
              name: "nylon guitar",
              midiProgram: 24,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 5657,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←2←3←4",
                feedbackType: "3⟲",
                feedbackAmplitude: 6,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "5×", amplitude: 2, envelope: "steady" },
                  { frequency: "7×", amplitude: 4, envelope: "steady" },
                ],
              },
            },
            {
              name: "steel guitar",
              midiProgram: 25,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "strum",
                harmonics: [
                  100, 100, 86, 71, 71, 71, 86, 86, 71, 57, 43, 43, 43, 57, 57,
                  57, 57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
                ],
                unison: "none",
                stringSustain: 71,
                envelopes: [],
              },
            },
            {
              name: "jazz guitar",
              midiProgram: 26,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 100, 86, 71, 57, 71, 71, 43, 57, 71, 57, 43, 29, 29, 29,
                  29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0,
                ],
              },
            },
            {
              name: "clean guitar",
              midiProgram: 27,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  86, 100, 100, 100, 86, 57, 86, 100, 100, 100, 71, 57, 43, 71,
                  86, 71, 57, 57, 71, 71, 71, 71, 57, 57, 57, 57, 57, 43,
                ],
              },
            },
            {
              name: "muted guitar",
              midiProgram: 28,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 7,
                feedbackEnvelope: "twang 2",
                operators: [
                  { frequency: "1×", amplitude: 13, envelope: "custom" },
                  { frequency: "1×", amplitude: 4, envelope: "twang 3" },
                  { frequency: "4×", amplitude: 4, envelope: "twang 2" },
                  { frequency: "16×", amplitude: 4, envelope: "twang 1" },
                ],
              },
            },
          ]),
        },
        {
          name: "Picked Bass Presets",
          presets: toNameMap([
            {
              name: "acoustic bass",
              midiProgram: 32,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43, 43, 43,
                  29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14,
                ],
              },
            },
            {
              name: "fingered bass",
              midiProgram: 33,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 86, 71, 57, 71, 43, 57, 29, 29, 29, 29, 29, 29, 14, 14,
                  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 0,
                ],
              },
            },
            {
              name: "picked bass",
              midiProgram: 34,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 0,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "3⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 5, envelope: "steady" },
                  { frequency: "11×", amplitude: 1, envelope: "twang 3" },
                  { frequency: "1×", amplitude: 9, envelope: "steady" },
                ],
              },
            },
            {
              name: "fretless bass",
              midiProgram: 35,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 1e3,
                filterResonance: 14,
                filterEnvelope: "flare 2",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 100, 86, 71, 71, 57, 57, 71, 71, 71, 57, 57, 57, 57, 57,
                  57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29, 14,
                ],
              },
            },
            {
              name: "slap bass 1",
              midiProgram: 36,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 4e3,
                filterResonance: 0,
                filterEnvelope: "twang 1",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 100, 100, 100, 86, 71, 57, 29, 29, 43, 43, 57, 71, 57,
                  29, 29, 43, 57, 57, 57, 43, 43, 43, 57, 71, 71, 71, 71,
                ],
              },
            },
            {
              name: "slap bass 2",
              midiProgram: 37,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 5657,
                filterResonance: 0,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←2←3←4",
                feedbackType: "3⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "3×", amplitude: 13, envelope: "custom" },
                  { frequency: "1×", amplitude: 7, envelope: "steady" },
                  { frequency: "13×", amplitude: 3, envelope: "steady" },
                  { frequency: "1×", amplitude: 11, envelope: "steady" },
                ],
              },
            },
            {
              name: "bass synth 1",
              midiProgram: 38,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "strum",
                filterCutoffHz: 4e3,
                filterResonance: 43,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "3⟲ 4⟲",
                feedbackAmplitude: 9,
                feedbackEnvelope: "twang 2",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "custom" },
                  { frequency: "1×", amplitude: 14, envelope: "twang 1" },
                  { frequency: "~1×", amplitude: 13, envelope: "twang 2" },
                ],
              },
            },
            {
              name: "bass synth 2",
              midiProgram: 39,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 1e3,
                filterResonance: 57,
                filterEnvelope: "punch",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1→2",
                feedbackAmplitude: 4,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "1×", amplitude: 9, envelope: "custom" },
                  { frequency: "1×", amplitude: 9, envelope: "steady" },
                  { frequency: "3×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "bass & lead",
              midiProgram: 87,
              generalMidi: !0,
              settings: {
                type: "chip",
                transition: "hard",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 86,
                filterEnvelope: "twang 2",
                wave: "sawtooth",
                interval: "shimmer",
                vibrato: "none",
              },
            },
            {
              name: "dubstep yoi yoi",
              midiProgram: 87,
              settings: {
                type: "chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 0.7071 },
                ],
                effects: ["note filter", "bitcrusher"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 594.6, linearGain: 11.3137 },
                ],
                bitcrusherOctave: 1.5,
                bitcrusherQuantization: 0,
                transition: "slide",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "arpeggio",
                wave: "sawtooth",
                unison: "none",
                envelopes: [
                  { target: "noteFilterFreq", envelope: "flare 2", index: 0 },
                ],
              },
            },
          ]),
        },
        {
          name: "Picked String Presets",
          presets: toNameMap([
            {
              name: "pizzicato strings",
              midiProgram: 45,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "medium fade",
                chord: "harmony",
                filterCutoffHz: 1e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 7,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "3×", amplitude: 11, envelope: "custom" },
                  { frequency: "6×", amplitude: 9, envelope: "custom" },
                  { frequency: "~1×", amplitude: 10, envelope: "steady" },
                ],
              },
            },
            {
              name: "harp",
              midiProgram: 46,
              generalMidi: !0,
              settings: {
                type: "FM",
                transition: "hard fade",
                effects: "reverb",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 0,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "3⟲",
                feedbackAmplitude: 6,
                feedbackEnvelope: "twang 2",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "4×", amplitude: 6, envelope: "custom" },
                  { frequency: "~2×", amplitude: 3, envelope: "steady" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                ],
              },
            },
            {
              name: "sitar",
              midiProgram: 104,
              generalMidi: !0,
              settings: {
                type: "FM",
                transition: "hard fade",
                effects: "reverb",
                chord: "strum",
                filterCutoffHz: 8e3,
                filterResonance: 57,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 14, envelope: "twang 3" },
                  { frequency: "9×", amplitude: 3, envelope: "twang 3" },
                  { frequency: "16×", amplitude: 9, envelope: "swell 3" },
                ],
              },
            },
            {
              name: "banjo",
              midiProgram: 105,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "2⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "4×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "steady" },
                  { frequency: "11×", amplitude: 3, envelope: "twang 3" },
                  { frequency: "1×", amplitude: 11, envelope: "steady" },
                ],
              },
            },
            {
              name: "ukulele",
              midiProgram: 105,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 0,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "3⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "2×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "9×", amplitude: 4, envelope: "twang 2" },
                  { frequency: "1×", amplitude: 11, envelope: "steady" },
                ],
              },
            },
            {
              name: "shamisen",
              midiProgram: 106,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "3⟲",
                feedbackAmplitude: 9,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 12, envelope: "steady" },
                  { frequency: "16×", amplitude: 4, envelope: "twang 3" },
                  { frequency: "1×", amplitude: 7, envelope: "steady" },
                ],
              },
            },
            {
              name: "koto",
              midiProgram: 107,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 2",
                operators: [
                  { frequency: "~1×", amplitude: 12, envelope: "custom" },
                  { frequency: "6×", amplitude: 10, envelope: "custom" },
                  { frequency: "4×", amplitude: 8, envelope: "twang 3" },
                  { frequency: "~2×", amplitude: 8, envelope: "twang 3" },
                ],
              },
            },
          ]),
        },
        {
          name: "Distortion Presets",
          presets: toNameMap([
            {
              name: "overdrive guitar",
              midiProgram: 29,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.7071 },
                  { type: "high-pass", cutoffHz: 210.22, linearGain: 1 },
                  { type: "low-pass", cutoffHz: 5656.85, linearGain: 1 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 0.5 },
                ],
                effects: ["note filter", "distortion"],
                noteFilter: [
                  { type: "high-pass", cutoffHz: 297.3, linearGain: 2 },
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 0.7071 },
                ],
                distortion: 71,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 12,
                chord: "strum",
                harmonics: [
                  86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71,
                  71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
                ],
                unison: "none",
                stringSustain: 71,
                envelopes: [
                  { target: "noteFilterFreq", envelope: "note size", index: 1 },
                ],
              },
            },
            {
              name: "distortion guitar",
              midiProgram: 30,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.7071 },
                  { type: "high-pass", cutoffHz: 210.22, linearGain: 1 },
                  { type: "low-pass", cutoffHz: 5656.85, linearGain: 1 },
                  { type: "peak", cutoffHz: 594.6, linearGain: 0.3536 },
                  { type: "peak", cutoffHz: 1e3, linearGain: 0.25 },
                ],
                effects: ["note filter", "distortion", "reverb"],
                noteFilter: [
                  { type: "high-pass", cutoffHz: 353.55, linearGain: 2 },
                  { type: "low-pass", cutoffHz: 2e3, linearGain: 1 },
                ],
                distortion: 86,
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 12,
                chord: "strum",
                harmonics: [
                  86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71,
                  71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
                ],
                unison: "none",
                stringSustain: 71,
                envelopes: [
                  { target: "noteFilterFreq", envelope: "note size", index: 1 },
                ],
              },
            },
            {
              name: "charango synth",
              midiProgram: 84,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 11313.71, linearGain: 1 },
                ],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                algorithm: "1←(2 3←4)",
                feedbackType: "1→2→3→4",
                feedbackAmplitude: 8,
                operators: [
                  { frequency: "3×", amplitude: 13 },
                  { frequency: "~1×", amplitude: 5 },
                  { frequency: "4×", amplitude: 6 },
                  { frequency: "3×", amplitude: 7 },
                ],
                envelopes: [
                  { target: "feedbackAmplitude", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "guitar harmonics",
              midiProgram: 31,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [{ type: "low-pass", cutoffHz: 4e3, linearGain: 2 }],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                algorithm: "1←(2 3)←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 2,
                operators: [
                  { frequency: "4×", amplitude: 12 },
                  { frequency: "16×", amplitude: 5 },
                  { frequency: "1×", amplitude: 2 },
                  { frequency: "~1×", amplitude: 12 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 1,
                  },
                  { target: "operatorAmplitude", envelope: "punch", index: 2 },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 1",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "PWM overdrive",
              midiProgram: 29,
              settings: {
                type: "PWM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 5656.85, linearGain: 1.4142 },
                ],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                pulseWidth: 17.67767,
                envelopes: [{ target: "pulseWidth", envelope: "punch" }],
              },
            },
            {
              name: "PWM distortion",
              midiProgram: 30,
              settings: {
                type: "PWM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 3363.59, linearGain: 2 },
                ],
                effects: ["vibrato"],
                vibrato: "delayed",
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                pulseWidth: 50,
                envelopes: [{ target: "pulseWidth", envelope: "swell 1" }],
              },
            },
            {
              name: "FM overdrive",
              midiProgram: 29,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 1 },
                ],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                algorithm: "1←(2 3←4)",
                feedbackType: "1→2",
                feedbackAmplitude: 2,
                operators: [
                  { frequency: "~1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 12 },
                  { frequency: "~2×", amplitude: 6 },
                  { frequency: "1×", amplitude: 12 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 1",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 3",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "punch" },
                ],
              },
            },
            {
              name: "FM distortion",
              midiProgram: 30,
              settings: {
                type: "FM",
                eqFilter: [{ type: "low-pass", cutoffHz: 4e3, linearGain: 2 }],
                effects: ["reverb"],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "strum",
                algorithm: "1←(2 3←4)",
                feedbackType: "1→2",
                feedbackAmplitude: 4,
                operators: [
                  { frequency: "~1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 11 },
                  { frequency: "1×", amplitude: 9 },
                  { frequency: "~2×", amplitude: 4 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 3",
                    index: 3,
                  },
                ],
              },
            },
          ]),
        },
        {
          name: "Bellows Presets",
          presets: toNameMap([
            {
              name: "drawbar organ 1",
              midiProgram: 16,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  86, 86, 0, 86, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
              },
            },
            {
              name: "drawbar organ 2",
              midiProgram: 16,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  86, 29, 71, 86, 71, 14, 0, 100, 0, 0, 0, 86, 0, 0, 0, 71, 0,
                  0, 0, 57, 0, 0, 0, 29, 0, 0, 0, 0,
                ],
              },
            },
            {
              name: "percussive organ",
              midiProgram: 17,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "FM",
                transition: "hard",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "punch",
                vibrato: "light",
                algorithm: "1 2 3 4",
                feedbackType: "1→3 2→4",
                feedbackAmplitude: 7,
                feedbackEnvelope: "decay 1",
                operators: [
                  { frequency: "1×", amplitude: 7, envelope: "custom" },
                  { frequency: "2×", amplitude: 7, envelope: "custom" },
                  { frequency: "3×", amplitude: 8, envelope: "custom" },
                  { frequency: "4×", amplitude: 8, envelope: "custom" },
                ],
              },
            },
            {
              name: "rock organ",
              midiProgram: 18,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "punch",
                vibrato: "delayed",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "flare 1",
                operators: [
                  { frequency: "1×", amplitude: 9, envelope: "custom" },
                  { frequency: "4×", amplitude: 9, envelope: "custom" },
                  { frequency: "6×", amplitude: 9, envelope: "custom" },
                  { frequency: "2×", amplitude: 5, envelope: "steady" },
                ],
              },
            },
            {
              name: "pipe organ",
              midiProgram: 19,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "FM",
                transition: "cross fade",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 8, envelope: "custom" },
                  { frequency: "2×", amplitude: 9, envelope: "custom" },
                  { frequency: "4×", amplitude: 9, envelope: "custom" },
                  { frequency: "8×", amplitude: 8, envelope: "custom" },
                ],
              },
            },
            {
              name: "reed organ",
              midiProgram: 20,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  71, 86, 100, 86, 71, 100, 57, 71, 71, 71, 43, 43, 43, 71, 43,
                  71, 57, 57, 57, 57, 57, 57, 57, 29, 43, 29, 29, 14,
                ],
              },
            },
            {
              name: "accordion",
              midiProgram: 21,
              generalMidi: !0,
              settings: {
                type: "chip",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 0,
                filterEnvelope: "swell 1",
                wave: "double saw",
                interval: "honky tonk",
                vibrato: "none",
              },
            },
            {
              name: "bandoneon",
              midiProgram: 23,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 29,
                filterEnvelope: "swell 1",
                interval: "hum",
                vibrato: "none",
                harmonics: [
                  86, 86, 86, 57, 71, 86, 57, 71, 71, 71, 57, 43, 57, 43, 71,
                  43, 71, 57, 57, 43, 43, 43, 57, 43, 43, 29, 29, 29,
                ],
              },
            },
            {
              name: "bagpipe",
              midiProgram: 109,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 43,
                filterEnvelope: "punch",
                interval: "hum",
                vibrato: "none",
                harmonics: [
                  71, 86, 86, 100, 100, 86, 57, 100, 86, 71, 71, 71, 57, 57, 57,
                  71, 57, 71, 57, 71, 43, 57, 57, 43, 43, 43, 43, 43,
                ],
              },
            },
          ]),
        },
        {
          name: "String Presets",
          presets: toNameMap([
            {
              name: "violin 1",
              midiProgram: 40,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 1.4142 },
                  { type: "high-pass", cutoffHz: 105.11, linearGain: 0.3536 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "delayed",
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0.0413,
                fadeOutTicks: 6,
                chord: "simultaneous",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "1→2",
                feedbackAmplitude: 5,
                operators: [
                  { frequency: "4×", amplitude: 9 },
                  { frequency: "3×", amplitude: 9 },
                  { frequency: "2×", amplitude: 7 },
                  { frequency: "7×", amplitude: 5 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "viola",
              midiProgram: 41,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "delayed",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 8,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "2×", amplitude: 11, envelope: "custom" },
                  { frequency: "7×", amplitude: 7, envelope: "custom" },
                  { frequency: "13×", amplitude: 4, envelope: "custom" },
                  { frequency: "1×", amplitude: 5, envelope: "steady" },
                ],
              },
            },
            {
              name: "cello",
              midiProgram: 42,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 0.1768 },
                  { type: "high-pass", cutoffHz: 297.3, linearGain: 0.7071 },
                  { type: "peak", cutoffHz: 4756.83, linearGain: 5.6569 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 16e3, linearGain: 0.0884 },
                ],
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 12,
                chord: "simultaneous",
                algorithm: "(1 2)←3←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 3,
                operators: [
                  { frequency: "16×", amplitude: 5 },
                  { frequency: "~1×", amplitude: 10 },
                  { frequency: "1×", amplitude: 9 },
                  { frequency: "6×", amplitude: 3 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "swell 1" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "contrabass",
              midiProgram: 43,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "delayed",
                algorithm: "(1 2)←3←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "16×", amplitude: 5, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "steady" },
                  { frequency: "6×", amplitude: 3, envelope: "swell 1" },
                ],
              },
            },
            {
              name: "fiddle",
              midiProgram: 110,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "delayed",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "3⟲ 4⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "2×", amplitude: 10, envelope: "custom" },
                  { frequency: "8×", amplitude: 8, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "steady" },
                  { frequency: "16×", amplitude: 3, envelope: "steady" },
                ],
              },
            },
            {
              name: "tremolo strings",
              midiProgram: 44,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "medium fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 0,
                filterEnvelope: "tremolo4",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1→2→3→4",
                feedbackAmplitude: 12,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 8, envelope: "custom" },
                  { frequency: "~2×", amplitude: 8, envelope: "custom" },
                  { frequency: "4×", amplitude: 8, envelope: "custom" },
                  { frequency: "7×", amplitude: 8, envelope: "custom" },
                ],
              },
            },
            {
              name: "strings",
              midiProgram: 48,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "4⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "4×", amplitude: 9, envelope: "custom" },
                  { frequency: "3×", amplitude: 9, envelope: "custom" },
                  { frequency: "2×", amplitude: 7, envelope: "steady" },
                  { frequency: "7×", amplitude: 3, envelope: "swell 1" },
                ],
              },
            },
            {
              name: "slow strings",
              midiProgram: 49,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "soft fade",
                chord: "harmony",
                filterCutoffHz: 1414,
                filterResonance: 0,
                filterEnvelope: "swell 2",
                vibrato: "none",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "4⟲",
                feedbackAmplitude: 6,
                feedbackEnvelope: "flare 3",
                operators: [
                  { frequency: "4×", amplitude: 10, envelope: "custom" },
                  { frequency: "3×", amplitude: 10, envelope: "custom" },
                  { frequency: "2×", amplitude: 7, envelope: "steady" },
                  { frequency: "7×", amplitude: 4, envelope: "swell 1" },
                ],
              },
            },
            {
              name: "strings synth 1",
              midiProgram: 50,
              generalMidi: !0,
              settings: {
                type: "chip",
                transition: "soft fade",
                effects: "chorus & reverb",
                chord: "harmony",
                filterCutoffHz: 1414,
                filterResonance: 43,
                filterEnvelope: "steady",
                wave: "sawtooth",
                interval: "hum",
                vibrato: "delayed",
              },
            },
            {
              name: "strings synth 2",
              midiProgram: 51,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "soft fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 12,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "3×", amplitude: 6, envelope: "custom" },
                  { frequency: "2×", amplitude: 7, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "custom" },
                  { frequency: "1×", amplitude: 9, envelope: "custom" },
                ],
              },
            },
            {
              name: "orchestra hit 1",
              midiProgram: 55,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 14,
                filterEnvelope: "custom",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 14,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "twang 3" },
                  { frequency: "2×", amplitude: 15, envelope: "flare 3" },
                  { frequency: "4×", amplitude: 15, envelope: "flare 2" },
                  { frequency: "8×", amplitude: 15, envelope: "flare 1" },
                ],
              },
            },
            {
              name: "violin 2",
              midiProgram: 40,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828, linearGain: 1.4142 },
                  { type: "high-pass", cutoffHz: 105.11, linearGain: 0.3536 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "light",
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0.0413,
                fadeOutTicks: 6,
                chord: "simultaneous",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "4⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "twang 3",
                operators: [
                  { frequency: "4×", amplitude: 15, envelope: "custom" },
                  { frequency: "3×", amplitude: 13, envelope: "custom" },
                  { frequency: "2×", amplitude: 7, envelope: "steady" },
                  { frequency: "7×", amplitude: 8, envelope: "swell 1" },
                ],
              },
            },
            {
              name: "orchestra hit 2",
              midiProgram: 55,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "medium fade",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 0,
                filterEnvelope: "decay 1",
                vibrato: "delayed",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 14,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 12, envelope: "custom" },
                  { frequency: "2×", amplitude: 14, envelope: "custom" },
                  { frequency: "3×", amplitude: 12, envelope: "custom" },
                  { frequency: "4×", amplitude: 14, envelope: "custom" },
                ],
              },
            },
            {
              name: "supersaw string",
              midiProgram: 41,
              settings: {
                type: "supersaw",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 1.4142 },
                  { type: "low-pass", cutoffHz: 3363.59, linearGain: 0.1768 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "high-pass", cutoffHz: 500, linearGain: 0.1768 },
                ],
                reverb: 33,
                fadeInSeconds: 0.0263,
                fadeOutTicks: 6,
                pulseWidth: 35.35534,
                dynamism: 83,
                spread: 8,
                shape: 50,
                envelopes: [
                  { target: "noteFilterFreq", envelope: "twang 1", index: 0 },
                ],
              },
            },
            {
              name: "supersaw string 2",
              midiProgram: 41,
              settings: {
                type: "supersaw",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 0.5 },
                  { type: "high-pass", cutoffHz: 594.6, linearGain: 0.25 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 2.8284 },
                  { type: "peak", cutoffHz: 4756.83, linearGain: 2 },
                ],
                eqFilterType: !1,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                envelopeSpeed: 12,
                discreteEnvelope: !1,
                eqSubFilters0: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 0.5 },
                  { type: "high-pass", cutoffHz: 594.6, linearGain: 0.25 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 2.8284 },
                  { type: "peak", cutoffHz: 4756.83, linearGain: 2 },
                ],
                effects: ["note filter", "chorus", "reverb"],
                noteFilterType: !1,
                noteSimpleCut: 10,
                noteSimplePeak: 0,
                noteFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 1 },
                ],
                noteSubFilters0: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 1 },
                ],
                chorus: 57,
                reverb: 42,
                fadeInSeconds: 0.0575,
                fadeOutTicks: -6,
                pulseWidth: 50,
                dynamism: 67,
                spread: 58,
                shape: 0,
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "punch" },
                  { target: "pulseWidth", envelope: "flare 2" },
                ],
              },
            },
          ]),
        },
        {
          name: "Vocal Presets",
          presets: toNameMap([
            {
              name: "choir soprano",
              midiProgram: 94,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 2 },
                  { type: "peak", cutoffHz: 1189.21, linearGain: 5.6569 },
                  { type: "high-pass", cutoffHz: 707.11, linearGain: 2.8284 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 0.25 },
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 11.3137 },
                ],
                effects: ["vibrato", "chorus", "reverb"],
                vibrato: "shaky",
                chorus: 100,
                reverb: 33,
                fadeInSeconds: 0.0413,
                fadeOutTicks: 24,
                harmonics: [
                  100, 100, 86, 57, 29, 29, 57, 71, 57, 29, 14, 14, 14, 29, 43,
                  57, 43, 29, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "choir tenor",
              midiProgram: 52,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "peak", cutoffHz: 1e3, linearGain: 11.3137 },
                  { type: "peak", cutoffHz: 707.11, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 1681.79, linearGain: 0.0884 },
                  { type: "high-pass", cutoffHz: 297.3, linearGain: 0.7071 },
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 11.3137 },
                ],
                effects: ["vibrato", "chorus", "reverb"],
                vibrato: "shaky",
                chorus: 100,
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0.0413,
                fadeOutTicks: 48,
                chord: "simultaneous",
                harmonics: [
                  86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29,
                  29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "choir bass",
              midiProgram: 52,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 11.3137 },
                  { type: "peak", cutoffHz: 594.6, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 1681.79, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 707.11, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 11.3137 },
                ],
                effects: ["vibrato", "chorus", "reverb"],
                vibrato: "shaky",
                chorus: 100,
                reverb: 67,
                transition: "normal",
                fadeInSeconds: 0.0413,
                fadeOutTicks: 48,
                chord: "simultaneous",
                harmonics: [
                  71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43,
                  43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "solo soprano",
              midiProgram: 85,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 2 },
                  { type: "peak", cutoffHz: 1189.21, linearGain: 5.6569 },
                  { type: "high-pass", cutoffHz: 707.11, linearGain: 2.8284 },
                  { type: "peak", cutoffHz: 2e3, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 0.25 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "shaky",
                reverb: 33,
                fadeInSeconds: 0.0413,
                fadeOutTicks: 12,
                harmonics: [
                  86, 100, 86, 43, 14, 14, 57, 71, 57, 14, 14, 14, 14, 14, 43,
                  57, 43, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "solo tenor",
              midiProgram: 85,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "peak", cutoffHz: 1e3, linearGain: 11.3137 },
                  { type: "peak", cutoffHz: 707.11, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 1681.79, linearGain: 0.0884 },
                  { type: "high-pass", cutoffHz: 297.3, linearGain: 0.7071 },
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 11.3137 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "shaky",
                reverb: 33,
                fadeInSeconds: 0.0413,
                fadeOutTicks: 12,
                harmonics: [
                  86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29,
                  29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "solo bass",
              midiProgram: 85,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 594.6, linearGain: 8 },
                  { type: "peak", cutoffHz: 1681.79, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 707.11, linearGain: 0.0884 },
                  { type: "peak", cutoffHz: 840.9, linearGain: 8 },
                  { type: "high-pass", cutoffHz: 210.22, linearGain: 1.4142 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "shaky",
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0.0263,
                fadeOutTicks: 12,
                chord: "simultaneous",
                harmonics: [
                  71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43,
                  43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "voice ooh",
              midiProgram: 53,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 1414,
                filterResonance: 57,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "shaky",
                harmonics: [
                  100, 57, 43, 43, 14, 14, 0, 0, 0, 14, 29, 29, 14, 0, 14, 29,
                  29, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
              },
            },
            {
              name: "voice synth",
              midiProgram: 54,
              generalMidi: !0,
              settings: {
                type: "chip",
                transition: "medium fade",
                effects: "chorus & reverb",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 57,
                filterEnvelope: "steady",
                wave: "rounded",
                interval: "union",
                vibrato: "light",
              },
            },
            {
              name: "vox synth lead",
              midiProgram: 85,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "steady",
                vibrato: "light",
                algorithm: "(1 2 3)←4",
                feedbackType: "1→2→3→4",
                feedbackAmplitude: 2,
                feedbackEnvelope: "punch",
                operators: [
                  { frequency: "2×", amplitude: 10, envelope: "custom" },
                  { frequency: "9×", amplitude: 5, envelope: "custom" },
                  { frequency: "20×", amplitude: 1, envelope: "custom" },
                  { frequency: "~1×", amplitude: 4, envelope: "steady" },
                ],
              },
            },
            {
              name: "tiny robot",
              midiProgram: 85,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["vibrato", "reverb"],
                vibrato: "delayed",
                reverb: 33,
                transition: "slide",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 2,
                operators: [
                  { frequency: "2×", amplitude: 15 },
                  { frequency: "1×", amplitude: 7 },
                  { frequency: "~1×", amplitude: 7 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "operatorAmplitude", envelope: "punch", index: 1 },
                  { target: "feedbackAmplitude", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "yowie",
              midiProgram: 85,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 86,
                filterEnvelope: "tremolo5",
                vibrato: "none",
                algorithm: "1←2←(3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 12,
                feedbackEnvelope: "tremolo3",
                operators: [
                  { frequency: "2×", amplitude: 12, envelope: "custom" },
                  { frequency: "16×", amplitude: 5, envelope: "steady" },
                  { frequency: "1×", amplitude: 5, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "mouse",
              midiProgram: 85,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["vibrato", "reverb"],
                vibrato: "light",
                reverb: 33,
                transition: "slide in pattern",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 5,
                operators: [
                  { frequency: "2×", amplitude: 13 },
                  { frequency: "5×", amplitude: 12 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "noteVolume", envelope: "note size" },
                  { target: "feedbackAmplitude", envelope: "flare 2" },
                ],
              },
            },
            {
              name: "gumdrop",
              midiProgram: 85,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 0,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 0,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "2×", amplitude: 15, envelope: "punch" },
                  { frequency: "4×", amplitude: 15, envelope: "punch" },
                  { frequency: "7×", amplitude: 15, envelope: "punch" },
                  { frequency: "1×", amplitude: 10, envelope: "twang 1" },
                ],
              },
            },
            {
              name: "echo drop",
              midiProgram: 102,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "punch",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "~2×", amplitude: 11, envelope: "custom" },
                  { frequency: "~1×", amplitude: 5, envelope: "steady" },
                  { frequency: "11×", amplitude: 2, envelope: "steady" },
                  { frequency: "16×", amplitude: 5, envelope: "swell 3" },
                ],
              },
            },
            {
              name: "dark choir",
              midiProgram: 85,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 29,
                filterEnvelope: "swell 1",
                spectrum: [
                  43, 14, 14, 14, 14, 14, 14, 100, 14, 14, 14, 57, 14, 14, 100,
                  14, 43, 14, 43, 14, 14, 43, 14, 29, 14, 29, 14, 14, 29, 0,
                ],
              },
            },
          ]),
        },
        {
          name: "Brass Presets",
          presets: toNameMap([
            {
              name: "trumpet",
              midiProgram: 56,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 9,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "steady" },
                  { frequency: "1×", amplitude: 5, envelope: "flare 2" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "trombone",
              midiProgram: 57,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "2⟲",
                feedbackAmplitude: 7,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "tuba",
              midiProgram: 58,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "2⟲",
                feedbackAmplitude: 8,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "muted trumpet",
              midiProgram: 59,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 2.8284 },
                  { type: "peak", cutoffHz: 4e3, linearGain: 2.8284 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 3363.59, linearGain: 1 },
                ],
                reverb: 33,
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 5,
                operators: [
                  { frequency: "1×", amplitude: 13 },
                  { frequency: "1×", amplitude: 5 },
                  { frequency: "9×", amplitude: 5 },
                  { frequency: "13×", amplitude: 7 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "swell 1" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "flare 2" },
                ],
              },
            },
            {
              name: "french horn",
              midiProgram: 60,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 1 },
                  { type: "peak", cutoffHz: 2378.41, linearGain: 2.8284 },
                ],
                effects: ["reverb"],
                reverb: 33,
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 3,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 12 },
                  { frequency: "1×", amplitude: 10 },
                  { frequency: "~1×", amplitude: 8 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 2",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "swell 1" },
                ],
              },
            },
            {
              name: "brass section",
              midiProgram: 61,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "punch",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 6,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 12, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "swell 1" },
                  { frequency: "~1×", amplitude: 10, envelope: "swell 1" },
                ],
              },
            },
            {
              name: "brass synth 1",
              midiProgram: 62,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 11,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 12, envelope: "flare 1" },
                  { frequency: "~1×", amplitude: 8, envelope: "flare 2" },
                ],
              },
            },
            {
              name: "brass synth 2",
              midiProgram: 63,
              generalMidi: !0,
              settings: {
                type: "FM",
                transition: "soft",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 43,
                filterEnvelope: "twang 3",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 9,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "flare 1" },
                  { frequency: "~1×", amplitude: 7, envelope: "flare 1" },
                ],
              },
            },
            {
              name: "pulse brass",
              midiProgram: 62,
              settings: {
                type: "PWM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 29,
                filterEnvelope: "swell 1",
                pulseWidth: 50,
                pulseEnvelope: "flare 3",
                vibrato: "none",
              },
            },
          ]),
        },
        {
          name: "Reed Presets",
          presets: toNameMap([
            {
              name: "soprano sax",
              midiProgram: 64,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←2←3←4",
                feedbackType: "4⟲",
                feedbackAmplitude: 5,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "1×", amplitude: 13, envelope: "custom" },
                  { frequency: "4×", amplitude: 4, envelope: "swell 1" },
                  { frequency: "1×", amplitude: 7, envelope: "steady" },
                  { frequency: "5×", amplitude: 4, envelope: "punch" },
                ],
              },
            },
            {
              name: "alto sax",
              midiProgram: 65,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "punch",
                operators: [
                  { frequency: "1×", amplitude: 13, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "4×", amplitude: 6, envelope: "swell 1" },
                  { frequency: "1×", amplitude: 12, envelope: "steady" },
                ],
              },
            },
            {
              name: "tenor sax",
              midiProgram: 66,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 29,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←2←3←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 6,
                feedbackEnvelope: "swell 1",
                operators: [
                  { frequency: "2×", amplitude: 12, envelope: "custom" },
                  { frequency: "3×", amplitude: 7, envelope: "steady" },
                  { frequency: "1×", amplitude: 3, envelope: "steady" },
                  { frequency: "8×", amplitude: 3, envelope: "steady" },
                ],
              },
            },
            {
              name: "baritone sax",
              midiProgram: 67,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 0,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "swell 2",
                operators: [
                  { frequency: "1×", amplitude: 12, envelope: "custom" },
                  { frequency: "8×", amplitude: 4, envelope: "steady" },
                  { frequency: "4×", amplitude: 5, envelope: "steady" },
                  { frequency: "1×", amplitude: 4, envelope: "punch" },
                ],
              },
            },
            {
              name: "sax synth",
              midiProgram: 64,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 0,
                filterEnvelope: "steady",
                vibrato: "light",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 4,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "4×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 15, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "shehnai",
              midiProgram: 111,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 8e3,
                filterResonance: 0,
                filterEnvelope: "steady",
                vibrato: "light",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 3,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "4×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "oboe",
              midiProgram: 68,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "swell 1",
                vibrato: "none",
                algorithm: "1 2←(3 4)",
                feedbackType: "2⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "tremolo5",
                operators: [
                  { frequency: "1×", amplitude: 7, envelope: "custom" },
                  { frequency: "4×", amplitude: 12, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "6×", amplitude: 2, envelope: "steady" },
                ],
              },
            },
            {
              name: "english horn",
              midiProgram: 69,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1 2←(3 4)",
                feedbackType: "2⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "4×", amplitude: 12, envelope: "custom" },
                  { frequency: "2×", amplitude: 10, envelope: "custom" },
                  { frequency: "1×", amplitude: 8, envelope: "punch" },
                  { frequency: "8×", amplitude: 4, envelope: "steady" },
                ],
              },
            },
            {
              name: "bassoon",
              midiProgram: 70,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 707,
                filterResonance: 57,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 2,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "2×", amplitude: 11, envelope: "custom" },
                  { frequency: "1×", amplitude: 6, envelope: "steady" },
                  { frequency: "6×", amplitude: 6, envelope: "swell 1" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
            {
              name: "clarinet",
              midiProgram: 71,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 1414,
                filterResonance: 14,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71,
                  71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0,
                ],
              },
            },
            {
              name: "harmonica",
              midiProgram: 22,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 29,
                filterEnvelope: "swell 1",
                vibrato: "none",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 9,
                feedbackEnvelope: "tremolo5",
                operators: [
                  { frequency: "2×", amplitude: 14, envelope: "custom" },
                  { frequency: "1×", amplitude: 15, envelope: "steady" },
                  { frequency: "~2×", amplitude: 2, envelope: "twang 3" },
                  { frequency: "1×", amplitude: 0, envelope: "steady" },
                ],
              },
            },
          ]),
        },
        {
          name: "Flute Presets",
          presets: toNameMap([
            {
              name: "flute 1",
              midiProgram: 73,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 14,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←(2 3 4)",
                feedbackType: "4⟲",
                feedbackAmplitude: 7,
                feedbackEnvelope: "decay 2",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "2×", amplitude: 4, envelope: "steady" },
                  { frequency: "1×", amplitude: 3, envelope: "steady" },
                  { frequency: "~1×", amplitude: 1, envelope: "punch" },
                ],
              },
            },
            {
              name: "recorder",
              midiProgram: 74,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 29,
                filterEnvelope: "swell 2",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 43, 57, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29,
                  29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0,
                ],
              },
            },
            {
              name: "whistle",
              midiProgram: 78,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "chorus & reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 43,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "delayed",
                harmonics: [
                  100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0,
                ],
              },
            },
            {
              name: "ocarina",
              midiProgram: 79,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 43,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "none",
                harmonics: [
                  100, 14, 57, 14, 29, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
              },
            },
            {
              name: "piccolo",
              midiProgram: 72,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 43,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1←3 2←4",
                feedbackType: "4⟲",
                feedbackAmplitude: 15,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "1×", amplitude: 10, envelope: "custom" },
                  { frequency: "~2×", amplitude: 3, envelope: "punch" },
                  { frequency: "~1×", amplitude: 5, envelope: "punch" },
                ],
              },
            },
            {
              name: "shakuhachi",
              midiProgram: 77,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "steady",
                vibrato: "delayed",
                algorithm: "1←(2 3←4)",
                feedbackType: "3→4",
                feedbackAmplitude: 15,
                feedbackEnvelope: "steady",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "2×", amplitude: 3, envelope: "punch" },
                  { frequency: "~1×", amplitude: 4, envelope: "twang 1" },
                  { frequency: "20×", amplitude: 15, envelope: "steady" },
                ],
              },
            },
            {
              name: "pan flute",
              midiProgram: 75,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 9513.66, linearGain: 5.6569 },
                ],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "high-pass", cutoffHz: 4756.83, linearGain: 0.7071 },
                ],
                reverb: 33,
                fadeInSeconds: 0.0125,
                fadeOutTicks: -3,
                spectrum: [
                  100, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 71, 0, 0, 14, 0, 57, 0,
                  29, 14, 29, 14, 14, 29, 14, 29, 14, 14, 29, 14,
                ],
                envelopes: [
                  { target: "noteFilterFreq", envelope: "twang 1", index: 0 },
                  { target: "noteVolume", envelope: "punch" },
                ],
              },
            },
            {
              name: "blown bottle",
              midiProgram: 76,
              generalMidi: !0,
              settings: {
                type: "FM",
                effects: "chorus & reverb",
                transition: "cross fade",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 57,
                filterEnvelope: "steady",
                vibrato: "none",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 7,
                feedbackEnvelope: "twang 1",
                operators: [
                  { frequency: "1×", amplitude: 15, envelope: "custom" },
                  { frequency: "3×", amplitude: 4, envelope: "custom" },
                  { frequency: "6×", amplitude: 2, envelope: "custom" },
                  { frequency: "11×", amplitude: 2, envelope: "custom" },
                ],
              },
            },
            {
              name: "calliope",
              midiProgram: 82,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                transition: "cross fade",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 5657,
                filterResonance: 14,
                filterEnvelope: "steady",
                spectrum: [
                  100, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 71, 0, 0, 57, 0, 43, 0,
                  29, 14, 14, 29, 14, 14, 14, 14, 14, 14, 14, 14,
                ],
              },
            },
            {
              name: "chiffer",
              midiProgram: 83,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "punch",
                spectrum: [
                  86, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 71, 0, 0, 57, 0, 57, 0, 43,
                  14, 14, 43, 14, 29, 14, 29, 29, 29, 29, 14,
                ],
              },
            },
            {
              name: "breath noise",
              midiProgram: 121,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                eqFilter: [],
                effects: ["chord type", "note filter", "reverb"],
                chord: "strum",
                noteFilter: [
                  { type: "high-pass", cutoffHz: 840.9, linearGain: 0.3536 },
                  { type: "low-pass", cutoffHz: 16e3, linearGain: 0.3536 },
                ],
                reverb: 33,
                fadeInSeconds: 0.0413,
                fadeOutTicks: 12,
                spectrum: [
                  71, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 71, 0, 0, 29, 0, 100, 29,
                  14, 29, 100, 29, 100, 14, 14, 71, 0, 29, 0, 0,
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 1" },
                ],
              },
            },
            {
              name: "flute 2",
              midiProgram: 73,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                effects: "reverb",
                transition: "seamless",
                chord: "harmony",
                filterCutoffHz: 1414,
                filterResonance: 14,
                filterEnvelope: "steady",
                interval: "union",
                vibrato: "delayed",
                harmonics: [
                  100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71,
                  71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0,
                ],
              },
            },
          ]),
        },
        {
          name: "Pad Presets",
          presets: toNameMap([
            {
              name: "new age pad",
              midiProgram: 88,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["chorus"],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 3,
                operators: [
                  { frequency: "2×", amplitude: 14 },
                  { frequency: "~1×", amplitude: 4 },
                  { frequency: "6×", amplitude: 3 },
                  { frequency: "13×", amplitude: 3 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 2",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 2,
                  },
                  { target: "feedbackAmplitude", envelope: "swell 3" },
                ],
              },
            },
            {
              name: "warm pad",
              midiProgram: 89,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 3363.59, linearGain: 1 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: 96,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 7,
                operators: [
                  { frequency: "1×", amplitude: 14 },
                  { frequency: "1×", amplitude: 6 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "swell 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 1",
                    index: 1,
                  },
                ],
              },
            },
            {
              name: "polysynth pad",
              midiProgram: 90,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["vibrato", "note filter", "chorus"],
                vibrato: "delayed",
                noteFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 1 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "honky tonk",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "space voice pad",
              midiProgram: 91,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 2828.43, linearGain: 5.6569 },
                  { type: "peak", cutoffHz: 1414.21, linearGain: 0.1768 },
                ],
                effects: ["chorus"],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                algorithm: "(1 2 3)←4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 5,
                operators: [
                  { frequency: "1×", amplitude: 10 },
                  { frequency: "2×", amplitude: 8 },
                  { frequency: "3×", amplitude: 7 },
                  { frequency: "11×", amplitude: 2 },
                ],
                envelopes: [
                  { target: "operatorAmplitude", envelope: "punch", index: 3 },
                  { target: "feedbackAmplitude", envelope: "swell 2" },
                ],
              },
            },
            {
              name: "bowed glass pad",
              midiProgram: 92,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.5 },
                ],
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: 96,
                chord: "simultaneous",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "1×", amplitude: 10 },
                  { frequency: "2×", amplitude: 12 },
                  { frequency: "3×", amplitude: 7 },
                  { frequency: "7×", amplitude: 4 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 3",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "metallic pad",
              midiProgram: 93,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 0.5 },
                ],
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲",
                feedbackAmplitude: 13,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "~1×", amplitude: 9 },
                  { frequency: "1×", amplitude: 7 },
                  { frequency: "11×", amplitude: 7 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 2",
                    index: 2,
                  },
                  { target: "feedbackAmplitude", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "sweep pad",
              midiProgram: 95,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 4 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: 96,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "hum",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "flare 3" },
                ],
              },
            },
            {
              name: "atmosphere",
              midiProgram: 99,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 1 },
                ],
                effects: ["chorus", "reverb"],
                chorus: 100,
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "strum",
                algorithm: "1←(2 3 4)",
                feedbackType: "3⟲ 4⟲",
                feedbackAmplitude: 3,
                operators: [
                  { frequency: "1×", amplitude: 14 },
                  { frequency: "~1×", amplitude: 10 },
                  { frequency: "3×", amplitude: 7 },
                  { frequency: "1×", amplitude: 7 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 3",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "brightness",
              midiProgram: 100,
              generalMidi: !0,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 2 },
                ],
                effects: ["chorus"],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                harmonics: [
                  100, 86, 86, 86, 43, 57, 43, 71, 43, 43, 43, 57, 43, 43, 57,
                  71, 57, 43, 29, 43, 57, 57, 43, 29, 29, 29, 29, 14,
                ],
                unison: "octave",
                stringSustain: 86,
                envelopes: [],
              },
            },
            {
              name: "goblins",
              midiProgram: 101,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "peak", cutoffHz: 2828.43, linearGain: 11.3137 },
                ],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 1681.79, linearGain: 0.5 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: 96,
                chord: "simultaneous",
                algorithm: "1←2←3←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 10,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "4×", amplitude: 5 },
                  { frequency: "1×", amplitude: 10 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "swell 2" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 3",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "tremolo1",
                    index: 2,
                  },
                  { target: "feedbackAmplitude", envelope: "flare 3" },
                ],
              },
            },
            {
              name: "sci-fi",
              midiProgram: 103,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "peak", cutoffHz: 9513.66, linearGain: 2.8284 },
                ],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 0.5 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 48,
                chord: "simultaneous",
                algorithm: "(1 2)←3←4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 8,
                operators: [
                  { frequency: "~1×", amplitude: 13 },
                  { frequency: "2×", amplitude: 10 },
                  { frequency: "5×", amplitude: 5 },
                  { frequency: "11×", amplitude: 8 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "tremolo5",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "flutter pad",
              midiProgram: 90,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["vibrato", "note filter", "chorus"],
                vibrato: "delayed",
                noteFilter: [
                  { type: "low-pass", cutoffHz: 4e3, linearGain: 4 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                algorithm: "(1 2)←(3 4)",
                feedbackType: "1⟲ 2⟲ 3⟲",
                feedbackAmplitude: 9,
                operators: [
                  { frequency: "1×", amplitude: 13 },
                  { frequency: "5×", amplitude: 7 },
                  { frequency: "7×", amplitude: 5 },
                  { frequency: "~1×", amplitude: 6 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                  {
                    target: "operatorAmplitude",
                    envelope: "tremolo1",
                    index: 2,
                  },
                  { target: "operatorAmplitude", envelope: "punch", index: 3 },
                ],
              },
            },
            {
              name: "feedback pad",
              midiProgram: 89,
              settings: {
                type: "FM",
                eqFilter: [{ type: "peak", cutoffHz: 2378.41, linearGain: 8 }],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: 96,
                chord: "custom interval",
                algorithm: "1 2 3 4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 8,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "~1×", amplitude: 15 },
                ],
                envelopes: [
                  { target: "feedbackAmplitude", envelope: "swell 2" },
                ],
              },
            },
            {
              name: "supersaw pad",
              midiProgram: 93,
              settings: {
                type: "supersaw",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.1768 },
                ],
                effects: ["reverb"],
                reverb: 100,
                fadeInSeconds: 0.0263,
                fadeOutTicks: 24,
                pulseWidth: 50,
                dynamism: 100,
                spread: 58,
                shape: 0,
                envelopes: [],
              },
            },
          ]),
        },
        {
          name: "Drum Presets",
          presets: toNameMap([
            {
              name: "standard drumset",
              midiProgram: 116,
              isNoise: !0,
              settings: {
                type: "drumset",
                effects: "reverb",
                drums: [
                  {
                    filterEnvelope: "twang 1",
                    spectrum: [
                      57, 71, 71, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57,
                      43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                      29, 29,
                    ],
                  },
                  {
                    filterEnvelope: "twang 1",
                    spectrum: [
                      0, 0, 0, 100, 71, 71, 57, 86, 57, 57, 57, 71, 43, 43, 57,
                      43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
                      43,
                    ],
                  },
                  {
                    filterEnvelope: "twang 1",
                    spectrum: [
                      0, 0, 0, 0, 100, 57, 43, 43, 29, 57, 43, 29, 71, 43, 43,
                      43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 43, 43,
                      43,
                    ],
                  },
                  {
                    filterEnvelope: "twang 1",
                    spectrum: [
                      0, 0, 0, 0, 0, 71, 57, 43, 43, 43, 57, 57, 43, 29, 57, 43,
                      43, 43, 29, 43, 57, 43, 43, 43, 43, 43, 43, 29, 43, 43,
                    ],
                  },
                  {
                    filterEnvelope: "decay 2",
                    spectrum: [
                      0, 14, 29, 43, 86, 71, 29, 43, 43, 43, 43, 29, 71, 29, 71,
                      29, 43, 43, 43, 43, 57, 43, 43, 57, 43, 43, 43, 57, 57,
                      57,
                    ],
                  },
                  {
                    filterEnvelope: "decay 1",
                    spectrum: [
                      0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 57,
                      71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43,
                      43,
                    ],
                  },
                  {
                    filterEnvelope: "twang 3",
                    spectrum: [
                      43, 43, 43, 71, 29, 29, 43, 43, 43, 29, 43, 43, 43, 29,
                      29, 43, 43, 29, 29, 29, 57, 14, 57, 43, 43, 57, 43, 43,
                      57, 57,
                    ],
                  },
                  {
                    filterEnvelope: "decay 3",
                    spectrum: [
                      29, 43, 43, 43, 43, 29, 29, 43, 29, 29, 43, 29, 14, 29,
                      43, 29, 43, 29, 57, 29, 43, 57, 43, 71, 43, 71, 57, 57,
                      71, 71,
                    ],
                  },
                  {
                    filterEnvelope: "twang 3",
                    spectrum: [
                      43, 29, 29, 43, 29, 29, 29, 57, 29, 29, 29, 57, 43, 43,
                      29, 29, 57, 43, 43, 43, 71, 43, 43, 71, 57, 71, 71, 71,
                      71, 71,
                    ],
                  },
                  {
                    filterEnvelope: "decay 3",
                    spectrum: [
                      57, 57, 57, 43, 57, 57, 43, 43, 57, 43, 43, 43, 71, 57,
                      43, 57, 86, 71, 57, 86, 71, 57, 86, 100, 71, 86, 86, 86,
                      86, 86,
                    ],
                  },
                  {
                    filterEnvelope: "flare 1",
                    spectrum: [
                      0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 71,
                      71, 86, 86, 100, 100, 100, 100, 100, 100, 100, 100, 86,
                      57, 29, 0,
                    ],
                  },
                  {
                    filterEnvelope: "decay 2",
                    spectrum: [
                      14, 14, 14, 14, 29, 14, 14, 29, 14, 43, 14, 43, 57, 86,
                      57, 57, 100, 57, 43, 43, 57, 100, 57, 43, 29, 14, 0, 0, 0,
                      0,
                    ],
                  },
                ],
              },
            },
            {
              name: "steel pan",
              midiProgram: 114,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 62.5, linearGain: 0.1768 },
                ],
                effects: ["note filter", "chorus", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 13454.34, linearGain: 0.25 },
                ],
                chorus: 67,
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 24,
                chord: "simultaneous",
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "~1×", amplitude: 14 },
                  { frequency: "7×", amplitude: 3 },
                  { frequency: "3×", amplitude: 5 },
                  { frequency: "4×", amplitude: 4 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "decay 2" },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 1",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 2",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 2",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "steel pan synth",
              midiProgram: 114,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 13454.34, linearGain: 0.25 },
                ],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                chord: "simultaneous",
                algorithm: "1 2 3←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 5,
                operators: [
                  { frequency: "~1×", amplitude: 12 },
                  { frequency: "2×", amplitude: 15 },
                  { frequency: "4×", amplitude: 14 },
                  { frequency: "~1×", amplitude: 3 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 1" },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 0,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 1",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 2",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "flare 1" },
                ],
              },
            },
            {
              name: "timpani",
              midiProgram: 47,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                eqFilter: [
                  { type: "peak", cutoffHz: 6727.17, linearGain: 5.6569 },
                ],
                effects: ["pitch shift", "note filter", "reverb"],
                pitchShiftSemitones: 15,
                noteFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.5 },
                ],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                spectrum: [
                  100, 0, 0, 0, 86, 0, 0, 71, 0, 14, 43, 14, 43, 43, 0, 29, 43,
                  29, 29, 29, 43, 29, 43, 29, 43, 43, 43, 43, 43, 43,
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 1" },
                  { target: "pitchShift", envelope: "twang 1" },
                ],
              },
            },
            {
              name: "dark strike",
              midiProgram: 47,
              settings: {
                type: "spectrum",
                eqFilter: [],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 0.7071 },
                ],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                spectrum: [
                  0, 0, 14, 14, 14, 29, 29, 43, 43, 86, 43, 43, 43, 29, 86, 29,
                  29, 29, 86, 29, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0,
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 2" },
                ],
              },
            },
            {
              name: "woodblock",
              midiProgram: 115,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -2.5,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                spectrum: [
                  0, 14, 29, 43, 43, 57, 86, 86, 71, 57, 57, 43, 43, 57, 86, 86,
                  43, 43, 71, 57, 57, 57, 57, 57, 86, 86, 71, 71, 71, 71,
                ],
              },
            },
            {
              name: "taiko drum",
              midiProgram: 116,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -0.5,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 29,
                filterEnvelope: "twang 1",
                spectrum: [
                  71, 100, 100, 43, 43, 71, 71, 43, 43, 43, 43, 43, 43, 57, 29,
                  57, 43, 57, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43,
                ],
              },
            },
            {
              name: "melodic drum",
              midiProgram: 117,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -1.5,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2828,
                filterResonance: 43,
                filterEnvelope: "twang 1",
                spectrum: [
                  100, 71, 71, 57, 57, 43, 43, 71, 43, 43, 43, 57, 43, 43, 57,
                  43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                ],
              },
            },
            {
              name: "drum synth",
              midiProgram: 118,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -2,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 43,
                filterEnvelope: "decay 1",
                spectrum: [
                  100, 86, 71, 57, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                  29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                ],
              },
            },
            {
              name: "tom-tom",
              midiProgram: 116,
              isNoise: !0,
              midiSubharmonicOctaves: -1,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "twang 1",
                spectrum: [
                  100, 29, 14, 0, 0, 86, 14, 43, 29, 86, 29, 14, 29, 57, 43, 43,
                  43, 43, 57, 43, 43, 43, 29, 57, 43, 43, 43, 43, 43, 43,
                ],
              },
            },
            {
              name: "metal pipe",
              midiProgram: 117,
              isNoise: !0,
              midiSubharmonicOctaves: -1.5,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 8e3,
                filterResonance: 14,
                filterEnvelope: "twang 2",
                spectrum: [
                  29, 43, 86, 43, 43, 43, 43, 43, 100, 29, 14, 14, 100, 14, 14,
                  0, 0, 0, 0, 0, 14, 29, 29, 14, 0, 0, 14, 29, 0, 0,
                ],
              },
            },
            {
              name: "synth kick",
              midiProgram: 47,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -6,
                chord: "simultaneous",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "8×", amplitude: 15 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  {
                    target: "operatorFrequency",
                    envelope: "twang 1",
                    index: 0,
                  },
                  { target: "noteVolume", envelope: "twang 2" },
                ],
              },
            },
          ]),
        },
        {
          name: "Novelty Presets",
          presets: toNameMap([
            {
              name: "guitar fret noise",
              midiProgram: 120,
              generalMidi: !0,
              settings: {
                type: "spectrum",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 1e3, linearGain: 0.1768 },
                ],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 5.6569 },
                ],
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: -3,
                chord: "simultaneous",
                spectrum: [
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 29, 14, 0,
                  0, 43, 0, 43, 0, 71, 43, 0, 57, 0,
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "flare 1" },
                  { target: "noteVolume", envelope: "twang 2" },
                ],
              },
            },
            {
              name: "fifth saw lead",
              midiProgram: 86,
              generalMidi: !0,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 1.4142 },
                ],
                chorus: 67,
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "fifth",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 3" },
                ],
              },
            },
            {
              name: "fifth swell",
              midiProgram: 86,
              midiSubharmonicOctaves: 1,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 2e3, linearGain: 2 },
                ],
                chorus: 100,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "fifth",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "swell 3" },
                ],
              },
            },
            {
              name: "soundtrack",
              midiProgram: 97,
              generalMidi: !0,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter", "chorus"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 2378.41, linearGain: 0.5 },
                ],
                chorus: 67,
                transition: "normal",
                fadeInSeconds: 0.0413,
                fadeOutTicks: 72,
                chord: "simultaneous",
                wave: "sawtooth",
                unison: "fifth",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "flare 3" },
                ],
              },
            },
            {
              name: "reverse cymbal",
              midiProgram: 119,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -3,
              settings: {
                type: "spectrum",
                effects: "none",
                transition: "soft",
                chord: "harmony",
                filterCutoffHz: 4e3,
                filterResonance: 14,
                filterEnvelope: "swell 3",
                spectrum: [
                  29, 57, 57, 29, 57, 57, 29, 29, 43, 29, 29, 43, 29, 29, 57,
                  57, 14, 57, 14, 57, 71, 71, 57, 86, 57, 100, 86, 86, 86, 86,
                ],
              },
            },
            {
              name: "seashore",
              midiProgram: 122,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -3,
              settings: {
                type: "spectrum",
                transition: "soft fade",
                effects: "reverb",
                chord: "harmony",
                filterCutoffHz: 2828,
                filterResonance: 0,
                filterEnvelope: "swell 3",
                spectrum: [
                  14, 14, 29, 29, 43, 43, 43, 57, 57, 57, 57, 57, 57, 71, 71,
                  71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57,
                ],
              },
            },
            {
              name: "bird tweet",
              midiProgram: 123,
              generalMidi: !0,
              settings: {
                type: "harmonics",
                eqFilter: [],
                effects: ["chord type", "vibrato", "reverb"],
                chord: "strum",
                vibrato: "heavy",
                reverb: 67,
                fadeInSeconds: 0.0575,
                fadeOutTicks: -6,
                harmonics: [
                  0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0,
                ],
                unison: "hum",
                envelopes: [{ target: "noteVolume", envelope: "decay 1" }],
              },
            },
            {
              name: "telephone ring",
              midiProgram: 124,
              generalMidi: !0,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 5656.85, linearGain: 1 },
                ],
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: -3,
                chord: "arpeggio",
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  { frequency: "2×", amplitude: 12 },
                  { frequency: "1×", amplitude: 4 },
                  { frequency: "20×", amplitude: 1 },
                  { frequency: "1×", amplitude: 0 },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "tremolo4" },
                  {
                    target: "operatorAmplitude",
                    envelope: "tremolo1",
                    index: 1,
                  },
                ],
              },
            },
            {
              name: "helicopter",
              midiProgram: 125,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -0.5,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "seamless",
                chord: "arpeggio",
                filterCutoffHz: 1414,
                filterResonance: 14,
                filterEnvelope: "tremolo4",
                spectrum: [
                  14, 43, 43, 57, 57, 57, 71, 71, 71, 71, 86, 86, 86, 86, 86,
                  86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 57, 57,
                ],
              },
            },
            {
              name: "applause",
              midiProgram: 126,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -3,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "soft fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "swell 3",
                spectrum: [
                  14, 14, 29, 29, 29, 43, 43, 57, 71, 71, 86, 86, 86, 71, 71,
                  57, 57, 57, 71, 86, 86, 86, 86, 86, 71, 71, 57, 57, 57, 57,
                ],
              },
            },
            {
              name: "gunshot",
              midiProgram: 127,
              generalMidi: !0,
              isNoise: !0,
              midiSubharmonicOctaves: -2,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "strum",
                filterCutoffHz: 1414,
                filterResonance: 29,
                filterEnvelope: "twang 1",
                spectrum: [
                  14, 29, 43, 43, 57, 57, 57, 71, 71, 71, 86, 86, 86, 86, 86,
                  86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43,
                ],
              },
            },
            {
              name: "scoot",
              midiProgram: 92,
              settings: {
                type: "chip",
                eqFilter: [],
                effects: ["note filter"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 707.11, linearGain: 4 },
                ],
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: -3,
                chord: "simultaneous",
                wave: "double saw",
                unison: "shimmer",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "flare 1" },
                ],
              },
            },
            {
              name: "buzz saw",
              midiProgram: 30,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 9513.66, linearGain: 0.5 },
                ],
                effects: [],
                transition: "normal",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                chord: "custom interval",
                algorithm: "1←2←3←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 4,
                operators: [
                  { frequency: "5×", amplitude: 13 },
                  { frequency: "1×", amplitude: 10 },
                  { frequency: "~1×", amplitude: 6 },
                  { frequency: "11×", amplitude: 12 },
                ],
                envelopes: [],
              },
            },
            {
              name: "mosquito",
              midiProgram: 93,
              settings: {
                type: "PWM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 2828.43, linearGain: 2 },
                ],
                effects: ["vibrato"],
                vibrato: "shaky",
                transition: "normal",
                fadeInSeconds: 0.0575,
                fadeOutTicks: -6,
                chord: "simultaneous",
                pulseWidth: 4.41942,
                envelopes: [{ target: "pulseWidth", envelope: "tremolo6" }],
              },
            },
            {
              name: "breathing",
              midiProgram: 126,
              isNoise: !0,
              midiSubharmonicOctaves: -1,
              settings: {
                type: "spectrum",
                effects: "reverb",
                transition: "hard fade",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 14,
                filterEnvelope: "swell 2",
                spectrum: [
                  14, 14, 14, 29, 29, 29, 29, 29, 43, 29, 29, 43, 43, 43, 29,
                  29, 71, 43, 86, 86, 57, 100, 86, 86, 86, 86, 71, 86, 71, 57,
                ],
              },
            },
            {
              name: "klaxon synth",
              midiProgram: 125,
              isNoise: !0,
              midiSubharmonicOctaves: -1,
              settings: {
                type: "noise",
                effects: "reverb",
                transition: "slide",
                chord: "harmony",
                filterCutoffHz: 2e3,
                filterResonance: 86,
                filterEnvelope: "steady",
                wave: "buzz",
              },
            },
            {
              name: "theremin",
              midiProgram: 40,
              settings: {
                type: "harmonics",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 8e3, linearGain: 0.7071 },
                ],
                effects: ["vibrato", "reverb"],
                vibrato: "heavy",
                reverb: 33,
                transition: "slide in pattern",
                fadeInSeconds: 0.0263,
                fadeOutTicks: -6,
                chord: "simultaneous",
                harmonics: [
                  100, 71, 57, 43, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "sonar ping",
              midiProgram: 121,
              settings: {
                type: "spectrum",
                eqFilter: [],
                effects: ["note filter", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 1681.79, linearGain: 0.5 },
                ],
                reverb: 33,
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
                chord: "simultaneous",
                spectrum: [
                  100, 43, 29, 29, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "twang 2" },
                ],
              },
            },
          ]),
        },
        {
          name: "UltraBox Presets",
          presets: toNameMap([
            {
              name: "nes white",
              midiProgram: 116,
              generalMidi: !0,
              isNoise: !0,
              settings: {
                type: "noise",
                eqFilter: [],
                eqFilterType: !1,
                eqSimpleCut: 8,
                eqSimplePeak: 0,
                eqSubFilters1: [],
                effects: ["panning"],
                pan: 0,
                panDelay: 10,
                fadeInSeconds: 0,
                fadeOutTicks: 0,
                wave: "1-bit white",
                envelopes: [],
              },
            },
            {
              name: "nes ping",
              midiProgram: 116,
              generalMidi: !0,
              isNoise: !0,
              settings: {
                type: "noise",
                eqFilter: [],
                eqFilterType: !1,
                eqSimpleCut: 8,
                eqSimplePeak: 0,
                eqSubFilters1: [],
                effects: ["panning"],
                pan: 0,
                panDelay: 10,
                fadeInSeconds: 0,
                fadeOutTicks: 0,
                wave: "1-bit metallic",
                envelopes: [],
              },
            },
            {
              name: "distorted pulse vocal",
              generalMidi: !1,
              settings: {
                type: "chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.0884 },
                ],
                eqFilterType: !1,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters0: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.0884 },
                ],
                effects: [
                  "panning",
                  "transition type",
                  "pitch shift",
                  "vibrato",
                  "note filter",
                  "bitcrusher",
                  "echo",
                  "reverb",
                ],
                transition: "normal",
                clicklessTransition: !1,
                pitchShiftSemitones: 0,
                vibrato: "delayed",
                vibratoDepth: 0.3,
                vibratoDelay: 18.5,
                vibratoSpeed: 10,
                vibratoType: 0,
                noteFilterType: !1,
                noteSimpleCut: 10,
                noteSimplePeak: 0,
                noteFilter: [
                  { type: "high-pass", cutoffHz: 840.9, linearGain: 11.3137 },
                  { type: "low-pass", cutoffHz: 297.3, linearGain: 8 },
                  { type: "peak", cutoffHz: 500, linearGain: 11.3137 },
                  { type: "high-pass", cutoffHz: 62.5, linearGain: 1.4142 },
                  { type: "peak", cutoffHz: 176.78, linearGain: 11.3137 },
                  { type: "high-pass", cutoffHz: 250, linearGain: 11.3137 },
                ],
                noteSubFilters0: [
                  { type: "high-pass", cutoffHz: 840.9, linearGain: 11.3137 },
                  { type: "low-pass", cutoffHz: 297.3, linearGain: 8 },
                  { type: "peak", cutoffHz: 500, linearGain: 11.3137 },
                  { type: "high-pass", cutoffHz: 62.5, linearGain: 1.4142 },
                  { type: "peak", cutoffHz: 176.78, linearGain: 11.3137 },
                  { type: "high-pass", cutoffHz: 250, linearGain: 11.3137 },
                ],
                bitcrusherOctave: 6.5,
                bitcrusherQuantization: 71,
                pan: 0,
                panDelay: 10,
                echoSustain: 14,
                echoDelayBeats: 0.167,
                reverb: 0,
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                wave: "1/8 pulse",
                unison: "none",
                envelopes: [],
              },
            },
            {
              name: "dubsteb bwah",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.7071 },
                ],
                eqFilterType: !0,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters1: [],
                effects: ["panning", "transition type", "chord type"],
                transition: "interrupt",
                clicklessTransition: !1,
                chord: "custom interval",
                fastTwoNoteArp: !1,
                arpeggioSpeed: 12,
                pan: 0,
                panDelay: 10,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 10,
                operators: [
                  {
                    frequency: "2×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "4×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 11,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 13,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [
                  { target: "noteVolume", envelope: "note size" },
                  {
                    target: "operatorAmplitude",
                    envelope: "swell 2",
                    index: 1,
                  },
                  { target: "operatorAmplitude", envelope: "punch", index: 2 },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "FM cool bass",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 1 },
                  { type: "high-pass", cutoffHz: 88.39, linearGain: 1 },
                  { type: "peak", cutoffHz: 1e3, linearGain: 0.7071 },
                ],
                eqFilterType: !1,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters0: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 1 },
                  { type: "high-pass", cutoffHz: 88.39, linearGain: 1 },
                  { type: "peak", cutoffHz: 1e3, linearGain: 0.7071 },
                ],
                effects: [
                  "panning",
                  "transition type",
                  "note filter",
                  "reverb",
                ],
                transition: "interrupt",
                clicklessTransition: !1,
                noteFilterType: !0,
                noteSimpleCut: 9,
                noteSimplePeak: 2,
                noteFilter: [
                  { type: "low-pass", cutoffHz: 7231.23, linearGain: 1 },
                ],
                noteSubFilters1: [
                  { type: "low-pass", cutoffHz: 7231.23, linearGain: 1 },
                ],
                pan: 0,
                panDelay: 10,
                reverb: 0,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                algorithm: "1←(2 3←4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  {
                    frequency: "2×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 8,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 7,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "13×",
                    amplitude: 11,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "punch" },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 3",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "twang 2",
                    index: 3,
                  },
                ],
              },
            },
            {
              name: "FM funky bass",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 9513.66, linearGain: 0.1768 },
                ],
                eqFilterType: !0,
                eqSimpleCut: 5,
                eqSimplePeak: 0,
                eqSubFilters1: [],
                effects: ["panning", "transition type", "reverb"],
                transition: "normal",
                clicklessTransition: !1,
                pan: 0,
                panDelay: 10,
                reverb: 0,
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                algorithm: "1←(2 3 4)",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  {
                    frequency: "1×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "~1×",
                    amplitude: 8,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [
                  { target: "noteVolume", envelope: "punch" },
                  { target: "noteVolume", envelope: "note size" },
                ],
              },
            },
            {
              name: "talking bass",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [],
                effects: ["chord type"],
                chord: "custom interval",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
                algorithm: "1←(2 3)←4",
                feedbackType: "1⟲",
                feedbackAmplitude: 15,
                operators: [
                  { frequency: "1×", amplitude: 15 },
                  { frequency: "2×", amplitude: 8 },
                  { frequency: "2×", amplitude: 5 },
                  { frequency: "1×", amplitude: 12 },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "note size" },
                ],
              },
            },
            {
              name: "synth marimba",
              generalMidi: !1,
              settings: {
                type: "Picked String",
                eqFilter: [
                  { type: "high-pass", cutoffHz: 176.78, linearGain: 1 },
                  { type: "peak", cutoffHz: 4e3, linearGain: 0.5 },
                ],
                effects: ["note filter", "echo"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 6727.17, linearGain: 1.4142 },
                ],
                echoSustain: 71,
                echoDelayBeats: 0.5,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                harmonics: [
                  86, 100, 29, 29, 0, 0, 0, 100, 0, 0, 0, 86, 29, 0, 14, 100, 0,
                  0, 0, 0, 0, 14, 0, 0, 14, 0, 0, 86,
                ],
                unison: "fifth",
                stringSustain: 7,
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "punch" },
                ],
              },
            },
            {
              name: "italian accordian",
              generalMidi: !1,
              settings: {
                type: "custom chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 6e3, linearGain: 0.5 },
                ],
                eqFilterType: !0,
                eqSimpleCut: 8,
                eqSimplePeak: 1,
                eqSubFilters1: [],
                effects: ["panning", "chorus", "reverb"],
                pan: 0,
                panDelay: 10,
                chorus: 71,
                reverb: 45,
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                wave: "square",
                unison: "honky tonk",
                customChipWave: {
                  0: -24,
                  1: -24,
                  2: -24,
                  3: -24,
                  4: -24,
                  5: -24,
                  6: -24,
                  7: -24,
                  8: -24,
                  9: -24,
                  10: -24,
                  11: -24,
                  12: -24,
                  13: -24,
                  14: -24,
                  15: -24,
                  16: 24,
                  17: 24,
                  18: 24,
                  19: 24,
                  20: 24,
                  21: 24,
                  22: 24,
                  23: 24,
                  24: -24,
                  25: -24,
                  26: -24,
                  27: -24,
                  28: -24,
                  29: -24,
                  30: -24,
                  31: -24,
                  32: -24,
                  33: -24,
                  34: -24,
                  35: -24,
                  36: -24,
                  37: -24,
                  38: -24,
                  39: -24,
                  40: 24,
                  41: 24,
                  42: 24,
                  43: 24,
                  44: 24,
                  45: 24,
                  46: 24,
                  47: 24,
                  48: -24,
                  49: -24,
                  50: -24,
                  51: -24,
                  52: -24,
                  53: -24,
                  54: -24,
                  55: -24,
                  56: -24,
                  57: -24,
                  58: -24,
                  59: -24,
                  60: -24,
                  61: -24,
                  62: -24,
                  63: -24,
                },
                customChipWaveIntegral: {
                  0: 0,
                  1: 0,
                  2: 0,
                  3: 0,
                  4: 0,
                  5: 0,
                  6: 0,
                  7: 0,
                  8: 0,
                  9: 0,
                  10: 0,
                  11: 0,
                  12: 0,
                  13: 0,
                  14: 0,
                  15: 0,
                  16: 0,
                  17: 0,
                  18: 0,
                  19: 0,
                  20: 0,
                  21: 0,
                  22: 0,
                  23: 0,
                  24: 0,
                  25: 0,
                  26: 0,
                  27: 0,
                  28: 0,
                  29: 0,
                  30: 0,
                  31: 0,
                  32: 0,
                  33: 0,
                  34: 0,
                  35: 0,
                  36: 0,
                  37: 0,
                  38: 0,
                  39: 0,
                  40: 0,
                  41: 0,
                  42: 0,
                  43: 0,
                  44: 0,
                  45: 0,
                  46: 0,
                  47: 0,
                  48: 0,
                  49: 0,
                  50: 0,
                  51: 0,
                  52: 0,
                  53: 0,
                  54: 0,
                  55: 0,
                  56: 0,
                  57: 0,
                  58: 0,
                  59: 0,
                  60: 0,
                  61: 0,
                  62: 0,
                  63: 0,
                  64: 0,
                },
                envelopes: [],
              },
            },
            {
              name: "chip supersaw",
              generalMidi: !1,
              settings: {
                type: "custom chip",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 0.7071 },
                ],
                eqFilterType: !0,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters1: [],
                effects: [
                  "panning",
                  "transition type",
                  "vibrato",
                  "chorus",
                  "reverb",
                ],
                transition: "interrupt",
                clicklessTransition: !1,
                vibrato: "delayed",
                vibratoDepth: 0.3,
                vibratoDelay: 18.5,
                vibratoSpeed: 10,
                vibratoType: 0,
                pan: 0,
                panDelay: 10,
                chorus: 29,
                reverb: 29,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                wave: "square",
                unison: "dissonant",
                customChipWave: {
                  0: 22,
                  1: 22,
                  2: 16,
                  3: 6,
                  4: 0,
                  5: -3,
                  6: -8,
                  7: -10,
                  8: -13,
                  9: -16,
                  10: -19,
                  11: -19,
                  12: -20,
                  13: -22,
                  14: -22,
                  15: -24,
                  16: -24,
                  17: -24,
                  18: -24,
                  19: -24,
                  20: -24,
                  21: -24,
                  22: -24,
                  23: -24,
                  24: -24,
                  25: -24,
                  26: -24,
                  27: -24,
                  28: -24,
                  29: -24,
                  30: -24,
                  31: 24,
                  32: 24,
                  33: 16,
                  34: 9,
                  35: 6,
                  36: 4,
                  37: 2,
                  38: 0,
                  39: -1,
                  40: -3,
                  41: -4,
                  42: -4,
                  43: -6,
                  44: -6,
                  45: -6,
                  46: -6,
                  47: -5,
                  48: -5,
                  49: -4,
                  50: -2,
                  51: -2,
                  52: 1,
                  53: 4,
                  54: 6,
                  55: 8,
                  56: 10,
                  57: 12,
                  58: 14,
                  59: 16,
                  60: 18,
                  61: 19,
                  62: 22,
                  63: 24,
                },
                customChipWaveIntegral: {
                  0: 0,
                  1: 0,
                  2: 0,
                  3: 0,
                  4: 0,
                  5: 0,
                  6: 0,
                  7: 0,
                  8: 0,
                  9: 0,
                  10: 0,
                  11: 0,
                  12: 0,
                  13: 0,
                  14: 0,
                  15: 0,
                  16: 0,
                  17: 0,
                  18: 0,
                  19: 0,
                  20: 0,
                  21: 0,
                  22: 0,
                  23: 0,
                  24: 0,
                  25: 0,
                  26: 0,
                  27: 0,
                  28: 0,
                  29: 0,
                  30: 0,
                  31: 0,
                  32: 0,
                  33: 0,
                  34: 0,
                  35: 0,
                  36: 0,
                  37: 0,
                  38: 0,
                  39: 0,
                  40: 0,
                  41: 0,
                  42: 0,
                  43: 0,
                  44: 0,
                  45: 0,
                  46: 0,
                  47: 0,
                  48: 0,
                  49: 0,
                  50: 0,
                  51: 0,
                  52: 0,
                  53: 0,
                  54: 0,
                  55: 0,
                  56: 0,
                  57: 0,
                  58: 0,
                  59: 0,
                  60: 0,
                  61: 0,
                  62: 0,
                  63: 0,
                  64: 0,
                },
                envelopes: [],
              },
            },
            {
              name: "fm supersaw",
              generalMidi: !1,
              settings: {
                type: "FM6op",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 1.4142 },
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.7071 },
                ],
                eqFilterType: !1,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters0: [
                  { type: "low-pass", cutoffHz: 19027.31, linearGain: 1.4142 },
                  { type: "high-pass", cutoffHz: 148.65, linearGain: 0.7071 },
                ],
                effects: [
                  "panning",
                  "transition type",
                  "pitch shift",
                  "note filter",
                  "chorus",
                  "reverb",
                ],
                transition: "continue",
                clicklessTransition: !1,
                pitchShiftSemitones: 0,
                noteFilterType: !1,
                noteSimpleCut: 10,
                noteSimplePeak: 0,
                noteFilter: [],
                noteSubFilters0: [],
                noteSubFilters1: [
                  { type: "low-pass", cutoffHz: 4756.83, linearGain: 1 },
                ],
                pan: 0,
                panDelay: 10,
                chorus: 71,
                reverb: 0,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                algorithm: "1 2 3 4 5 6",
                feedbackType: "1⟲",
                feedbackAmplitude: 0,
                operators: [
                  {
                    frequency: "1×",
                    amplitude: 13,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "~1×",
                    amplitude: 15,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "2×",
                    amplitude: 10,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "3×",
                    amplitude: 7,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "4×",
                    amplitude: 9,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "8×",
                    amplitude: 6,
                    waveform: "sawtooth",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [],
              },
            },
            {
              name: "wind",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [
                  { type: "low-pass", cutoffHz: 250.03, linearGain: 11.3137 },
                ],
                eqFilterType: !0,
                eqSimpleCut: 0,
                eqSimplePeak: 7,
                envelopeSpeed: 12,
                discreteEnvelope: !1,
                eqSubFilters1: [],
                effects: ["transition type", "reverb"],
                transition: "continue",
                clicklessTransition: !1,
                panDelay: 10,
                reverb: 0,
                fadeInSeconds: 0,
                fadeOutTicks: -1,
                algorithm: "1←(2 3 4)",
                feedbackType: "1→3 2→4",
                feedbackAmplitude: 15,
                operators: [
                  {
                    frequency: "16×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "16×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "16×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "16×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "1×",
                    amplitude: 0,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [],
              },
            },
            {
              name: "mrow",
              generalMidi: !1,
              settings: {
                type: "FM",
                eqFilter: [],
                eqFilterType: !1,
                eqSimpleCut: 10,
                eqSimplePeak: 0,
                eqSubFilters0: [],
                effects: ["panning", "chord type", "reverb"],
                chord: "custom interval",
                fastTwoNoteArp: !1,
                arpeggioSpeed: 12,
                pan: 0,
                panDelay: 10,
                reverb: 35,
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                algorithm: "1←3 2←4",
                feedbackType: "1⟲ 2⟲ 3⟲ 4⟲",
                feedbackAmplitude: 5,
                operators: [
                  {
                    frequency: "4×",
                    amplitude: 15,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "~2×",
                    amplitude: 13,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "~2×",
                    amplitude: 8,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                  {
                    frequency: "~2×",
                    amplitude: 9,
                    waveform: "sine",
                    pulseWidth: 5,
                  },
                ],
                envelopes: [
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 1",
                    index: 0,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 1,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "note size",
                    index: 2,
                  },
                  {
                    target: "operatorAmplitude",
                    envelope: "flare 3",
                    index: 3,
                  },
                  { target: "feedbackAmplitude", envelope: "flare 1" },
                ],
              },
            },
            {
              name: "vocal why",
              generalMidi: !1,
              settings: {
                type: "harmonics",
                eqFilter: [],
                effects: ["note filter", "panning", "reverb"],
                noteFilter: [
                  { type: "low-pass", cutoffHz: 840.9, linearGain: 11.3137 },
                ],
                pan: 0,
                reverb: 0,
                fadeInSeconds: 0.0263,
                fadeOutTicks: -3,
                harmonics: [
                  100, 86, 29, 29, 14, 14, 0, 14, 14, 43, 71, 100, 100, 86, 71,
                  71, 57, 57, 43, 43, 43, 43, 43, 0, 0, 0, 0, 0,
                ],
                unison: "octave",
                envelopes: [
                  { target: "noteFilterAllFreqs", envelope: "note size" },
                ],
              },
            },
          ]),
        },
      ]));
    class Deque {
      constructor() {
        (this._capacity = 1),
          (this._buffer = [void 0]),
          (this._mask = 0),
          (this._offset = 0),
          (this._count = 0);
      }
      pushFront(element) {
        this._count >= this._capacity && this._expandCapacity(),
          (this._offset = (this._offset - 1) & this._mask),
          (this._buffer[this._offset] = element),
          this._count++;
      }
      pushBack(element) {
        this._count >= this._capacity && this._expandCapacity(),
          (this._buffer[(this._offset + this._count) & this._mask] = element),
          this._count++;
      }
      popFront() {
        if (this._count <= 0) throw new Error("No elements left to pop.");
        const element = this._buffer[this._offset];
        return (
          (this._buffer[this._offset] = void 0),
          (this._offset = (this._offset + 1) & this._mask),
          this._count--,
          element
        );
      }
      popBack() {
        if (this._count <= 0) throw new Error("No elements left to pop.");
        this._count--;
        const index = (this._offset + this._count) & this._mask,
          element = this._buffer[index];
        return (this._buffer[index] = void 0), element;
      }
      peakFront() {
        if (this._count <= 0) throw new Error("No elements left to pop.");
        return this._buffer[this._offset];
      }
      peakBack() {
        if (this._count <= 0) throw new Error("No elements left to pop.");
        return this._buffer[(this._offset + this._count - 1) & this._mask];
      }
      count() {
        return this._count;
      }
      set(index, element) {
        if (index < 0 || index >= this._count) throw new Error("Invalid index");
        this._buffer[(this._offset + index) & this._mask] = element;
      }
      get(index) {
        if (index < 0 || index >= this._count) throw new Error("Invalid index");
        return this._buffer[(this._offset + index) & this._mask];
      }
      remove(index) {
        if (index < 0 || index >= this._count) throw new Error("Invalid index");
        if (index <= this._count >> 1) {
          for (; index > 0; ) this.set(index, this.get(index - 1)), index--;
          this.popFront();
        } else {
          for (index++; index < this._count; )
            this.set(index - 1, this.get(index)), index++;
          this.popBack();
        }
      }
      _expandCapacity() {
        if (this._capacity >= 1073741824) throw new Error("Capacity too big.");
        this._capacity = this._capacity << 1;
        const oldBuffer = this._buffer,
          newBuffer = new Array(this._capacity),
          size = 0 | this._count,
          offset = 0 | this._offset;
        for (let i = 0; i < size; i++)
          newBuffer[i] = oldBuffer[(offset + i) & this._mask];
        for (let i = size; i < this._capacity; i++) newBuffer[i] = void 0;
        (this._offset = 0),
          (this._buffer = newBuffer),
          (this._mask = this._capacity - 1);
      }
    }
    class EventManager {
      constructor() {
        (this.activeEvents = []),
          (this.listeners = {}),
          (this.activeEvents = []),
          (this.listeners = {});
      }
      raise(eventType, eventData, extraEventData) {
        if (null != this.listeners[eventType]) {
          this.activeEvents.push(eventType);
          for (let i = 0; i < this.listeners[eventType].length; i++)
            this.listeners[eventType][i](eventData, extraEventData);
          this.activeEvents.pop();
        }
      }
      listen(eventType, callback) {
        null == this.listeners[eventType] && (this.listeners[eventType] = []),
          this.listeners[eventType].push(callback);
      }
      unlisten(eventType, callback) {
        if (null == this.listeners[eventType]) return;
        const lisen = this.listeners[eventType].indexOf(callback);
        -1 != lisen && this.listeners[eventType].splice(lisen, 1);
      }
      unlistenAll(eventType) {
        null != this.listeners[eventType] && (this.listeners[eventType] = []);
      }
    }
    const events = new EventManager();
    class FilterCoefficients {
      constructor() {
        (this.a = [1]), (this.b = [1]), (this.order = 0);
      }
      linearGain0thOrder(linearGain) {
        (this.b[0] = linearGain), (this.order = 0);
      }
      lowPass1stOrderButterworth(cornerRadiansPerSample) {
        const g = 1 / Math.tan(0.5 * cornerRadiansPerSample),
          a0 = 1 + g;
        (this.a[1] = (1 - g) / a0),
          (this.b[1] = this.b[0] = 1 / a0),
          (this.order = 1);
      }
      lowPass1stOrderSimplified(cornerRadiansPerSample) {
        const g = 2 * Math.sin(0.5 * cornerRadiansPerSample);
        (this.a[1] = g - 1), (this.b[0] = g), (this.b[1] = 0), (this.order = 1);
      }
      highPass1stOrderButterworth(cornerRadiansPerSample) {
        const g = 1 / Math.tan(0.5 * cornerRadiansPerSample),
          a0 = 1 + g;
        (this.a[1] = (1 - g) / a0),
          (this.b[0] = g / a0),
          (this.b[1] = -g / a0),
          (this.order = 1);
      }
      highShelf1stOrder(cornerRadiansPerSample, shelfLinearGain) {
        const tan = Math.tan(0.5 * cornerRadiansPerSample),
          sqrtGain = Math.sqrt(shelfLinearGain),
          g = (tan * sqrtGain - 1) / (tan * sqrtGain + 1),
          a0 = 1;
        (this.a[1] = g / 1),
          (this.b[0] = (1 + g + shelfLinearGain * (1 - g)) / 2),
          (this.b[1] = (1 + g - shelfLinearGain * (1 - g)) / 2),
          (this.order = 1);
      }
      allPass1stOrderInvertPhaseAbove(cornerRadiansPerSample) {
        const g =
          (Math.sin(cornerRadiansPerSample) - 1) /
          Math.cos(cornerRadiansPerSample);
        (this.a[1] = g), (this.b[0] = g), (this.b[1] = 1), (this.order = 1);
      }
      allPass1stOrderFractionalDelay(delay) {
        const g = (1 - delay) / (1 + delay);
        (this.a[1] = g), (this.b[0] = g), (this.b[1] = 1), (this.order = 1);
      }
      lowPass2ndOrderButterworth(cornerRadiansPerSample, peakLinearGain) {
        const alpha = Math.sin(cornerRadiansPerSample) / (2 * peakLinearGain),
          cos = Math.cos(cornerRadiansPerSample),
          a0 = 1 + alpha;
        (this.a[1] = (-2 * cos) / a0),
          (this.a[2] = (1 - alpha) / a0),
          (this.b[2] = this.b[0] = (1 - cos) / (2 * a0)),
          (this.b[1] = (1 - cos) / a0),
          (this.order = 2);
      }
      lowPass2ndOrderSimplified(cornerRadiansPerSample, peakLinearGain) {
        const g = 2 * Math.sin(cornerRadiansPerSample / 2),
          filterResonance = 1 - 1 / (2 * peakLinearGain),
          feedback = filterResonance + filterResonance / (1 - g);
        (this.a[1] = 2 * g + (g - 1) * g * feedback - 2),
          (this.a[2] = (g - 1) * (g - g * feedback - 1)),
          (this.b[0] = g * g),
          (this.b[1] = 0),
          (this.b[2] = 0),
          (this.order = 2);
      }
      highPass2ndOrderButterworth(cornerRadiansPerSample, peakLinearGain) {
        const alpha = Math.sin(cornerRadiansPerSample) / (2 * peakLinearGain),
          cos = Math.cos(cornerRadiansPerSample),
          a0 = 1 + alpha;
        (this.a[1] = (-2 * cos) / a0),
          (this.a[2] = (1 - alpha) / a0),
          (this.b[2] = this.b[0] = (1 + cos) / (2 * a0)),
          (this.b[1] = -(1 + cos) / a0),
          (this.order = 2);
      }
      highShelf2ndOrder(cornerRadiansPerSample, shelfLinearGain, slope) {
        const A = Math.sqrt(shelfLinearGain),
          c = Math.cos(cornerRadiansPerSample),
          Aplus = A + 1,
          Aminus = A - 1,
          alpha =
            0.5 *
            Math.sin(cornerRadiansPerSample) *
            Math.sqrt((Aplus / A) * (1 / slope - 1) + 2),
          sqrtA2Alpha = 2 * Math.sqrt(A) * alpha,
          a0 = Aplus - Aminus * c + sqrtA2Alpha;
        (this.a[1] = (2 * (Aminus - Aplus * c)) / a0),
          (this.a[2] = (Aplus - Aminus * c - sqrtA2Alpha) / a0),
          (this.b[0] = (A * (Aplus + Aminus * c + sqrtA2Alpha)) / a0),
          (this.b[1] = (-2 * A * (Aminus + Aplus * c)) / a0),
          (this.b[2] = (A * (Aplus + Aminus * c - sqrtA2Alpha)) / a0),
          (this.order = 2);
      }
      peak2ndOrder(cornerRadiansPerSample, peakLinearGain, bandWidthScale) {
        const sqrtGain = Math.sqrt(peakLinearGain),
          bandWidth =
            (bandWidthScale * cornerRadiansPerSample) /
            (sqrtGain >= 1 ? sqrtGain : 1 / sqrtGain),
          alpha = Math.tan(0.5 * bandWidth),
          a0 = 1 + alpha / sqrtGain;
        (this.b[0] = (1 + alpha * sqrtGain) / a0),
          (this.b[1] = this.a[1] =
            (-2 * Math.cos(cornerRadiansPerSample)) / a0),
          (this.b[2] = (1 - alpha * sqrtGain) / a0),
          (this.a[2] = (1 - alpha / sqrtGain) / a0),
          (this.order = 2);
      }
    }
    class FrequencyResponse {
      constructor() {
        (this.real = 0), (this.imag = 0), (this.denom = 1);
      }
      analyze(filter, radiansPerSample) {
        this.analyzeComplex(
          filter,
          Math.cos(radiansPerSample),
          Math.sin(radiansPerSample)
        );
      }
      analyzeComplex(filter, real, imag) {
        const a = filter.a,
          b = filter.b,
          realZ1 = real,
          imagZ1 = -imag;
        let realNum = b[0] + b[1] * realZ1,
          imagNum = b[1] * imagZ1,
          realDenom = 1 + a[1] * realZ1,
          imagDenom = a[1] * imagZ1,
          realZ = realZ1,
          imagZ = imagZ1;
        for (let i = 2; i <= filter.order; i++) {
          const realTemp = realZ * realZ1 - imagZ * imagZ1,
            imagTemp = realZ * imagZ1 + imagZ * realZ1;
          (realZ = realTemp),
            (imagZ = imagTemp),
            (realNum += b[i] * realZ),
            (imagNum += b[i] * imagZ),
            (realDenom += a[i] * realZ),
            (imagDenom += a[i] * imagZ);
        }
        (this.denom = realDenom * realDenom + imagDenom * imagDenom),
          (this.real = realNum * realDenom + imagNum * imagDenom),
          (this.imag = imagNum * realDenom - realNum * imagDenom);
      }
      magnitude() {
        return (
          Math.sqrt(this.real * this.real + this.imag * this.imag) / this.denom
        );
      }
      angle() {
        return Math.atan2(this.imag, this.real);
      }
    }
    class DynamicBiquadFilter {
      constructor() {
        (this.a1 = 0),
          (this.a2 = 0),
          (this.b0 = 1),
          (this.b1 = 0),
          (this.b2 = 0),
          (this.a1Delta = 0),
          (this.a2Delta = 0),
          (this.b0Delta = 0),
          (this.b1Delta = 0),
          (this.b2Delta = 0),
          (this.output1 = 0),
          (this.output2 = 0),
          (this.useMultiplicativeInputCoefficients = !1);
      }
      resetOutput() {
        (this.output1 = 0), (this.output2 = 0);
      }
      loadCoefficientsWithGradient(
        start,
        end,
        deltaRate,
        useMultiplicativeInputCoefficients
      ) {
        if (2 != start.order || 2 != end.order) throw new Error();
        (this.a1 = start.a[1]),
          (this.a2 = start.a[2]),
          (this.b0 = start.b[0]),
          (this.b1 = start.b[1]),
          (this.b2 = start.b[2]),
          (this.a1Delta = (end.a[1] - start.a[1]) * deltaRate),
          (this.a2Delta = (end.a[2] - start.a[2]) * deltaRate),
          useMultiplicativeInputCoefficients
            ? ((this.b0Delta = Math.pow(end.b[0] / start.b[0], deltaRate)),
              (this.b1Delta = Math.pow(end.b[1] / start.b[1], deltaRate)),
              (this.b2Delta = Math.pow(end.b[2] / start.b[2], deltaRate)))
            : ((this.b0Delta = (end.b[0] - start.b[0]) * deltaRate),
              (this.b1Delta = (end.b[1] - start.b[1]) * deltaRate),
              (this.b2Delta = (end.b[2] - start.b[2]) * deltaRate)),
          (this.useMultiplicativeInputCoefficients =
            useMultiplicativeInputCoefficients);
      }
    }
    function warpInfinityToNyquist(radians) {
      return 2 * Math.atan(0.5 * radians);
    }
    const epsilon = 1e-24;
    function clamp(min, max, val) {
      return val <= (max -= 1) ? (val >= min ? val : min) : max;
    }
    function validateRange(min, max, val) {
      if (min <= val && val <= max) return val;
      throw new Error(`Value ${val} not in range [${min}, ${max}]`);
    }
    function parseFloatWithDefault(s, defaultValue) {
      let result = parseFloat(s);
      return Number.isNaN(result) && (result = defaultValue), result;
    }
    function parseIntWithDefault(s, defaultValue) {
      let result = parseInt(s);
      return Number.isNaN(result) && (result = defaultValue), result;
    }
    function encode32BitNumber(buffer, x) {
      buffer.push(base64IntToCharCode[(x >>> 30) & 3]),
        buffer.push(base64IntToCharCode[(x >>> 24) & 63]),
        buffer.push(base64IntToCharCode[(x >>> 18) & 63]),
        buffer.push(base64IntToCharCode[(x >>> 12) & 63]),
        buffer.push(base64IntToCharCode[(x >>> 6) & 63]),
        buffer.push(base64IntToCharCode[(x >>> 0) & 63]);
    }
    function decode32BitNumber(compressed, charIndex) {
      let x = 0;
      return (
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 30),
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 24),
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 18),
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 12),
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6),
        (x |= base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 0),
        x
      );
    }
    function encodeUnisonSettings(buffer, v, s, o, e, i) {
      buffer.push(base64IntToCharCode[v]),
        buffer.push(base64IntToCharCode[Number(s > 0)]);
      let cleanS = Math.round(1e3 * Math.abs(s)),
        cleanSDivided = Math.floor(cleanS / 63);
      buffer.push(
        base64IntToCharCode[cleanS % 63],
        base64IntToCharCode[cleanSDivided % 63],
        base64IntToCharCode[Math.floor(cleanSDivided / 63)]
      ),
        buffer.push(base64IntToCharCode[Number(o > 0)]);
      let cleanO = Math.round(1e3 * Math.abs(o)),
        cleanODivided = Math.floor(cleanO / 63);
      buffer.push(
        base64IntToCharCode[cleanO % 63],
        base64IntToCharCode[cleanODivided % 63],
        base64IntToCharCode[Math.floor(cleanODivided / 63)]
      ),
        buffer.push(base64IntToCharCode[Number(e > 0)]);
      let cleanE = Math.round(1e3 * Math.abs(e));
      buffer.push(
        base64IntToCharCode[cleanE % 63],
        base64IntToCharCode[Math.floor(cleanE / 63)]
      ),
        buffer.push(base64IntToCharCode[Number(i > 0)]);
      let cleanI = Math.round(1e3 * Math.abs(i));
      buffer.push(
        base64IntToCharCode[cleanI % 63],
        base64IntToCharCode[Math.floor(cleanI / 63)]
      );
    }
    function convertLegacyKeyToKeyAndOctave(rawKeyIndex) {
      let key = clamp(0, Config.keys.length, rawKeyIndex),
        octave = 0;
      return (
        12 === rawKeyIndex
          ? ((key = 0), (octave = 1))
          : 13 === rawKeyIndex
            ? ((key = 6), (octave = -1))
            : 14 === rawKeyIndex
              ? ((key = 0), (octave = -1))
              : 15 === rawKeyIndex && ((key = 5), (octave = -1)),
        [key, octave]
      );
    }
    const base64IntToCharCode = [
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103,
        104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
        118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 95,
      ],
      base64CharCodeToInt = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62,
        0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 36, 37, 38, 39,
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
        58, 59, 60, 61, 0, 0, 0, 0, 63, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0,
        0, 0, 0, 0,
      ];
    class BitFieldReader {
      constructor(source, startIndex, stopIndex) {
        (this._bits = []), (this._readIndex = 0);
        for (let i = startIndex; i < stopIndex; i++) {
          const value = base64CharCodeToInt[source.charCodeAt(i)];
          this._bits.push((value >> 5) & 1),
            this._bits.push((value >> 4) & 1),
            this._bits.push((value >> 3) & 1),
            this._bits.push((value >> 2) & 1),
            this._bits.push((value >> 1) & 1),
            this._bits.push(1 & value);
        }
      }
      read(bitCount) {
        let result = 0;
        for (; bitCount > 0; )
          (result <<= 1), (result += this._bits[this._readIndex++]), bitCount--;
        return result;
      }
      readLongTail(minValue, minBits) {
        let result = minValue,
          numBits = minBits;
        for (; this._bits[this._readIndex++]; )
          (result += 1 << numBits), numBits++;
        for (; numBits > 0; )
          numBits--, this._bits[this._readIndex++] && (result += 1 << numBits);
        return result;
      }
      readPartDuration() {
        return this.readLongTail(1, 3);
      }
      readLegacyPartDuration() {
        return this.readLongTail(1, 2);
      }
      readPinCount() {
        return this.readLongTail(1, 0);
      }
      readPitchInterval() {
        return this.read(1)
          ? -this.readLongTail(1, 3)
          : this.readLongTail(1, 3);
      }
    }
    class BitFieldWriter {
      constructor() {
        (this._index = 0), (this._bits = []);
      }
      clear() {
        this._index = 0;
      }
      write(bitCount, value) {
        for (bitCount--; bitCount >= 0; )
          (this._bits[this._index++] = (value >>> bitCount) & 1), bitCount--;
      }
      writeLongTail(minValue, minBits, value) {
        if (value < minValue) throw new Error("value out of bounds");
        value -= minValue;
        let numBits = minBits;
        for (; value >= 1 << numBits; )
          (this._bits[this._index++] = 1), (value -= 1 << numBits), numBits++;
        for (this._bits[this._index++] = 0; numBits > 0; )
          numBits--, (this._bits[this._index++] = (value >>> numBits) & 1);
      }
      writePartDuration(value) {
        this.writeLongTail(1, 3, value);
      }
      writePinCount(value) {
        this.writeLongTail(1, 0, value);
      }
      writePitchInterval(value) {
        value < 0
          ? (this.write(1, 1), this.writeLongTail(1, 3, -value))
          : (this.write(1, 0), this.writeLongTail(1, 3, value));
      }
      concat(other) {
        for (let i = 0; i < other._index; i++)
          this._bits[this._index++] = other._bits[i];
      }
      encodeBase64(buffer) {
        for (let i = 0; i < this._index; i += 6) {
          const value =
            (this._bits[i] << 5) |
            (this._bits[i + 1] << 4) |
            (this._bits[i + 2] << 3) |
            (this._bits[i + 3] << 2) |
            (this._bits[i + 4] << 1) |
            this._bits[i + 5];
          buffer.push(base64IntToCharCode[value]);
        }
        return buffer;
      }
      lengthBase64() {
        return Math.ceil(this._index / 6);
      }
    }
    function makeNotePin(interval, time, size) {
      return { interval: interval, time: time, size: size };
    }
    class Note {
      constructor(pitch, start, end, size, fadeout = !1) {
        (this.pitches = [pitch]),
          (this.pins = [
            makeNotePin(0, 0, size),
            makeNotePin(0, end - start, fadeout ? 0 : size),
          ]),
          (this.start = start),
          (this.end = end),
          (this.continuesLastPattern = !1);
      }
      pickMainInterval() {
        let longestFlatIntervalDuration = 0,
          mainInterval = 0;
        for (let pinIndex = 1; pinIndex < this.pins.length; pinIndex++) {
          const pinA = this.pins[pinIndex - 1],
            pinB = this.pins[pinIndex];
          if (pinA.interval == pinB.interval) {
            const duration = pinB.time - pinA.time;
            longestFlatIntervalDuration < duration &&
              ((longestFlatIntervalDuration = duration),
              (mainInterval = pinA.interval));
          }
        }
        if (0 == longestFlatIntervalDuration) {
          let loudestSize = 0;
          for (let pinIndex = 0; pinIndex < this.pins.length; pinIndex++) {
            const pin = this.pins[pinIndex];
            loudestSize < pin.size &&
              ((loudestSize = pin.size), (mainInterval = pin.interval));
          }
        }
        return mainInterval;
      }
      clone() {
        const newNote = new Note(-1, this.start, this.end, 3);
        (newNote.pitches = this.pitches.concat()), (newNote.pins = []);
        for (const pin of this.pins)
          newNote.pins.push(makeNotePin(pin.interval, pin.time, pin.size));
        return (
          (newNote.continuesLastPattern = this.continuesLastPattern), newNote
        );
      }
      getEndPinIndex(part) {
        let endPinIndex;
        for (
          endPinIndex = 1;
          endPinIndex < this.pins.length - 1 &&
          !(this.pins[endPinIndex].time + this.start > part);
          endPinIndex++
        );
        return endPinIndex;
      }
    }
    class Pattern {
      constructor() {
        (this.notes = []), (this.instruments = [0]);
      }
      cloneNotes() {
        const result = [];
        for (const note of this.notes) result.push(note.clone());
        return result;
      }
      reset() {
        (this.notes.length = 0),
          (this.instruments[0] = 0),
          (this.instruments.length = 1);
      }
      toJsonObject(song, channel, isModChannel) {
        const noteArray = [];
        for (const note of this.notes) {
          let instrument = channel.instruments[this.instruments[0]],
            mod = Math.max(0, Config.modCount - note.pitches[0] - 1),
            volumeCap = song.getVolumeCapForSetting(
              isModChannel,
              instrument.modulators[mod],
              instrument.modFilterTypes[mod]
            );
          const pointArray = [];
          for (const pin of note.pins) {
            let useVol = isModChannel
              ? Math.round(pin.size)
              : Math.round((100 * pin.size) / volumeCap);
            pointArray.push({
              tick:
                ((pin.time + note.start) *
                  Config.rhythms[song.rhythm].stepsPerBeat) /
                Config.partsPerBeat,
              pitchBend: pin.interval,
              volume: useVol,
              forMod: isModChannel,
            });
          }
          const noteObject = { pitches: note.pitches, points: pointArray };
          0 == note.start &&
            (noteObject.continuesLastPattern = note.continuesLastPattern),
            noteArray.push(noteObject);
        }
        const patternObject = { notes: noteArray };
        return (
          song.patternInstruments &&
            (patternObject.instruments = this.instruments.map((i) => i + 1)),
          patternObject
        );
      }
      fromJsonObject(
        patternObject,
        song,
        channel,
        importedPartsPerBeat,
        isNoiseChannel,
        isModChannel
      ) {
        if (song.patternInstruments)
          if (Array.isArray(patternObject.instruments)) {
            const instruments = patternObject.instruments,
              instrumentCount = clamp(
                Config.instrumentCountMin,
                song.getMaxInstrumentsPerPatternForChannel(channel) + 1,
                instruments.length
              );
            for (let j = 0; j < instrumentCount; j++)
              this.instruments[j] = clamp(
                0,
                channel.instruments.length,
                (0 | instruments[j]) - 1
              );
            this.instruments.length = instrumentCount;
          } else
            (this.instruments[0] = clamp(
              0,
              channel.instruments.length,
              (0 | patternObject.instrument) - 1
            )),
              (this.instruments.length = 1);
        if (patternObject.notes && patternObject.notes.length > 0) {
          const maxNoteCount = Math.min(
            song.beatsPerBar *
              Config.partsPerBeat *
              (isModChannel ? Config.modCount : 1),
            patternObject.notes.length >>> 0
          );
          for (
            let j = 0;
            j < patternObject.notes.length && !(j >= maxNoteCount);
            j++
          ) {
            const noteObject = patternObject.notes[j];
            if (
              !(
                noteObject &&
                noteObject.pitches &&
                noteObject.pitches.length >= 1 &&
                noteObject.points &&
                noteObject.points.length >= 2
              )
            )
              continue;
            const note = new Note(0, 0, 0, 0);
            (note.pitches = []), (note.pins = []);
            for (let k = 0; k < noteObject.pitches.length; k++) {
              const pitch = 0 | noteObject.pitches[k];
              if (
                -1 == note.pitches.indexOf(pitch) &&
                (note.pitches.push(pitch),
                note.pitches.length >= Config.maxChordSize)
              )
                break;
            }
            if (note.pitches.length < 1) continue;
            let startInterval = 0;
            for (let k = 0; k < noteObject.points.length; k++) {
              const pointObject = noteObject.points[k];
              if (null == pointObject || null == pointObject.tick) continue;
              const interval =
                  null == pointObject.pitchBend ? 0 : 0 | pointObject.pitchBend,
                time = Math.round(
                  (+pointObject.tick * Config.partsPerBeat) /
                    importedPartsPerBeat
                );
              let instrument = channel.instruments[this.instruments[0]],
                mod = Math.max(0, Config.modCount - note.pitches[0] - 1),
                volumeCap = song.getVolumeCapForSetting(
                  isModChannel,
                  instrument.modulators[mod],
                  instrument.modFilterTypes[mod]
                ),
                size;
              (size =
                null == pointObject.volume
                  ? volumeCap
                  : null == pointObject.forMod
                    ? Math.max(
                        0,
                        Math.min(
                          volumeCap,
                          Math.round(
                            ((0 | pointObject.volume) * volumeCap) / 100
                          )
                        )
                      )
                    : (0 | pointObject.forMod) > 0
                      ? Math.round(0 | pointObject.volume)
                      : Math.max(
                          0,
                          Math.min(
                            volumeCap,
                            Math.round(
                              ((0 | pointObject.volume) * volumeCap) / 100
                            )
                          )
                        )),
                time > song.beatsPerBar * Config.partsPerBeat ||
                  (0 == note.pins.length &&
                    ((note.start = time), (startInterval = interval)),
                  note.pins.push(
                    makeNotePin(
                      interval - startInterval,
                      time - note.start,
                      size
                    )
                  ));
            }
            if (note.pins.length < 2) continue;
            note.end = note.pins[note.pins.length - 1].time + note.start;
            const maxPitch = isNoiseChannel
              ? Config.drumCount - 1
              : Config.maxPitch;
            let lowestPitch = maxPitch,
              highestPitch = 0;
            for (let k = 0; k < note.pitches.length; k++)
              (note.pitches[k] += startInterval),
                (note.pitches[k] < 0 || note.pitches[k] > maxPitch) &&
                  (note.pitches.splice(k, 1), k--),
                note.pitches[k] < lowestPitch &&
                  (lowestPitch = note.pitches[k]),
                note.pitches[k] > highestPitch &&
                  (highestPitch = note.pitches[k]);
            if (!(note.pitches.length < 1)) {
              for (let k = 0; k < note.pins.length; k++) {
                const pin = note.pins[k];
                pin.interval + lowestPitch < 0 && (pin.interval = -lowestPitch),
                  pin.interval + highestPitch > maxPitch &&
                    (pin.interval = maxPitch - highestPitch),
                  k >= 2 &&
                    pin.interval == note.pins[k - 1].interval &&
                    pin.interval == note.pins[k - 2].interval &&
                    pin.size == note.pins[k - 1].size &&
                    pin.size == note.pins[k - 2].size &&
                    (note.pins.splice(k - 1, 1), k--);
              }
              0 == note.start
                ? (note.continuesLastPattern =
                    !0 === noteObject.continuesLastPattern)
                : (note.continuesLastPattern = !1),
                this.notes.push(note);
            }
          }
        }
      }
    }
    class Operator {
      constructor(index) {
        (this.frequency = 4),
          (this.amplitude = 0),
          (this.waveform = 0),
          (this.pulseWidth = 0.5),
          this.reset(index);
      }
      reset(index) {
        (this.frequency = 4),
          (this.amplitude = index <= 1 ? Config.operatorAmplitudeMax : 0),
          (this.waveform = 0),
          (this.pulseWidth = 5);
      }
      copy(other) {
        (this.frequency = other.frequency),
          (this.amplitude = other.amplitude),
          (this.waveform = other.waveform),
          (this.pulseWidth = other.pulseWidth);
      }
    }
    class CustomAlgorithm {
      constructor() {
        (this.name = ""),
          (this.carrierCount = 0),
          (this.modulatedBy = [[], [], [], [], [], []]),
          (this.associatedCarrier = []),
          this.fromPreset(1);
      }
      set(carriers, modulation) {
        this.reset(), (this.carrierCount = carriers);
        for (let i = 0; i < this.modulatedBy.length; i++) {
          (this.modulatedBy[i] = modulation[i]),
            i < carriers && (this.associatedCarrier[i] = i + 1),
            (this.name += i + 1);
          for (let j = 0; j < modulation[i].length; j++)
            (this.name += modulation[i][j]),
              modulation[i][j] > carriers - 1 &&
                (this.associatedCarrier[modulation[i][j] - 1] = i + 1),
              (this.name += ",");
          this.name += i < carriers ? "|" : ".";
        }
      }
      reset() {
        (this.name = ""),
          (this.carrierCount = 1),
          (this.modulatedBy = [[2, 3, 4, 5, 6], [], [], [], [], []]),
          (this.associatedCarrier = [1, 1, 1, 1, 1, 1]);
      }
      copy(other) {
        (this.name = other.name),
          (this.carrierCount = other.carrierCount),
          (this.modulatedBy = other.modulatedBy),
          (this.associatedCarrier = other.associatedCarrier);
      }
      fromPreset(other) {
        this.reset();
        let preset = Config.algorithms6Op[other];
        (this.name = preset.name), (this.carrierCount = preset.carrierCount);
        for (var i = 0; i < preset.modulatedBy.length; i++)
          (this.modulatedBy[i] = Array.from(preset.modulatedBy[i])),
            (this.associatedCarrier[i] = preset.associatedCarrier[i]);
      }
    }
    class CustomFeedBack {
      constructor() {
        (this.name = ""),
          (this.indices = [[], [], [], [], [], []]),
          this.fromPreset(1);
      }
      set(inIndices) {
        this.reset();
        for (let i = 0; i < this.indices.length; i++) {
          this.indices[i] = inIndices[i];
          for (let j = 0; j < inIndices[i].length; j++)
            (this.name += inIndices[i][j]), (this.name += ",");
          this.name += ".";
        }
      }
      reset() {
        this.reset,
          (this.name = ""),
          (this.indices = [[1], [], [], [], [], []]);
      }
      copy(other) {
        (this.name = other.name), (this.indices = other.indices);
      }
      fromPreset(other) {
        this.reset();
        let preset = Config.feedbacks6Op[other];
        for (var i = 0; i < preset.indices.length; i++) {
          this.indices[i] = Array.from(preset.indices[i]);
          for (let j = 0; j < preset.indices[i].length; j++)
            (this.name += preset.indices[i][j]), (this.name += ",");
          this.name += ".";
        }
      }
    }
    class SpectrumWave {
      constructor(isNoiseChannel) {
        (this.spectrum = []), (this.hash = -1), this.reset(isNoiseChannel);
      }
      reset(isNoiseChannel) {
        for (let i = 0; i < Config.spectrumControlPoints; i++)
          if (isNoiseChannel)
            this.spectrum[i] = Math.round(
              Config.spectrumMax * (1 / Math.sqrt(1 + i / 3))
            );
          else {
            const isHarmonic =
              0 == i ||
              7 == i ||
              11 == i ||
              14 == i ||
              16 == i ||
              18 == i ||
              21 == i ||
              23 == i ||
              i >= 25;
            this.spectrum[i] = isHarmonic
              ? Math.max(0, Math.round(Config.spectrumMax * (1 - i / 30)))
              : 0;
          }
        this.markCustomWaveDirty();
      }
      markCustomWaveDirty() {
        const hashMult = Synth.fittingPowerOfTwo(Config.spectrumMax + 2) - 1;
        let hash = 0;
        for (const point of this.spectrum)
          hash = (hash * hashMult + point) >>> 0;
        this.hash = hash;
      }
    }
    class SpectrumWaveState {
      constructor() {
        (this.wave = null), (this._hash = -1);
      }
      getCustomWave(settings, lowestOctave) {
        if (this._hash == settings.hash) return this.wave;
        this._hash = settings.hash;
        const waveLength = Config.spectrumNoiseLength;
        (null != this.wave && this.wave.length == waveLength + 1) ||
          (this.wave = new Float32Array(waveLength + 1));
        const wave = this.wave;
        for (let i = 0; i < waveLength; i++) wave[i] = 0;
        const highestOctave = 14,
          falloffRatio = 0.25,
          pitchTweak = [
            0,
            1 / 7,
            Math.log2(5 / 4),
            3 / 7,
            Math.log2(1.5),
            5 / 7,
            6 / 7,
          ];
        function controlPointToOctave(point) {
          return (
            lowestOctave +
            Math.floor(point / Config.spectrumControlPointsPerOctave) +
            pitchTweak[
              (point + Config.spectrumControlPointsPerOctave) %
                Config.spectrumControlPointsPerOctave
            ]
          );
        }
        let combinedAmplitude = 1;
        for (let i = 0; i < Config.spectrumControlPoints + 1; i++) {
          const value1 = i <= 0 ? 0 : settings.spectrum[i - 1],
            value2 =
              i >= Config.spectrumControlPoints
                ? settings.spectrum[Config.spectrumControlPoints - 1]
                : settings.spectrum[i],
            octave1 = controlPointToOctave(i - 1);
          let octave2 = controlPointToOctave(i);
          i >= Config.spectrumControlPoints &&
            (octave2 = 14 + 0.25 * (octave2 - 14)),
            (0 == value1 && 0 == value2) ||
              (combinedAmplitude +=
                0.02 *
                drawNoiseSpectrum(
                  wave,
                  waveLength,
                  octave1,
                  octave2,
                  value1 / Config.spectrumMax,
                  value2 / Config.spectrumMax,
                  -0.5
                ));
        }
        return (
          settings.spectrum[Config.spectrumControlPoints - 1] > 0 &&
            (combinedAmplitude +=
              0.02 *
              drawNoiseSpectrum(
                wave,
                waveLength,
                14 +
                  0.25 *
                    (controlPointToOctave(Config.spectrumControlPoints) - 14),
                14,
                settings.spectrum[Config.spectrumControlPoints - 1] /
                  Config.spectrumMax,
                0,
                -0.5
              )),
          inverseRealFourierTransform(wave, waveLength),
          scaleElementsByFactor(
            wave,
            5 / (Math.sqrt(waveLength) * Math.pow(combinedAmplitude, 0.75))
          ),
          (wave[waveLength] = wave[0]),
          wave
        );
      }
    }
    class HarmonicsWave {
      constructor() {
        (this.harmonics = []), (this.hash = -1), this.reset();
      }
      reset() {
        for (let i = 0; i < Config.harmonicsControlPoints; i++)
          this.harmonics[i] = 0;
        (this.harmonics[0] = Config.harmonicsMax),
          (this.harmonics[3] = Config.harmonicsMax),
          (this.harmonics[6] = Config.harmonicsMax),
          this.markCustomWaveDirty();
      }
      markCustomWaveDirty() {
        const hashMult = Synth.fittingPowerOfTwo(Config.harmonicsMax + 2) - 1;
        let hash = 0;
        for (const point of this.harmonics)
          hash = (hash * hashMult + point) >>> 0;
        this.hash = hash;
      }
    }
    class HarmonicsWaveState {
      constructor() {
        (this.wave = null), (this._hash = -1);
      }
      getCustomWave(settings, instrumentType) {
        if (
          this._hash == settings.hash &&
          this._generatedForType == instrumentType
        )
          return this.wave;
        (this._hash = settings.hash), (this._generatedForType = instrumentType);
        const harmonicsRendered =
            7 == instrumentType
              ? Config.harmonicsRenderedForPickedString
              : Config.harmonicsRendered,
          waveLength = Config.harmonicsWavelength,
          retroWave = getDrumWave(0, null, null);
        (null != this.wave && this.wave.length == waveLength + 1) ||
          (this.wave = new Float32Array(waveLength + 1));
        const wave = this.wave;
        for (let i = 0; i < waveLength; i++) wave[i] = 0;
        const overallSlope = -0.25;
        let combinedControlPointAmplitude = 1;
        for (
          let harmonicIndex = 0;
          harmonicIndex < harmonicsRendered;
          harmonicIndex++
        ) {
          const harmonicFreq = harmonicIndex + 1;
          let controlValue =
            harmonicIndex < Config.harmonicsControlPoints
              ? settings.harmonics[harmonicIndex]
              : settings.harmonics[Config.harmonicsControlPoints - 1];
          harmonicIndex >= Config.harmonicsControlPoints &&
            (controlValue *=
              1 -
              (harmonicIndex - Config.harmonicsControlPoints) /
                (harmonicsRendered - Config.harmonicsControlPoints));
          const normalizedValue = controlValue / Config.harmonicsMax;
          let amplitude =
            Math.pow(2, controlValue - Config.harmonicsMax + 1) *
            Math.sqrt(normalizedValue);
          harmonicIndex < Config.harmonicsControlPoints &&
            (combinedControlPointAmplitude += amplitude),
            (amplitude *= Math.pow(harmonicFreq, -0.25)),
            (amplitude *= retroWave[harmonicIndex + 589]),
            (wave[waveLength - harmonicFreq] = amplitude);
        }
        inverseRealFourierTransform(wave, waveLength);
        const mult = 1 / Math.pow(combinedControlPointAmplitude, 0.7);
        for (let i = 0; i < wave.length; i++) wave[i] *= mult;
        return performIntegralOld(wave), (wave[waveLength] = wave[0]), wave;
      }
    }
    class FilterControlPoint {
      constructor() {
        (this.freq = 0), (this.gain = Config.filterGainCenter), (this.type = 2);
      }
      set(freqSetting, gainSetting) {
        (this.freq = freqSetting), (this.gain = gainSetting);
      }
      getHz() {
        return FilterControlPoint.getHzFromSettingValue(this.freq);
      }
      static getHzFromSettingValue(value) {
        return (
          Config.filterFreqReferenceHz *
          Math.pow(
            2,
            (value - Config.filterFreqReferenceSetting) * Config.filterFreqStep
          )
        );
      }
      static getSettingValueFromHz(hz) {
        return (
          Math.log2(hz / Config.filterFreqReferenceHz) / Config.filterFreqStep +
          Config.filterFreqReferenceSetting
        );
      }
      static getRoundedSettingValueFromHz(hz) {
        return Math.max(
          0,
          Math.min(
            Config.filterFreqRange - 1,
            Math.round(FilterControlPoint.getSettingValueFromHz(hz))
          )
        );
      }
      getLinearGain(peakMult = 1) {
        const power =
            (this.gain - Config.filterGainCenter) * Config.filterGainStep,
          neutral = 2 == this.type ? 0 : -0.5,
          interpolatedPower = neutral + (power - neutral) * peakMult;
        return Math.pow(2, interpolatedPower);
      }
      static getRoundedSettingValueFromLinearGain(linearGain) {
        return Math.max(
          0,
          Math.min(
            Config.filterGainRange - 1,
            Math.round(
              Math.log2(linearGain) / Config.filterGainStep +
                Config.filterGainCenter
            )
          )
        );
      }
      toCoefficients(filter, sampleRate, freqMult = 1, peakMult = 1) {
        const cornerRadiansPerSample =
            (2 *
              Math.PI *
              Math.max(
                Config.filterFreqMinHz,
                Math.min(Config.filterFreqMaxHz, freqMult * this.getHz())
              )) /
            sampleRate,
          linearGain = this.getLinearGain(peakMult);
        switch (this.type) {
          case 0:
            filter.lowPass2ndOrderButterworth(
              cornerRadiansPerSample,
              linearGain
            );
            break;
          case 1:
            filter.highPass2ndOrderButterworth(
              cornerRadiansPerSample,
              linearGain
            );
            break;
          case 2:
            filter.peak2ndOrder(cornerRadiansPerSample, linearGain, 1);
            break;
          default:
            throw new Error();
        }
      }
      getVolumeCompensationMult() {
        const octave =
            (this.freq - Config.filterFreqReferenceSetting) *
            Config.filterFreqStep,
          gainPow =
            (this.gain - Config.filterGainCenter) * Config.filterGainStep;
        switch (this.type) {
          case 0:
            const freqRelativeTo8khz =
                (Math.pow(2, octave) * Config.filterFreqReferenceHz) / 8e3,
              warpedFreq = (Math.sqrt(1 + 4 * freqRelativeTo8khz) - 1) / 2,
              warpedOctave = Math.log2(warpedFreq);
            return Math.pow(
              0.5,
              0.2 * Math.max(0, gainPow + 1) +
                Math.min(
                  0,
                  Math.max(
                    -3,
                    0.595 * warpedOctave + 0.35 * Math.min(0, gainPow + 1)
                  )
                )
            );
          case 1:
            return Math.pow(
              0.5,
              0.125 * Math.max(0, gainPow + 1) +
                Math.min(
                  0,
                  0.3 *
                    (-octave - Math.log2(Config.filterFreqReferenceHz / 125)) +
                    0.2 * Math.min(0, gainPow + 1)
                )
            );
          case 2:
            const distanceFromCenter =
                octave + Math.log2(Config.filterFreqReferenceHz / 2e3),
              freqLoudness = Math.pow(
                1 / (1 + Math.pow(distanceFromCenter / 3, 2)),
                2
              );
            return Math.pow(
              0.5,
              0.125 * Math.max(0, gainPow) +
                0.1 * freqLoudness * Math.min(0, gainPow)
            );
          default:
            throw new Error();
        }
      }
    }
    class FilterSettings {
      constructor() {
        (this.controlPoints = []), (this.controlPointCount = 0), this.reset();
      }
      reset() {
        this.controlPointCount = 0;
      }
      addPoint(type, freqSetting, gainSetting) {
        let controlPoint;
        this.controlPoints.length <= this.controlPointCount
          ? ((controlPoint = new FilterControlPoint()),
            (this.controlPoints[this.controlPointCount] = controlPoint))
          : (controlPoint = this.controlPoints[this.controlPointCount]),
          this.controlPointCount++,
          (controlPoint.type = type),
          controlPoint.set(freqSetting, gainSetting);
      }
      toJsonObject() {
        const filterArray = [];
        for (let i = 0; i < this.controlPointCount; i++) {
          const point = this.controlPoints[i];
          filterArray.push({
            type: Config.filterTypeNames[point.type],
            cutoffHz: Math.round(100 * point.getHz()) / 100,
            linearGain: Math.round(1e4 * point.getLinearGain()) / 1e4,
          });
        }
        return filterArray;
      }
      fromJsonObject(filterObject) {
        if (((this.controlPoints.length = 0), filterObject))
          for (const pointObject of filterObject) {
            const point = new FilterControlPoint();
            (point.type = Config.filterTypeNames.indexOf(pointObject.type)),
              -1 == point.type && (point.type = 2),
              null != pointObject.cutoffHz
                ? (point.freq = FilterControlPoint.getRoundedSettingValueFromHz(
                    pointObject.cutoffHz
                  ))
                : (point.freq = 0),
              null != pointObject.linearGain
                ? (point.gain =
                    FilterControlPoint.getRoundedSettingValueFromLinearGain(
                      pointObject.linearGain
                    ))
                : (point.gain = Config.filterGainCenter),
              this.controlPoints.push(point);
          }
        this.controlPointCount = this.controlPoints.length;
      }
      static filtersCanMorph(filterA, filterB) {
        if (filterA.controlPointCount != filterB.controlPointCount) return !1;
        for (let i = 0; i < filterA.controlPointCount; i++)
          if (filterA.controlPoints[i].type != filterB.controlPoints[i].type)
            return !1;
        return !0;
      }
      static lerpFilters(filterA, filterB, pos) {
        let lerpedFilter = new FilterSettings();
        if (null == filterA) return filterA;
        if (null == filterB) return filterB;
        if (
          ((pos = Math.max(0, Math.min(1, pos))),
          this.filtersCanMorph(filterA, filterB))
        ) {
          for (let i = 0; i < filterA.controlPointCount; i++)
            (lerpedFilter.controlPoints[i] = new FilterControlPoint()),
              (lerpedFilter.controlPoints[i].type =
                filterA.controlPoints[i].type),
              (lerpedFilter.controlPoints[i].freq =
                filterA.controlPoints[i].freq +
                (filterB.controlPoints[i].freq -
                  filterA.controlPoints[i].freq) *
                  pos),
              (lerpedFilter.controlPoints[i].gain =
                filterA.controlPoints[i].gain +
                (filterB.controlPoints[i].gain -
                  filterA.controlPoints[i].gain) *
                  pos);
          return (
            (lerpedFilter.controlPointCount = filterA.controlPointCount),
            lerpedFilter
          );
        }
        return pos >= 1 ? filterB : filterA;
      }
      convertLegacySettings(
        legacyCutoffSetting,
        legacyResonanceSetting,
        legacyEnv
      ) {
        this.reset();
        const legacyFilterCutoffMaxHz = 8e3,
          legacyFilterMax = 0.95,
          legacyFilterMaxRadians = 2 * Math.asin(0.475),
          legacyFilterMaxResonance = 0.95,
          legacyFilterCutoffRange = 11,
          legacyFilterResonanceRange = 8,
          resonant = legacyResonanceSetting > 1,
          firstOrder = 0 == legacyResonanceSetting,
          cutoffAtMax = 10 == legacyCutoffSetting,
          envDecays =
            3 == legacyEnv.type ||
            4 == legacyEnv.type ||
            8 == legacyEnv.type ||
            0 == legacyEnv.type,
          standardSampleRate = 48e3,
          legacyHz = 8e3 * Math.pow(2, 0.5 * (legacyCutoffSetting - 10)),
          legacyRadians = Math.min(
            legacyFilterMaxRadians,
            (2 * Math.PI * legacyHz) / 48e3
          );
        if (1 == legacyEnv.type && !resonant && cutoffAtMax);
        else if (firstOrder) {
          const extraOctaves = 3.5,
            targetRadians = legacyRadians * Math.pow(2, extraOctaves),
            curvedRadians = targetRadians / (1 + targetRadians / Math.PI),
            curvedHz = (48e3 * curvedRadians) / (2 * Math.PI),
            freqSetting =
              FilterControlPoint.getRoundedSettingValueFromHz(curvedHz),
            finalHz = FilterControlPoint.getHzFromSettingValue(freqSetting),
            finalRadians = (2 * Math.PI * finalHz) / 48e3,
            legacyFilter = new FilterCoefficients();
          legacyFilter.lowPass1stOrderSimplified(legacyRadians);
          const response = new FrequencyResponse();
          response.analyze(legacyFilter, finalRadians);
          const legacyFilterGainAtNewRadians = response.magnitude();
          let logGain = Math.log2(legacyFilterGainAtNewRadians);
          (logGain = 0.82 * (logGain + extraOctaves) - extraOctaves),
            envDecays && (logGain = Math.min(logGain, -1));
          const convertedGain = Math.pow(2, logGain),
            gainSetting =
              FilterControlPoint.getRoundedSettingValueFromLinearGain(
                convertedGain
              );
          this.addPoint(0, freqSetting, gainSetting);
        } else {
          const intendedGain =
              0.5 /
              (1 -
                0.95 * Math.sqrt(Math.max(0, legacyResonanceSetting - 1) / 6)),
            invertedGain = 0.5 / intendedGain,
            maxRadians = (2 * Math.PI * 8e3) / 48e3,
            freqRatio = legacyRadians / maxRadians,
            targetRadians =
              legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1),
            curvedRadians =
              legacyRadians + (targetRadians - legacyRadians) * invertedGain;
          let curvedHz;
          curvedHz = envDecays
            ? (48e3 *
                Math.min(curvedRadians, legacyRadians * Math.pow(2, 0.25))) /
              (2 * Math.PI)
            : (48e3 * curvedRadians) / (2 * Math.PI);
          const freqSetting =
            FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);
          let legacyFilterGain;
          if (envDecays) legacyFilterGain = intendedGain;
          else {
            const legacyFilter = new FilterCoefficients();
            legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);
            const response = new FrequencyResponse();
            response.analyze(legacyFilter, curvedRadians),
              (legacyFilterGain = response.magnitude());
          }
          resonant ||
            (legacyFilterGain = Math.min(legacyFilterGain, Math.sqrt(0.5)));
          const gainSetting =
            FilterControlPoint.getRoundedSettingValueFromLinearGain(
              legacyFilterGain
            );
          this.addPoint(0, freqSetting, gainSetting);
        }
        this.controlPoints.length = this.controlPointCount;
      }
      convertLegacySettingsForSynth(
        legacyCutoffSetting,
        legacyResonanceSetting,
        allowFirstOrder = !1
      ) {
        this.reset();
        const legacyFilterCutoffMaxHz = 8e3,
          legacyFilterMax = 0.95,
          legacyFilterMaxRadians = 2 * Math.asin(0.475),
          legacyFilterMaxResonance = 0.95,
          legacyFilterCutoffRange = 11,
          legacyFilterResonanceRange = 8,
          firstOrder = 0 == legacyResonanceSetting && allowFirstOrder,
          standardSampleRate = 48e3,
          legacyHz = 8e3 * Math.pow(2, 0.5 * (legacyCutoffSetting - 10)),
          legacyRadians = Math.min(
            legacyFilterMaxRadians,
            (2 * Math.PI * legacyHz) / 48e3
          );
        if (firstOrder) {
          const extraOctaves = 3.5,
            targetRadians = legacyRadians * Math.pow(2, extraOctaves),
            curvedRadians = targetRadians / (1 + targetRadians / Math.PI),
            curvedHz = (48e3 * curvedRadians) / (2 * Math.PI),
            freqSetting =
              FilterControlPoint.getRoundedSettingValueFromHz(curvedHz),
            finalHz = FilterControlPoint.getHzFromSettingValue(freqSetting),
            finalRadians = (2 * Math.PI * finalHz) / 48e3,
            legacyFilter = new FilterCoefficients();
          legacyFilter.lowPass1stOrderSimplified(legacyRadians);
          const response = new FrequencyResponse();
          response.analyze(legacyFilter, finalRadians);
          const legacyFilterGainAtNewRadians = response.magnitude();
          let logGain = Math.log2(legacyFilterGainAtNewRadians);
          logGain = 0.82 * (logGain + extraOctaves) - extraOctaves;
          const convertedGain = Math.pow(2, logGain),
            gainSetting =
              FilterControlPoint.getRoundedSettingValueFromLinearGain(
                convertedGain
              );
          this.addPoint(0, freqSetting, gainSetting);
        } else {
          const intendedGain =
              0.5 /
              (1 -
                0.95 * Math.sqrt(Math.max(0, legacyResonanceSetting - 1) / 6)),
            invertedGain = 0.5 / intendedGain,
            maxRadians = (2 * Math.PI * 8e3) / 48e3,
            freqRatio = legacyRadians / maxRadians,
            targetRadians =
              legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1),
            curvedRadians =
              legacyRadians + (targetRadians - legacyRadians) * invertedGain;
          let curvedHz;
          curvedHz = (48e3 * curvedRadians) / (2 * Math.PI);
          const freqSetting =
            FilterControlPoint.getSettingValueFromHz(curvedHz);
          let legacyFilterGain;
          const legacyFilter = new FilterCoefficients();
          legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);
          const response = new FrequencyResponse();
          response.analyze(legacyFilter, curvedRadians),
            (legacyFilterGain = response.magnitude());
          const gainSetting =
            FilterControlPoint.getRoundedSettingValueFromLinearGain(
              legacyFilterGain
            );
          this.addPoint(0, freqSetting, gainSetting);
        }
      }
    }
    class EnvelopeSettings {
      constructor() {
        (this.target = 0), (this.index = 0), (this.envelope = 0), this.reset();
      }
      reset() {
        (this.target = 0), (this.index = 0), (this.envelope = 0);
      }
      toJsonObject() {
        const envelopeObject = {
          target: Config.instrumentAutomationTargets[this.target].name,
          envelope: Config.envelopes[this.envelope].name,
        };
        return (
          Config.instrumentAutomationTargets[this.target].maxCount > 1 &&
            (envelopeObject.index = this.index),
          envelopeObject
        );
      }
      fromJsonObject(envelopeObject) {
        this.reset();
        let target =
          Config.instrumentAutomationTargets.dictionary[envelopeObject.target];
        null == target &&
          (target = Config.instrumentAutomationTargets.dictionary.noteVolume),
          (this.target = target.index);
        let envelope = Config.envelopes.dictionary[envelopeObject.envelope];
        null == envelope && (envelope = Config.envelopes.dictionary.none),
          (this.envelope = envelope.index),
          null != envelopeObject.index
            ? (this.index = clamp(
                0,
                Config.instrumentAutomationTargets[this.target].maxCount,
                0 | envelopeObject.index
              ))
            : (this.index = 0);
      }
    }
    class Instrument {
      constructor(isNoiseChannel, isModChannel) {
        if (
          ((this.type = 0),
          (this.preset = 0),
          (this.chipWave = 2),
          (this.isUsingAdvancedLoopControls = !1),
          (this.chipWaveLoopStart = 0),
          (this.chipWaveLoopEnd =
            Config.rawRawChipWaves[this.chipWave].samples.length - 1),
          (this.chipWaveLoopMode = 0),
          (this.chipWavePlayBackwards = !1),
          (this.chipWaveStartOffset = 0),
          (this.chipNoise = 1),
          (this.eqFilter = new FilterSettings()),
          (this.eqFilterType = !1),
          (this.eqFilterSimpleCut = Config.filterSimpleCutRange - 1),
          (this.eqFilterSimplePeak = 0),
          (this.noteFilter = new FilterSettings()),
          (this.noteFilterType = !1),
          (this.noteFilterSimpleCut = Config.filterSimpleCutRange - 1),
          (this.noteFilterSimplePeak = 0),
          (this.eqSubFilters = []),
          (this.noteSubFilters = []),
          (this.envelopes = []),
          (this.fadeIn = 0),
          (this.fadeOut = Config.fadeOutNeutral),
          (this.envelopeCount = 0),
          (this.transition = Config.transitions.dictionary.normal.index),
          (this.pitchShift = 0),
          (this.detune = 0),
          (this.vibrato = 0),
          (this.interval = 0),
          (this.vibratoDepth = 0),
          (this.vibratoSpeed = 10),
          (this.vibratoDelay = 0),
          (this.vibratoType = 0),
          (this.envelopeSpeed = 12),
          (this.discreteEnvelope = !1),
          (this.unison = 0),
          (this.unisonVoices = 1),
          (this.unisonSpread = 0),
          (this.unisonOffset = 0),
          (this.unisonExpression = 1.4),
          (this.unisonSign = 1),
          (this.effects = 0),
          (this.chord = 1),
          (this.volume = 0),
          (this.pan = Config.panCenter),
          (this.panDelay = 10),
          (this.arpeggioSpeed = 12),
          (this.fastTwoNoteArp = !1),
          (this.legacyTieOver = !1),
          (this.clicklessTransition = !1),
          (this.aliases = !1),
          (this.pulseWidth = Config.pulseWidthRange),
          (this.decimalOffset = 0),
          (this.supersawDynamism = Config.supersawDynamismMax),
          (this.supersawSpread = Math.ceil(Config.supersawSpreadMax / 2)),
          (this.supersawShape = 0),
          (this.stringSustain = 10),
          (this.stringSustainType = 1),
          (this.distortion = 0),
          (this.bitcrusherFreq = 0),
          (this.bitcrusherQuantization = 0),
          (this.chorus = 0),
          (this.reverb = 0),
          (this.echoSustain = 0),
          (this.echoDelay = 0),
          (this.algorithm = 0),
          (this.feedbackType = 0),
          (this.algorithm6Op = 1),
          (this.feedbackType6Op = 1),
          (this.customAlgorithm = new CustomAlgorithm()),
          (this.customFeedbackType = new CustomFeedBack()),
          (this.feedbackAmplitude = 0),
          (this.customChipWave = new Float32Array(64)),
          (this.customChipWaveIntegral = new Float32Array(65)),
          (this.operators = []),
          (this.harmonicsWave = new HarmonicsWave()),
          (this.drumsetEnvelopes = []),
          (this.drumsetSpectrumWaves = []),
          (this.modChannels = []),
          (this.modInstruments = []),
          (this.modulators = []),
          (this.modFilterTypes = []),
          (this.invalidModulators = []),
          isModChannel)
        )
          for (let mod = 0; mod < Config.modCount; mod++)
            this.modChannels.push(-2),
              this.modInstruments.push(0),
              this.modulators.push(Config.modulators.dictionary.none.index);
        this.spectrumWave = new SpectrumWave(isNoiseChannel);
        for (let i = 0; i < Config.operatorCount + 2; i++)
          this.operators[i] = new Operator(i);
        for (let i = 0; i < Config.drumCount; i++)
          (this.drumsetEnvelopes[i] =
            Config.envelopes.dictionary["twang 2"].index),
            (this.drumsetSpectrumWaves[i] = new SpectrumWave(!0));
        for (let i = 0; i < 64; i++)
          this.customChipWave[i] = 24 - Math.floor(0.75 * i);
        let sum = 0;
        for (let i = 0; i < this.customChipWave.length; i++)
          sum += this.customChipWave[i];
        const average = sum / this.customChipWave.length;
        let cumulative = 0,
          wavePrev = 0;
        for (let i = 0; i < this.customChipWave.length; i++)
          (cumulative += wavePrev),
            (wavePrev = this.customChipWave[i] - average),
            (this.customChipWaveIntegral[i] = cumulative);
        this.customChipWaveIntegral[64] = 0;
      }
      setTypeAndReset(type, isNoiseChannel, isModChannel) {
        isModChannel && (type = 10),
          (this.type = type),
          (this.preset = type),
          (this.volume = 0),
          (this.effects = 4),
          (this.chorus = Config.chorusRange - 1),
          (this.reverb = 0),
          (this.echoSustain = Math.floor(0.5 * (Config.echoSustainRange - 1))),
          (this.echoDelay = Math.floor(0.5 * (Config.echoDelayRange - 1))),
          this.eqFilter.reset(),
          (this.eqFilterType = !1),
          (this.eqFilterSimpleCut = Config.filterSimpleCutRange - 1),
          (this.eqFilterSimplePeak = 0);
        for (let i = 0; i < Config.filterMorphCount; i++)
          (this.eqSubFilters[i] = null), (this.noteSubFilters[i] = null);
        switch (
          (this.noteFilter.reset(),
          (this.noteFilterType = !1),
          (this.noteFilterSimpleCut = Config.filterSimpleCutRange - 1),
          (this.noteFilterSimplePeak = 0),
          (this.distortion = Math.floor(0.75 * (Config.distortionRange - 1))),
          (this.bitcrusherFreq = Math.floor(
            0.5 * (Config.bitcrusherFreqRange - 1)
          )),
          (this.bitcrusherQuantization = Math.floor(
            0.5 * (Config.bitcrusherQuantizationRange - 1)
          )),
          (this.pan = Config.panCenter),
          (this.panDelay = 10),
          (this.pitchShift = Config.pitchShiftCenter),
          (this.detune = Config.detuneCenter),
          (this.vibrato = 0),
          (this.unison = 0),
          (this.stringSustain = 10),
          (this.stringSustainType = Config.enableAcousticSustain ? 1 : 0),
          (this.clicklessTransition = !1),
          (this.arpeggioSpeed = 12),
          (this.envelopeSpeed = 12),
          (this.discreteEnvelope = !1),
          (this.legacyTieOver = !1),
          (this.aliases = !1),
          (this.fadeIn = 0),
          (this.fadeOut = Config.fadeOutNeutral),
          (this.transition = Config.transitions.dictionary.normal.index),
          (this.envelopeCount = 0),
          type)
        ) {
          case 0:
            (this.chipWave = 2),
              (this.chord = Config.chords.dictionary.arpeggio.index),
              (this.isUsingAdvancedLoopControls = !1),
              (this.chipWaveLoopStart = 0),
              (this.chipWaveLoopEnd =
                Config.rawRawChipWaves[this.chipWave].samples.length - 1),
              (this.chipWaveLoopMode = 0),
              (this.chipWavePlayBackwards = !1),
              (this.chipWaveStartOffset = 0);
            break;
          case 9:
            (this.chipWave = 2),
              (this.chord = Config.chords.dictionary.arpeggio.index);
            for (let i = 0; i < 64; i++)
              this.customChipWave[i] = 24 - Math.floor(0.75 * i);
            let sum = 0;
            for (let i = 0; i < this.customChipWave.length; i++)
              sum += this.customChipWave[i];
            const average = sum / this.customChipWave.length;
            let cumulative = 0,
              wavePrev = 0;
            for (let i = 0; i < this.customChipWave.length; i++)
              (cumulative += wavePrev),
                (wavePrev = this.customChipWave[i] - average),
                (this.customChipWaveIntegral[i] = cumulative);
            this.customChipWaveIntegral[64] = 0;
            break;
          case 1:
            (this.chord = Config.chords.dictionary["custom interval"].index),
              (this.algorithm = 0),
              (this.feedbackType = 0),
              (this.feedbackAmplitude = 0);
            for (let i = 0; i < this.operators.length; i++)
              this.operators[i].reset(i);
            break;
          case 11:
            (this.transition = 1),
              (this.vibrato = 0),
              (this.effects = 1),
              (this.chord = 3),
              (this.algorithm = 0),
              (this.feedbackType = 0),
              (this.algorithm6Op = 1),
              (this.feedbackType6Op = 1),
              this.customAlgorithm.fromPreset(1),
              (this.feedbackAmplitude = 0);
            for (let i = 0; i < this.operators.length; i++)
              this.operators[i].reset(i);
            break;
          case 2:
            (this.chipNoise = 1),
              (this.chord = Config.chords.dictionary.arpeggio.index);
            break;
          case 3:
            (this.chord = Config.chords.dictionary.simultaneous.index),
              this.spectrumWave.reset(isNoiseChannel);
            break;
          case 4:
            this.chord = Config.chords.dictionary.simultaneous.index;
            for (let i = 0; i < Config.drumCount; i++)
              (this.drumsetEnvelopes[i] =
                Config.envelopes.dictionary["twang 2"].index),
                null == this.drumsetSpectrumWaves[i] &&
                  (this.drumsetSpectrumWaves[i] = new SpectrumWave(!0)),
                this.drumsetSpectrumWaves[i].reset(isNoiseChannel);
            break;
          case 5:
            (this.chord = Config.chords.dictionary.simultaneous.index),
              this.harmonicsWave.reset();
            break;
          case 6:
            (this.chord = Config.chords.dictionary.arpeggio.index),
              (this.pulseWidth = Config.pulseWidthRange),
              (this.decimalOffset = 0);
            break;
          case 7:
            (this.chord = Config.chords.dictionary.strum.index),
              this.harmonicsWave.reset();
            break;
          case 10:
            (this.transition = 0),
              (this.vibrato = 0),
              (this.interval = 0),
              (this.effects = 0),
              (this.chord = 0),
              (this.modChannels = []),
              (this.modInstruments = []),
              (this.modulators = []);
            for (let mod = 0; mod < Config.modCount; mod++)
              this.modChannels.push(-2),
                this.modInstruments.push(0),
                this.modulators.push(Config.modulators.dictionary.none.index),
                (this.invalidModulators[mod] = !1),
                (this.modFilterTypes[mod] = 0);
            break;
          case 8:
            (this.chord = Config.chords.dictionary.arpeggio.index),
              (this.supersawDynamism = Config.supersawDynamismMax),
              (this.supersawSpread = Math.ceil(Config.supersawSpreadMax / 2)),
              (this.supersawShape = 0),
              (this.pulseWidth = Config.pulseWidthRange - 1),
              (this.decimalOffset = 0);
            break;
          default:
            throw new Error("Unrecognized instrument type: " + type);
        }
        this.chord != Config.chords.dictionary.simultaneous.index &&
          (this.effects = 2048 | this.effects);
      }
      convertLegacySettings(legacySettings, forceSimpleFilter) {
        let legacyCutoffSetting = legacySettings.filterCutoff,
          legacyResonanceSetting = legacySettings.filterResonance,
          legacyFilterEnv = legacySettings.filterEnvelope,
          legacyPulseEnv = legacySettings.pulseEnvelope,
          legacyOperatorEnvelopes = legacySettings.operatorEnvelopes,
          legacyFeedbackEnv = legacySettings.feedbackEnvelope;
        null == legacyCutoffSetting &&
          (legacyCutoffSetting = 0 == this.type ? 6 : 10),
          null == legacyResonanceSetting && (legacyResonanceSetting = 0),
          null == legacyFilterEnv &&
            (legacyFilterEnv = Config.envelopes.dictionary.none),
          null == legacyPulseEnv &&
            (legacyPulseEnv =
              Config.envelopes.dictionary[6 == this.type ? "twang 2" : "none"]),
          null == legacyOperatorEnvelopes &&
            (legacyOperatorEnvelopes = [
              Config.envelopes.dictionary[
                1 == this.type ? "note size" : "none"
              ],
              Config.envelopes.dictionary.none,
              Config.envelopes.dictionary.none,
              Config.envelopes.dictionary.none,
            ]),
          null == legacyFeedbackEnv &&
            (legacyFeedbackEnv = Config.envelopes.dictionary.none);
        const legacyFilterCutoffRange = 11,
          cutoffAtMax = 10 == legacyCutoffSetting;
        cutoffAtMax &&
          2 == legacyFilterEnv.type &&
          (legacyFilterEnv = Config.envelopes.dictionary.none);
        const carrierCount = Config.algorithms[this.algorithm].carrierCount;
        let noCarriersControlledByNoteSize = !0,
          allCarriersControlledByNoteSize = !0,
          noteSizeControlsSomethingElse =
            0 == legacyFilterEnv.type || 0 == legacyPulseEnv.type;
        if (1 == this.type || 11 == this.type) {
          noteSizeControlsSomethingElse =
            noteSizeControlsSomethingElse || 0 == legacyFeedbackEnv.type;
          for (let i = 0; i < legacyOperatorEnvelopes.length; i++)
            i < carrierCount
              ? 0 != legacyOperatorEnvelopes[i].type
                ? (allCarriersControlledByNoteSize = !1)
                : (noCarriersControlledByNoteSize = !1)
              : (noteSizeControlsSomethingElse =
                  noteSizeControlsSomethingElse ||
                  0 == legacyOperatorEnvelopes[i].type);
        }
        (this.envelopeCount = 0),
          (1 != this.type && 11 != this.type) ||
            (allCarriersControlledByNoteSize && noteSizeControlsSomethingElse
              ? this.addEnvelope(
                  Config.instrumentAutomationTargets.dictionary.noteVolume
                    .index,
                  0,
                  Config.envelopes.dictionary["note size"].index
                )
              : noCarriersControlledByNoteSize &&
                !noteSizeControlsSomethingElse &&
                this.addEnvelope(
                  Config.instrumentAutomationTargets.dictionary.none.index,
                  0,
                  Config.envelopes.dictionary["note size"].index
                )),
          1 == legacyFilterEnv.type
            ? (this.noteFilter.reset(),
              (this.noteFilterType = !1),
              this.eqFilter.convertLegacySettings(
                legacyCutoffSetting,
                legacyResonanceSetting,
                legacyFilterEnv
              ),
              (this.effects &= -33),
              (forceSimpleFilter || this.eqFilterType) &&
                ((this.eqFilterType = !0),
                (this.eqFilterSimpleCut = legacyCutoffSetting),
                (this.eqFilterSimplePeak = legacyResonanceSetting)))
            : (this.eqFilter.reset(),
              (this.eqFilterType = !1),
              (this.noteFilterType = !1),
              this.noteFilter.convertLegacySettings(
                legacyCutoffSetting,
                legacyResonanceSetting,
                legacyFilterEnv
              ),
              (this.effects |= 32),
              this.addEnvelope(
                Config.instrumentAutomationTargets.dictionary.noteFilterAllFreqs
                  .index,
                0,
                legacyFilterEnv.index
              ),
              (forceSimpleFilter || this.noteFilterType) &&
                ((this.noteFilterType = !0),
                (this.noteFilterSimpleCut = legacyCutoffSetting),
                (this.noteFilterSimplePeak = legacyResonanceSetting))),
          1 != legacyPulseEnv.type &&
            this.addEnvelope(
              Config.instrumentAutomationTargets.dictionary.pulseWidth.index,
              0,
              legacyPulseEnv.index
            );
        for (let i = 0; i < legacyOperatorEnvelopes.length; i++)
          (i < carrierCount && allCarriersControlledByNoteSize) ||
            (1 != legacyOperatorEnvelopes[i].type &&
              this.addEnvelope(
                Config.instrumentAutomationTargets.dictionary.operatorAmplitude
                  .index,
                i,
                legacyOperatorEnvelopes[i].index
              ));
        1 != legacyFeedbackEnv.type &&
          this.addEnvelope(
            Config.instrumentAutomationTargets.dictionary.feedbackAmplitude
              .index,
            0,
            legacyFeedbackEnv.index
          );
      }
      toJsonObject() {
        const instrumentObject = {
          type: Config.instrumentTypeNames[this.type],
          volume: this.volume,
          eqFilter: this.eqFilter.toJsonObject(),
          eqFilterType: this.eqFilterType,
          eqSimpleCut: this.eqFilterSimpleCut,
          eqSimplePeak: this.eqFilterSimplePeak,
          envelopeSpeed: this.envelopeSpeed,
          discreteEnvelope: this.discreteEnvelope,
        };
        this.preset != this.type && (instrumentObject.preset = this.preset);
        for (let i = 0; i < Config.filterMorphCount; i++)
          null != this.eqSubFilters[i] &&
            (instrumentObject["eqSubFilters" + i] =
              this.eqSubFilters[i].toJsonObject());
        const effects = [];
        for (const effect of Config.effectOrder)
          this.effects & (1 << effect) &&
            effects.push(Config.effectNames[effect]);
        if (
          ((instrumentObject.effects = effects),
          effectsIncludeTransition(this.effects) &&
            ((instrumentObject.transition =
              Config.transitions[this.transition].name),
            (instrumentObject.clicklessTransition = this.clicklessTransition)),
          effectsIncludeChord(this.effects) &&
            ((instrumentObject.chord = this.getChord().name),
            (instrumentObject.fastTwoNoteArp = this.fastTwoNoteArp),
            (instrumentObject.arpeggioSpeed = this.arpeggioSpeed)),
          effectsIncludePitchShift(this.effects) &&
            (instrumentObject.pitchShiftSemitones = this.pitchShift),
          effectsIncludeDetune(this.effects) &&
            (instrumentObject.detuneCents = Synth.detuneToCents(this.detune)),
          effectsIncludeVibrato(this.effects) &&
            (-1 == this.vibrato && (this.vibrato = 5),
            5 != this.vibrato
              ? (instrumentObject.vibrato = Config.vibratos[this.vibrato].name)
              : (instrumentObject.vibrato = "custom"),
            (instrumentObject.vibratoDepth = this.vibratoDepth),
            (instrumentObject.vibratoDelay = this.vibratoDelay),
            (instrumentObject.vibratoSpeed = this.vibratoSpeed),
            (instrumentObject.vibratoType = this.vibratoType)),
          effectsIncludeNoteFilter(this.effects))
        ) {
          (instrumentObject.noteFilterType = this.noteFilterType),
            (instrumentObject.noteSimpleCut = this.noteFilterSimpleCut),
            (instrumentObject.noteSimplePeak = this.noteFilterSimplePeak),
            (instrumentObject.noteFilter = this.noteFilter.toJsonObject());
          for (let i = 0; i < Config.filterMorphCount; i++)
            null != this.noteSubFilters[i] &&
              (instrumentObject["noteSubFilters" + i] =
                this.noteSubFilters[i].toJsonObject());
        }
        if (
          (effectsIncludeDistortion(this.effects) &&
            ((instrumentObject.distortion = Math.round(
              (100 * this.distortion) / (Config.distortionRange - 1)
            )),
            (instrumentObject.aliases = this.aliases)),
          effectsIncludeBitcrusher(this.effects) &&
            ((instrumentObject.bitcrusherOctave =
              (Config.bitcrusherFreqRange - 1 - this.bitcrusherFreq) *
              Config.bitcrusherOctaveStep),
            (instrumentObject.bitcrusherQuantization = Math.round(
              (100 * this.bitcrusherQuantization) /
                (Config.bitcrusherQuantizationRange - 1)
            ))),
          effectsIncludePanning(this.effects) &&
            ((instrumentObject.pan = Math.round(
              (100 * (this.pan - Config.panCenter)) / Config.panCenter
            )),
            (instrumentObject.panDelay = this.panDelay)),
          effectsIncludeChorus(this.effects) &&
            (instrumentObject.chorus = Math.round(
              (100 * this.chorus) / (Config.chorusRange - 1)
            )),
          effectsIncludeEcho(this.effects) &&
            ((instrumentObject.echoSustain = Math.round(
              (100 * this.echoSustain) / (Config.echoSustainRange - 1)
            )),
            (instrumentObject.echoDelayBeats =
              Math.round(
                (1e3 * (this.echoDelay + 1) * Config.echoDelayStepTicks) /
                  (Config.ticksPerPart * Config.partsPerBeat)
              ) / 1e3)),
          effectsIncludeReverb(this.effects) &&
            (instrumentObject.reverb = Math.round(
              (100 * this.reverb) / (Config.reverbRange - 1)
            )),
          4 != this.type &&
            ((instrumentObject.fadeInSeconds =
              Math.round(1e4 * Synth.fadeInSettingToSeconds(this.fadeIn)) /
              1e4),
            (instrumentObject.fadeOutTicks = Synth.fadeOutSettingToTicks(
              this.fadeOut
            ))),
          5 == this.type || 7 == this.type)
        ) {
          instrumentObject.harmonics = [];
          for (let i = 0; i < Config.harmonicsControlPoints; i++)
            instrumentObject.harmonics[i] = Math.round(
              (100 * this.harmonicsWave.harmonics[i]) / Config.harmonicsMax
            );
        }
        if (2 == this.type)
          (instrumentObject.wave = Config.chipNoises[this.chipNoise].name),
            (instrumentObject.unison =
              this.unison == Config.unisons.length
                ? "custom"
                : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign));
        else if (3 == this.type) {
          instrumentObject.spectrum = [];
          for (let i = 0; i < Config.spectrumControlPoints; i++)
            instrumentObject.spectrum[i] = Math.round(
              (100 * this.spectrumWave.spectrum[i]) / Config.spectrumMax
            );
          (instrumentObject.unison =
            this.unison == Config.unisons.length
              ? "custom"
              : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign));
        } else if (4 == this.type) {
          instrumentObject.drums = [];
          for (let j = 0; j < Config.drumCount; j++) {
            const spectrum = [];
            for (let i = 0; i < Config.spectrumControlPoints; i++)
              spectrum[i] = Math.round(
                (100 * this.drumsetSpectrumWaves[j].spectrum[i]) /
                  Config.spectrumMax
              );
            instrumentObject.drums[j] = {
              filterEnvelope: this.getDrumsetEnvelope(j).name,
              spectrum: spectrum,
            };
          }
        } else if (0 == this.type)
          (instrumentObject.wave = Config.chipWaves[this.chipWave].name),
            (instrumentObject.unison =
              this.unison == Config.unisons.length
                ? "custom"
                : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign)),
            (instrumentObject.isUsingAdvancedLoopControls =
              this.isUsingAdvancedLoopControls),
            (instrumentObject.chipWaveLoopStart = this.chipWaveLoopStart),
            (instrumentObject.chipWaveLoopEnd = this.chipWaveLoopEnd),
            (instrumentObject.chipWaveLoopMode = this.chipWaveLoopMode),
            (instrumentObject.chipWavePlayBackwards =
              this.chipWavePlayBackwards),
            (instrumentObject.chipWaveStartOffset = this.chipWaveStartOffset);
        else if (6 == this.type)
          (instrumentObject.pulseWidth = this.pulseWidth),
            (instrumentObject.decimalOffset = this.decimalOffset),
            (instrumentObject.unison =
              this.unison == Config.unisons.length
                ? "custom"
                : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign));
        else if (8 == this.type)
          (instrumentObject.pulseWidth = this.pulseWidth),
            (instrumentObject.decimalOffset = this.decimalOffset),
            (instrumentObject.dynamism = Math.round(
              (100 * this.supersawDynamism) / Config.supersawDynamismMax
            )),
            (instrumentObject.spread = Math.round(
              (100 * this.supersawSpread) / Config.supersawSpreadMax
            )),
            (instrumentObject.shape = Math.round(
              (100 * this.supersawShape) / Config.supersawShapeMax
            ));
        else if (7 == this.type)
          (instrumentObject.unison =
            this.unison == Config.unisons.length
              ? "custom"
              : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign)),
            (instrumentObject.stringSustain = Math.round(
              (100 * this.stringSustain) / (Config.stringSustainRange - 1)
            )),
            Config.enableAcousticSustain &&
              (instrumentObject.stringSustainType =
                Config.sustainTypeNames[this.stringSustainType]);
        else if (5 == this.type)
          (instrumentObject.unison =
            this.unison == Config.unisons.length
              ? "custom"
              : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign));
        else if (1 == this.type || 11 == this.type) {
          const operatorArray = [];
          for (const operator of this.operators)
            operatorArray.push({
              frequency: Config.operatorFrequencies[operator.frequency].name,
              amplitude: operator.amplitude,
              waveform: Config.operatorWaves[operator.waveform].name,
              pulseWidth: operator.pulseWidth,
            });
          if (1 == this.type)
            (instrumentObject.algorithm =
              Config.algorithms[this.algorithm].name),
              (instrumentObject.feedbackType =
                Config.feedbacks[this.feedbackType].name),
              (instrumentObject.feedbackAmplitude = this.feedbackAmplitude),
              (instrumentObject.operators = operatorArray);
          else {
            if (
              ((instrumentObject.algorithm =
                Config.algorithms6Op[this.algorithm6Op].name),
              (instrumentObject.feedbackType =
                Config.feedbacks6Op[this.feedbackType6Op].name),
              (instrumentObject.feedbackAmplitude = this.feedbackAmplitude),
              0 == this.algorithm6Op)
            ) {
              const customAlgorithm = {};
              (customAlgorithm.mods = this.customAlgorithm.modulatedBy),
                (customAlgorithm.carrierCount =
                  this.customAlgorithm.carrierCount),
                (instrumentObject.customAlgorithm = customAlgorithm);
            }
            if (0 == this.feedbackType6Op) {
              const customFeedback = {};
              (customFeedback.mods = this.customFeedbackType.indices),
                (instrumentObject.customFeedback = customFeedback);
            }
            instrumentObject.operators = operatorArray;
          }
        } else if (9 == this.type) {
          (instrumentObject.wave = Config.chipWaves[this.chipWave].name),
            (instrumentObject.unison =
              this.unison == Config.unisons.length
                ? "custom"
                : Config.unisons[this.unison].name),
            this.unison == Config.unisons.length &&
              ((instrumentObject.unisonVoices = this.unisonVoices),
              (instrumentObject.unisonSpread = this.unisonSpread),
              (instrumentObject.unisonOffset = this.unisonOffset),
              (instrumentObject.unisonExpression = this.unisonExpression),
              (instrumentObject.unisonSign = this.unisonSign)),
            (instrumentObject.customChipWave = new Float64Array(64)),
            (instrumentObject.customChipWaveIntegral = new Float64Array(65));
          for (let i = 0; i < this.customChipWave.length; i++)
            instrumentObject.customChipWave[i] = this.customChipWave[i];
        } else {
          if (10 != this.type) throw new Error("Unrecognized instrument type");
          (instrumentObject.modChannels = []),
            (instrumentObject.modInstruments = []),
            (instrumentObject.modSettings = []),
            (instrumentObject.modFilterTypes = []);
          for (let mod = 0; mod < Config.modCount; mod++)
            (instrumentObject.modChannels[mod] = this.modChannels[mod]),
              (instrumentObject.modInstruments[mod] = this.modInstruments[mod]),
              (instrumentObject.modSettings[mod] = this.modulators[mod]),
              (instrumentObject.modFilterTypes[mod] = this.modFilterTypes[mod]);
        }
        const envelopes = [];
        for (let i = 0; i < this.envelopeCount; i++)
          envelopes.push(this.envelopes[i].toJsonObject());
        return (instrumentObject.envelopes = envelopes), instrumentObject;
      }
      fromJsonObject(
        instrumentObject,
        isNoiseChannel,
        isModChannel,
        useSlowerRhythm,
        useFastTwoNoteArp,
        legacyGlobalReverb = 0,
        jsonFormat = Config.jsonFormat
      ) {
        null == instrumentObject && (instrumentObject = {});
        let type = Config.instrumentTypeNames.indexOf(instrumentObject.type);
        if (
          ("SynthBox" == jsonFormat &&
            "FM" == instrumentObject.type &&
            (type = Config.instrumentTypeNames.indexOf("FM6op")),
          -1 == type && (type = isModChannel ? 10 : isNoiseChannel ? 2 : 0),
          this.setTypeAndReset(type, isNoiseChannel, isModChannel),
          (this.effects &= -5),
          null != instrumentObject.preset &&
            (this.preset = instrumentObject.preset >>> 0),
          null != instrumentObject.volume
            ? (this.volume =
                "JummBox" == jsonFormat ||
                "Midbox" == jsonFormat ||
                "SynthBox" == jsonFormat ||
                "UltraBox" == jsonFormat
                  ? clamp(
                      -Config.volumeRange / 2,
                      Config.volumeRange / 2 + 1,
                      0 | instrumentObject.volume
                    )
                  : Math.round(
                      (25 *
                        -clamp(
                          0,
                          8,
                          Math.round(5 - (0 | instrumentObject.volume) / 20)
                        )) /
                        7
                    ))
            : (this.volume = 0),
          null != instrumentObject.envelopeSpeed
            ? (this.envelopeSpeed = clamp(
                0,
                Config.modulators.dictionary["envelope speed"].maxRawVol + 1,
                0 | instrumentObject.envelopeSpeed
              ))
            : (this.envelopeSpeed = 12),
          null != instrumentObject.discreteEnvelope
            ? (this.discreteEnvelope = instrumentObject.discreteEnvelope)
            : (this.discreteEnvelope = !1),
          Array.isArray(instrumentObject.effects))
        ) {
          let effects = 0;
          for (let i = 0; i < instrumentObject.effects.length; i++)
            effects |=
              1 << Config.effectNames.indexOf(instrumentObject.effects[i]);
          this.effects = 4095 & effects;
        } else {
          const legacyEffectsNames = [
            "none",
            "reverb",
            "chorus",
            "chorus & reverb",
          ];
          (this.effects = legacyEffectsNames.indexOf(instrumentObject.effects)),
            -1 == this.effects && (this.effects = 2 == this.type ? 0 : 1);
        }
        this.transition = Config.transitions.dictionary.normal.index;
        const transitionProperty =
          instrumentObject.transition || instrumentObject.envelope;
        if (null != transitionProperty) {
          let transition = Config.transitions.dictionary[transitionProperty];
          if (
            null == instrumentObject.fadeInSeconds ||
            null == instrumentObject.fadeOutTicks
          ) {
            const legacySettings = {
              binary: {
                transition: "interrupt",
                fadeInSeconds: 0,
                fadeOutTicks: -1,
              },
              seamless: {
                transition: "interrupt",
                fadeInSeconds: 0,
                fadeOutTicks: -1,
              },
              sudden: {
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
              },
              hard: {
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: -3,
              },
              smooth: {
                transition: "normal",
                fadeInSeconds: 0.025,
                fadeOutTicks: -3,
              },
              soft: {
                transition: "normal",
                fadeInSeconds: 0.025,
                fadeOutTicks: -3,
              },
              slide: {
                transition: "slide in pattern",
                fadeInSeconds: 0.025,
                fadeOutTicks: -3,
              },
              "cross fade": {
                transition: "normal",
                fadeInSeconds: 0.04,
                fadeOutTicks: 6,
              },
              "hard fade": {
                transition: "normal",
                fadeInSeconds: 0,
                fadeOutTicks: 48,
              },
              "medium fade": {
                transition: "normal",
                fadeInSeconds: 0.0125,
                fadeOutTicks: 72,
              },
              "soft fade": {
                transition: "normal",
                fadeInSeconds: 0.06,
                fadeOutTicks: 96,
              },
            }[transitionProperty];
            null != legacySettings &&
              ((transition =
                Config.transitions.dictionary[legacySettings.transition]),
              (this.fadeIn = Synth.secondsToFadeInSetting(
                legacySettings.fadeInSeconds
              )),
              (this.fadeOut = Synth.ticksToFadeOutSetting(
                legacySettings.fadeOutTicks
              )));
          }
          null != transition && (this.transition = transition.index),
            this.transition != Config.transitions.dictionary.normal.index &&
              (this.effects = 1024 | this.effects);
        }
        null != instrumentObject.fadeInSeconds &&
          (this.fadeIn = Synth.secondsToFadeInSetting(
            +instrumentObject.fadeInSeconds
          )),
          null != instrumentObject.fadeOutTicks &&
            (this.fadeOut = Synth.ticksToFadeOutSetting(
              +instrumentObject.fadeOutTicks
            ));
        {
          const chordProperty = instrumentObject.chord,
            legacyChordNames = { harmony: "simultaneous" },
            chord =
              Config.chords.dictionary[legacyChordNames[chordProperty]] ||
              Config.chords.dictionary[chordProperty];
          null != chord
            ? (this.chord = chord.index)
            : 2 == this.type
              ? (this.chord = Config.chords.dictionary.arpeggio.index)
              : 7 == this.type
                ? (this.chord = Config.chords.dictionary.strum.index)
                : 0 == this.type
                  ? (this.chord = Config.chords.dictionary.arpeggio.index)
                  : 1 == this.type || 11 == this.type
                    ? (this.chord =
                        Config.chords.dictionary["custom interval"].index)
                    : (this.chord =
                        Config.chords.dictionary.simultaneous.index);
        }
        this.unison = Config.unisons.dictionary.none.index;
        const unisonProperty =
          instrumentObject.unison ||
          instrumentObject.interval ||
          instrumentObject.chorus;
        if (null != unisonProperty) {
          const legacyChorusNames = {
              union: "none",
              fifths: "fifth",
              octaves: "octave",
              error: "voiced",
            },
            unison =
              Config.unisons.dictionary[legacyChorusNames[unisonProperty]] ||
              Config.unisons.dictionary[unisonProperty];
          null != unison && (this.unison = unison.index),
            "custom" == unisonProperty && (this.unison = Config.unisons.length);
        }
        if (
          ((this.unisonVoices =
            null == instrumentObject.unisonVoices
              ? Config.unisons[this.unison].voices
              : instrumentObject.unisonVoices),
          (this.unisonSpread =
            null == instrumentObject.unisonSpread
              ? Config.unisons[this.unison].spread
              : instrumentObject.unisonSpread),
          (this.unisonOffset =
            null == instrumentObject.unisonOffset
              ? Config.unisons[this.unison].offset
              : instrumentObject.unisonOffset),
          (this.unisonExpression =
            null == instrumentObject.unisonExpression
              ? Config.unisons[this.unison].expression
              : instrumentObject.unisonExpression),
          (this.unisonSign =
            null == instrumentObject.unisonSign
              ? Config.unisons[this.unison].sign
              : instrumentObject.unisonSign),
          "custom harmony" == instrumentObject.chorus &&
            ((this.unison = Config.unisons.dictionary.hum.index),
            (this.chord = Config.chords.dictionary["custom interval"].index)),
          this.chord == Config.chords.dictionary.simultaneous.index ||
            Array.isArray(instrumentObject.effects) ||
            (this.effects = 2048 | this.effects),
          null != instrumentObject.pitchShiftSemitones &&
            (this.pitchShift = clamp(
              0,
              Config.pitchShiftRange,
              Math.round(+instrumentObject.pitchShiftSemitones)
            )),
          null != instrumentObject.octoff)
        ) {
          let potentialPitchShift = instrumentObject.octoff;
          (this.effects = 128 | this.effects),
            (this.pitchShift =
              "+1 (octave)" == potentialPitchShift ||
              "+2 (2 octaves)" == potentialPitchShift
                ? 24
                : "+1/2 (fifth)" == potentialPitchShift ||
                    "+1 1/2 (octave and fifth)" == potentialPitchShift
                  ? 18
                  : "-1 (octave)" == potentialPitchShift ||
                      "-2 (2 octaves" == potentialPitchShift
                    ? 0
                    : "-1/2 (fifth)" == potentialPitchShift ||
                        "-1 1/2 (octave and fifth)" == potentialPitchShift
                      ? 6
                      : 12);
        }
        null != instrumentObject.detuneCents &&
          (this.detune = clamp(
            Config.detuneMin,
            Config.detuneMax + 1,
            Math.round(Synth.centsToDetune(+instrumentObject.detuneCents))
          )),
          (this.vibrato = Config.vibratos.dictionary.none.index);
        const vibratoProperty =
          instrumentObject.vibrato || instrumentObject.effect;
        if (null != vibratoProperty) {
          const legacyVibratoNames = {
              "vibrato light": "light",
              "vibrato delayed": "delayed",
              "vibrato heavy": "heavy",
            },
            vibrato =
              Config.vibratos.dictionary[legacyVibratoNames[unisonProperty]] ||
              Config.vibratos.dictionary[vibratoProperty];
          null != vibrato
            ? (this.vibrato = vibrato.index)
            : "custom" == vibratoProperty &&
              (this.vibrato = Config.vibratos.length),
            this.vibrato == Config.vibratos.length
              ? ((this.vibratoDepth = instrumentObject.vibratoDepth),
                (this.vibratoSpeed = instrumentObject.vibratoSpeed),
                (this.vibratoDelay = instrumentObject.vibratoDelay),
                (this.vibratoType = instrumentObject.vibratoType))
              : ((this.vibratoDepth = Config.vibratos[this.vibrato].amplitude),
                (this.vibratoDelay =
                  Config.vibratos[this.vibrato].delayTicks / 2),
                (this.vibratoSpeed = 10),
                (this.vibratoType = Config.vibratos[this.vibrato].type)),
            vibrato != Config.vibratos.dictionary.none &&
              (this.effects = 512 | this.effects);
        }
        if (
          (null != instrumentObject.pan
            ? ((this.pan = clamp(
                0,
                Config.panMax + 1,
                Math.round(
                  Config.panCenter +
                    ((0 | instrumentObject.pan) * Config.panCenter) / 100
                )
              )),
              this.pan != Config.panCenter && (this.effects = 4 | this.effects))
            : (this.pan = Config.panCenter),
          null != instrumentObject.panDelay
            ? (this.panDelay = 0 | instrumentObject.panDelay)
            : (this.panDelay = 10),
          null != instrumentObject.detune
            ? (this.detune = clamp(
                Config.detuneMin,
                Config.detuneMax + 1,
                0 | instrumentObject.detune
              ))
            : null == instrumentObject.detuneCents &&
              (this.detune = Config.detuneCenter),
          null != instrumentObject.distortion &&
            (this.distortion = clamp(
              0,
              Config.distortionRange,
              Math.round(
                ((Config.distortionRange - 1) *
                  (0 | instrumentObject.distortion)) /
                  100
              )
            )),
          null != instrumentObject.bitcrusherOctave &&
            (this.bitcrusherFreq =
              Config.bitcrusherFreqRange -
              1 -
              +instrumentObject.bitcrusherOctave / Config.bitcrusherOctaveStep),
          null != instrumentObject.bitcrusherQuantization &&
            (this.bitcrusherQuantization = clamp(
              0,
              Config.bitcrusherQuantizationRange,
              Math.round(
                ((Config.bitcrusherQuantizationRange - 1) *
                  (0 | instrumentObject.bitcrusherQuantization)) /
                  100
              )
            )),
          null != instrumentObject.echoSustain &&
            (this.echoSustain = clamp(
              0,
              Config.echoSustainRange,
              Math.round(
                ((Config.echoSustainRange - 1) *
                  (0 | instrumentObject.echoSustain)) /
                  100
              )
            )),
          null != instrumentObject.echoDelayBeats &&
            (this.echoDelay = clamp(
              0,
              Config.echoDelayRange,
              Math.round(
                (+instrumentObject.echoDelayBeats *
                  (Config.ticksPerPart * Config.partsPerBeat)) /
                  Config.echoDelayStepTicks -
                  1
              )
            )),
          isNaN(instrumentObject.chorus) ||
            (this.chorus = clamp(
              0,
              Config.chorusRange,
              Math.round(
                ((Config.chorusRange - 1) * (0 | instrumentObject.chorus)) / 100
              )
            )),
          null != instrumentObject.reverb
            ? (this.reverb = clamp(
                0,
                Config.reverbRange,
                Math.round(
                  ((Config.reverbRange - 1) * (0 | instrumentObject.reverb)) /
                    100
                )
              ))
            : (this.reverb = legacyGlobalReverb),
          null != instrumentObject.pulseWidth
            ? (this.pulseWidth = clamp(
                1,
                Config.pulseWidthRange + 1,
                Math.round(instrumentObject.pulseWidth)
              ))
            : (this.pulseWidth = Config.pulseWidthRange),
          null != instrumentObject.decimalOffset
            ? (this.decimalOffset = clamp(
                0,
                100,
                Math.round(instrumentObject.decimalOffset)
              ))
            : (this.decimalOffset = 0),
          null != instrumentObject.dynamism
            ? (this.supersawDynamism = clamp(
                0,
                Config.supersawDynamismMax + 1,
                Math.round(
                  (Config.supersawDynamismMax *
                    (0 | instrumentObject.dynamism)) /
                    100
                )
              ))
            : (this.supersawDynamism = Config.supersawDynamismMax),
          null != instrumentObject.spread
            ? (this.supersawSpread = clamp(
                0,
                Config.supersawSpreadMax + 1,
                Math.round(
                  (Config.supersawSpreadMax * (0 | instrumentObject.spread)) /
                    100
                )
              ))
            : (this.supersawSpread = Math.ceil(Config.supersawSpreadMax / 2)),
          null != instrumentObject.shape
            ? (this.supersawShape = clamp(
                0,
                Config.supersawShapeMax + 1,
                Math.round(
                  (Config.supersawShapeMax * (0 | instrumentObject.shape)) / 100
                )
              ))
            : (this.supersawShape = 0),
          null != instrumentObject.harmonics)
        ) {
          for (let i = 0; i < Config.harmonicsControlPoints; i++)
            this.harmonicsWave.harmonics[i] = Math.max(
              0,
              Math.min(
                Config.harmonicsMax,
                Math.round(
                  (Config.harmonicsMax * +instrumentObject.harmonics[i]) / 100
                )
              )
            );
          this.harmonicsWave.markCustomWaveDirty();
        } else this.harmonicsWave.reset();
        if (null != instrumentObject.spectrum)
          for (let i = 0; i < Config.spectrumControlPoints; i++)
            (this.spectrumWave.spectrum[i] = Math.max(
              0,
              Math.min(
                Config.spectrumMax,
                Math.round(
                  (Config.spectrumMax * +instrumentObject.spectrum[i]) / 100
                )
              )
            )),
              this.spectrumWave.markCustomWaveDirty();
        else this.spectrumWave.reset(isNoiseChannel);
        null != instrumentObject.stringSustain
          ? (this.stringSustain = clamp(
              0,
              Config.stringSustainRange,
              Math.round(
                ((Config.stringSustainRange - 1) *
                  (0 | instrumentObject.stringSustain)) /
                  100
              )
            ))
          : (this.stringSustain = 10),
          (this.stringSustainType = Config.enableAcousticSustain
            ? Config.sustainTypeNames.indexOf(
                instrumentObject.stringSustainType
              )
            : 0),
          -1 == this.stringSustainType && (this.stringSustainType = 0),
          2 == this.type &&
            ((this.chipNoise = Config.chipNoises.findIndex(
              (wave) => wave.name == instrumentObject.wave
            )),
            "pink noise" == instrumentObject.wave &&
              (this.chipNoise = Config.chipNoises.findIndex(
                (wave) => "pink" == wave.name
              )),
            "brownian noise" == instrumentObject.wave &&
              (this.chipNoise = Config.chipNoises.findIndex(
                (wave) => "brownian" == wave.name
              )),
            -1 == this.chipNoise && (this.chipNoise = 1));
        const legacyEnvelopeNames = {
            custom: "note size",
            steady: "none",
            "pluck 1": "twang 1",
            "pluck 2": "twang 2",
            "pluck 3": "twang 3",
          },
          getEnvelope = (name) =>
            null != legacyEnvelopeNames[name]
              ? Config.envelopes.dictionary[legacyEnvelopeNames[name]]
              : Config.envelopes.dictionary[name];
        if (4 == this.type && null != instrumentObject.drums)
          for (let j = 0; j < Config.drumCount; j++) {
            const drum = instrumentObject.drums[j];
            if (null != drum) {
              if (
                ((this.drumsetEnvelopes[j] =
                  Config.envelopes.dictionary["twang 2"].index),
                null != drum.filterEnvelope)
              ) {
                const envelope = getEnvelope(drum.filterEnvelope);
                null != envelope && (this.drumsetEnvelopes[j] = envelope.index);
              }
              if (null != drum.spectrum)
                for (let i = 0; i < Config.spectrumControlPoints; i++)
                  this.drumsetSpectrumWaves[j].spectrum[i] = Math.max(
                    0,
                    Math.min(
                      Config.spectrumMax,
                      Math.round((Config.spectrumMax * +drum.spectrum[i]) / 100)
                    )
                  );
              this.drumsetSpectrumWaves[j].markCustomWaveDirty();
            }
          }
        if (0 == this.type) {
          const legacyWaveNames = {
              triangle: 1,
              square: 2,
              "pulse wide": 3,
              "pulse narrow": 4,
              sawtooth: 5,
              "double saw": 6,
              "double pulse": 7,
              spiky: 8,
              plateau: 0,
            },
            modboxWaveNames = {
              "10% pulse": 22,
              "sunsoft bass": 23,
              "loud pulse": 24,
              sax: 25,
              guitar: 26,
              "atari bass": 28,
              "atari pulse": 29,
              "1% pulse": 30,
              "curved sawtooth": 31,
              viola: 32,
              brass: 33,
              "acoustic bass": 34,
              lyre: 35,
              "ramp pulse": 36,
              piccolo: 37,
              squaretooth: 38,
              flatline: 39,
              "pnryshk a (u5)": 40,
              "pnryshk b (riff)": 41,
            },
            sandboxWaveNames = {
              "shrill lute": 42,
              "shrill bass": 44,
              "nes pulse": 45,
              "saw bass": 46,
              euphonium: 47,
              "shrill pulse": 48,
              "r-sawtooth": 49,
              recorder: 50,
              "narrow saw": 51,
              "deep square": 52,
              "ring pulse": 53,
              "double sine": 54,
              contrabass: 55,
              "double bass": 56,
            },
            zefboxWaveNames = {
              "semi-square": 63,
              "deep square": 64,
              squaretal: 40,
              "saw wide": 65,
              "saw narrow ": 66,
              "deep sawtooth": 67,
              sawtal: 68,
              pulse: 69,
              "triple pulse": 70,
              "high pulse": 71,
              "deep pulse": 72,
            },
            miscWaveNames = {
              test1: 56,
              "pokey 4bit lfsr": 57,
              "pokey 5step bass": 58,
              "isolated spiky": 59,
              "unnamed 1": 60,
              "unnamed 2": 61,
              "guitar string": 75,
              intense: 76,
              "buzz wave": 77,
              "pokey square": 57,
              "pokey bass": 58,
              "banana wave": 83,
              "test 1": 84,
              "test 2": 84,
              "real snare": 85,
              "earthbound o. guitar": 86,
            },
            paandorasboxWaveNames = {
              kick: 87,
              snare: 88,
              piano1: 89,
              WOW: 90,
              overdrive: 91,
              trumpet: 92,
              saxophone: 93,
              orchestrahit: 94,
              "detached violin": 95,
              synth: 96,
              sonic3snare: 97,
              "come on": 98,
              choir: 99,
              overdriveguitar: 100,
              flute: 101,
              "legato violin": 102,
              "tremolo violin": 103,
              "amen break": 104,
              "pizzicato violin": 105,
              "tim allen grunt": 106,
              tuba: 107,
              loopingcymbal: 108,
              standardkick: 109,
              standardsnare: 110,
              closedhihat: 111,
              foothihat: 112,
              openhihat: 113,
              crashcymbal: 114,
              pianoC4: 115,
              "liver pad": 116,
              marimba: 117,
              susdotwav: 118,
              wackyboxtts: 119,
            };
          this.chipWave = -1;
          const rawName = instrumentObject.wave;
          for (const table of [
            legacyWaveNames,
            modboxWaveNames,
            sandboxWaveNames,
            zefboxWaveNames,
            miscWaveNames,
            paandorasboxWaveNames,
          ])
            if (
              -1 == this.chipWave &&
              null != table[rawName] &&
              null != Config.chipWaves[table[rawName]]
            ) {
              this.chipWave = table[rawName];
              break;
            }
          if (-1 == this.chipWave) {
            const potentialChipWaveIndex = Config.chipWaves.findIndex(
              (wave) => wave.name == rawName
            );
            -1 != potentialChipWaveIndex &&
              (this.chipWave = potentialChipWaveIndex);
          }
          -1 == this.chipWave && (this.chipWave = 1);
        }
        if (1 == this.type || 11 == this.type) {
          if (1 == this.type)
            (this.algorithm = Config.algorithms.findIndex(
              (algorithm) => algorithm.name == instrumentObject.algorithm
            )),
              -1 == this.algorithm && (this.algorithm = 0),
              (this.feedbackType = Config.feedbacks.findIndex(
                (feedback) => feedback.name == instrumentObject.feedbackType
              )),
              -1 == this.feedbackType && (this.feedbackType = 0);
          else if (
            ((this.algorithm6Op = Config.algorithms6Op.findIndex(
              (algorithm6Op) => algorithm6Op.name == instrumentObject.algorithm
            )),
            -1 == this.algorithm6Op && (this.algorithm6Op = 1),
            0 == this.algorithm6Op
              ? this.customAlgorithm.set(
                  instrumentObject.customAlgorithm.carrierCount,
                  instrumentObject.customAlgorithm.mods
                )
              : this.customAlgorithm.fromPreset(this.algorithm6Op),
            (this.feedbackType6Op = Config.feedbacks6Op.findIndex(
              (feedback6Op) => feedback6Op.name == instrumentObject.feedbackType
            )),
            -1 == this.feedbackType6Op && "SynthBox" == jsonFormat)
          ) {
            this.feedbackType6Op = Config.algorithms6Op.findIndex(
              (feedbackType6Op) => "Custom" == feedbackType6Op.name
            );
            let synthboxLegacyFeedbacks = toNameMap([
                { name: "2⟲ 3⟲", indices: [[], [2], [3], [], [], []] },
                { name: "4⟲ 5⟲", indices: [[], [], [], [4], [5], []] },
                { name: "5⟲ 6⟲", indices: [[], [], [], [], [5], [6]] },
                { name: "1⟲ 6⟲", indices: [[1], [], [], [], [], [6]] },
                { name: "1⟲ 3⟲", indices: [[1], [], [3], [], [], []] },
                { name: "1⟲ 4⟲", indices: [[1], [], [], [4], [], []] },
                { name: "1⟲ 5⟲", indices: [[1], [], [], [], [5], []] },
                { name: "4⟲ 6⟲", indices: [[], [], [], [4], [], [6]] },
                { name: "2⟲ 6⟲", indices: [[], [2], [], [], [], [6]] },
                { name: "3⟲ 6⟲", indices: [[], [], [3], [], [], [6]] },
                { name: "4⟲ 5⟲ 6⟲", indices: [[], [], [], [4], [5], [6]] },
                { name: "1⟲ 3⟲ 6⟲", indices: [[1], [], [3], [], [], [6]] },
                { name: "2→5", indices: [[], [], [], [], [2], []] },
                { name: "2→6", indices: [[], [], [], [], [], [2]] },
                { name: "3→5", indices: [[], [], [], [], [3], []] },
                { name: "3→6", indices: [[], [], [], [], [], [3]] },
                { name: "4→6", indices: [[], [], [], [], [], [4]] },
                { name: "5→6", indices: [[], [], [], [], [], [5]] },
                { name: "1→3→4", indices: [[], [], [1], [], [3], []] },
                { name: "2→5→6", indices: [[], [], [], [], [2], [5]] },
                { name: "2→4→6", indices: [[], [], [], [2], [], [4]] },
                { name: "4→5→6", indices: [[], [], [], [], [4], [5]] },
                { name: "3→4→5→6", indices: [[], [], [], [3], [4], [5]] },
                { name: "2→3→4→5→6", indices: [[], [1], [2], [3], [4], [5]] },
                { name: "1→2→3→4→5→6", indices: [[], [1], [2], [3], [4], [5]] },
              ]),
              synthboxFeedbackType =
                synthboxLegacyFeedbacks[
                  synthboxLegacyFeedbacks.findIndex(
                    (feedback) => feedback.name == instrumentObject.feedbackType
                  )
                ].indices;
            this.customFeedbackType.set(synthboxFeedbackType);
          } else
            -1 == this.feedbackType6Op && (this.feedbackType6Op = 1),
              0 == this.feedbackType6Op
                ? this.customFeedbackType.set(
                    instrumentObject.customFeedback.mods
                  )
                : this.customFeedbackType.fromPreset(this.feedbackType6Op);
          null != instrumentObject.feedbackAmplitude
            ? (this.feedbackAmplitude = clamp(
                0,
                Config.operatorAmplitudeMax + 1,
                0 | instrumentObject.feedbackAmplitude
              ))
            : (this.feedbackAmplitude = 0);
          for (
            let j = 0;
            j < Config.operatorCount + (11 == this.type ? 2 : 0);
            j++
          ) {
            const operator = this.operators[j];
            let operatorObject = void 0;
            null != instrumentObject.operators &&
              (operatorObject = instrumentObject.operators[j]),
              null == operatorObject && (operatorObject = {}),
              (operator.frequency = Config.operatorFrequencies.findIndex(
                (freq) => freq.name == operatorObject.frequency
              )),
              -1 == operator.frequency && (operator.frequency = 0),
              null != operatorObject.amplitude
                ? (operator.amplitude = clamp(
                    0,
                    Config.operatorAmplitudeMax + 1,
                    0 | operatorObject.amplitude
                  ))
                : (operator.amplitude = 0),
              null != operatorObject.waveform
                ? ((operator.waveform = Config.operatorWaves.findIndex(
                    (wave) => wave.name == operatorObject.waveform
                  )),
                  -1 == operator.waveform &&
                    ("square" == operatorObject.waveform
                      ? ((operator.waveform =
                          Config.operatorWaves.dictionary["pulse width"].index),
                        (operator.pulseWidth = 5))
                      : (operator.waveform = 0)))
                : (operator.waveform = 0),
              null != operatorObject.pulseWidth
                ? (operator.pulseWidth = 0 | operatorObject.pulseWidth)
                : (operator.pulseWidth = 5);
          }
        } else if (9 == this.type) {
          if (instrumentObject.customChipWave) {
            for (let i = 0; i < 64; i++)
              this.customChipWave[i] = instrumentObject.customChipWave[i];
            let sum = 0;
            for (let i = 0; i < this.customChipWave.length; i++)
              sum += this.customChipWave[i];
            const average = sum / this.customChipWave.length;
            let cumulative = 0,
              wavePrev = 0;
            for (let i = 0; i < this.customChipWave.length; i++)
              (cumulative += wavePrev),
                (wavePrev = this.customChipWave[i] - average),
                (this.customChipWaveIntegral[i] = cumulative);
            this.customChipWaveIntegral[64] = 0;
          }
        } else if (10 == this.type && null != instrumentObject.modChannels)
          for (let mod = 0; mod < Config.modCount; mod++)
            (this.modChannels[mod] = instrumentObject.modChannels[mod]),
              (this.modInstruments[mod] = instrumentObject.modInstruments[mod]),
              (this.modulators[mod] = instrumentObject.modSettings[mod]),
              null != instrumentObject.modFilterTypes &&
                (this.modFilterTypes[mod] =
                  instrumentObject.modFilterTypes[mod]);
        if (10 != this.type) {
          this.chord == Config.chords.dictionary.arpeggio.index &&
          null != instrumentObject.arpeggioSpeed
            ? (this.arpeggioSpeed = instrumentObject.arpeggioSpeed)
            : (this.arpeggioSpeed = useSlowerRhythm ? 9 : 12),
            null != instrumentObject.fastTwoNoteArp
              ? (this.fastTwoNoteArp = instrumentObject.fastTwoNoteArp)
              : (this.fastTwoNoteArp = useFastTwoNoteArp),
            null != instrumentObject.clicklessTransition
              ? (this.clicklessTransition =
                  instrumentObject.clicklessTransition)
              : (this.clicklessTransition = !1),
            null != instrumentObject.aliases
              ? (this.aliases = instrumentObject.aliases)
              : "ModBox" == jsonFormat
                ? ((this.effects = 8 | this.effects),
                  (this.aliases = !0),
                  (this.distortion = 0))
                : (this.aliases = !1),
            null != instrumentObject.noteFilterType &&
              (this.noteFilterType = instrumentObject.noteFilterType),
            null != instrumentObject.noteSimpleCut &&
              (this.noteFilterSimpleCut = instrumentObject.noteSimpleCut),
            null != instrumentObject.noteSimplePeak &&
              (this.noteFilterSimplePeak = instrumentObject.noteSimplePeak),
            null != instrumentObject.noteFilter
              ? this.noteFilter.fromJsonObject(instrumentObject.noteFilter)
              : this.noteFilter.reset();
          for (let i = 0; i < Config.filterMorphCount; i++)
            Array.isArray(instrumentObject["noteSubFilters" + i]) &&
              ((this.noteSubFilters[i] = new FilterSettings()),
              this.noteSubFilters[i].fromJsonObject(
                instrumentObject["noteSubFilters" + i]
              ));
          if (
            (null != instrumentObject.eqFilterType &&
              (this.eqFilterType = instrumentObject.eqFilterType),
            null != instrumentObject.eqSimpleCut &&
              (this.eqFilterSimpleCut = instrumentObject.eqSimpleCut),
            null != instrumentObject.eqSimplePeak &&
              (this.eqFilterSimplePeak = instrumentObject.eqSimplePeak),
            Array.isArray(instrumentObject.eqFilter))
          )
            this.eqFilter.fromJsonObject(instrumentObject.eqFilter);
          else {
            this.eqFilter.reset();
            const legacySettings = {},
              filterCutoffMaxHz = 8e3,
              filterCutoffRange = 11,
              filterResonanceRange = 8;
            if (
              (null != instrumentObject.filterCutoffHz
                ? (legacySettings.filterCutoff = clamp(
                    0,
                    filterCutoffRange,
                    Math.round(
                      filterCutoffRange -
                        1 +
                        (2 *
                          Math.log(
                            (0 | instrumentObject.filterCutoffHz) /
                              filterCutoffMaxHz
                          )) /
                          Math.LN2
                    )
                  ))
                : (legacySettings.filterCutoff = 0 == this.type ? 6 : 10),
              null != instrumentObject.filterResonance
                ? (legacySettings.filterResonance = clamp(
                    0,
                    filterResonanceRange,
                    Math.round(
                      ((filterResonanceRange - 1) *
                        (0 | instrumentObject.filterResonance)) /
                        100
                    )
                  ))
                : (legacySettings.filterResonance = 0),
              (legacySettings.filterEnvelope = getEnvelope(
                instrumentObject.filterEnvelope
              )),
              (legacySettings.pulseEnvelope = getEnvelope(
                instrumentObject.pulseEnvelope
              )),
              (legacySettings.feedbackEnvelope = getEnvelope(
                instrumentObject.feedbackEnvelope
              )),
              Array.isArray(instrumentObject.operators))
            ) {
              legacySettings.operatorEnvelopes = [];
              for (
                let j = 0;
                j < Config.operatorCount + (11 == this.type ? 2 : 0);
                j++
              ) {
                let envelope;
                null != instrumentObject.operators[j] &&
                  (envelope = getEnvelope(
                    instrumentObject.operators[j].envelope
                  )),
                  (legacySettings.operatorEnvelopes[j] =
                    null != envelope
                      ? envelope
                      : Config.envelopes.dictionary.none);
              }
            }
            if (null != instrumentObject.filter) {
              const legacyToCutoff = [10, 6, 3, 0, 8, 5, 2],
                legacyToEnvelope = [
                  "none",
                  "none",
                  "none",
                  "none",
                  "decay 1",
                  "decay 2",
                  "decay 3",
                ],
                filterNames = [
                  "none",
                  "bright",
                  "medium",
                  "soft",
                  "decay bright",
                  "decay medium",
                  "decay soft",
                ],
                oldFilterNames = {
                  "sustain sharp": 1,
                  "sustain medium": 2,
                  "sustain soft": 3,
                  "decay sharp": 4,
                };
              let legacyFilter =
                null != oldFilterNames[instrumentObject.filter]
                  ? oldFilterNames[instrumentObject.filter]
                  : filterNames.indexOf(instrumentObject.filter);
              -1 == legacyFilter && (legacyFilter = 0),
                (legacySettings.filterCutoff = legacyToCutoff[legacyFilter]),
                (legacySettings.filterEnvelope = getEnvelope(
                  legacyToEnvelope[legacyFilter]
                )),
                (legacySettings.filterResonance = 0);
            }
            this.convertLegacySettings(legacySettings, !0);
          }
          for (let i = 0; i < Config.filterMorphCount; i++)
            Array.isArray(instrumentObject["eqSubFilters" + i]) &&
              ((this.eqSubFilters[i] = new FilterSettings()),
              this.eqSubFilters[i].fromJsonObject(
                instrumentObject["eqSubFilters" + i]
              ));
          if (Array.isArray(instrumentObject.envelopes)) {
            const envelopeArray = instrumentObject.envelopes;
            for (
              let i = 0;
              i < envelopeArray.length &&
              !(this.envelopeCount >= Config.maxEnvelopeCount);
              i++
            ) {
              const tempEnvelope = new EnvelopeSettings();
              tempEnvelope.fromJsonObject(envelopeArray[i]),
                this.addEnvelope(
                  tempEnvelope.target,
                  tempEnvelope.index,
                  tempEnvelope.envelope
                );
            }
          }
        }
        0 === type &&
          (null != instrumentObject.isUsingAdvancedLoopControls
            ? ((this.isUsingAdvancedLoopControls =
                instrumentObject.isUsingAdvancedLoopControls),
              (this.chipWaveLoopStart = instrumentObject.chipWaveLoopStart),
              (this.chipWaveLoopEnd = instrumentObject.chipWaveLoopEnd),
              (this.chipWaveLoopMode = instrumentObject.chipWaveLoopMode),
              (this.chipWavePlayBackwards =
                instrumentObject.chipWavePlayBackwards),
              (this.chipWaveStartOffset = instrumentObject.chipWaveStartOffset))
            : ((this.isUsingAdvancedLoopControls = !1),
              (this.chipWaveLoopStart = 0),
              (this.chipWaveLoopEnd =
                Config.rawRawChipWaves[this.chipWave].samples.length - 1),
              (this.chipWaveLoopMode = 0),
              (this.chipWavePlayBackwards = !1),
              (this.chipWaveStartOffset = 0)));
      }
      getLargestControlPointCount(forNoteFilter) {
        let largest;
        if (forNoteFilter) {
          largest = this.noteFilter.controlPointCount;
          for (let i = 0; i < Config.filterMorphCount; i++)
            null != this.noteSubFilters[i] &&
              this.noteSubFilters[i].controlPointCount > largest &&
              (largest = this.noteSubFilters[i].controlPointCount);
        } else {
          largest = this.eqFilter.controlPointCount;
          for (let i = 0; i < Config.filterMorphCount; i++)
            null != this.eqSubFilters[i] &&
              this.eqSubFilters[i].controlPointCount > largest &&
              (largest = this.eqSubFilters[i].controlPointCount);
        }
        return largest;
      }
      static frequencyFromPitch(pitch) {
        return 440 * Math.pow(2, (pitch - 69) / 12);
      }
      addEnvelope(target, index, envelope) {
        let makeEmpty = !1;
        if (
          (this.supportsEnvelopeTarget(target, index) || (makeEmpty = !0),
          this.envelopeCount >= Config.maxEnvelopeCount)
        )
          throw new Error();
        for (; this.envelopes.length <= this.envelopeCount; )
          this.envelopes[this.envelopes.length] = new EnvelopeSettings();
        const envelopeSettings = this.envelopes[this.envelopeCount];
        (envelopeSettings.target = makeEmpty
          ? Config.instrumentAutomationTargets.dictionary.none.index
          : target),
          (envelopeSettings.index = makeEmpty ? 0 : index),
          (envelopeSettings.envelope = envelope),
          this.envelopeCount++;
      }
      supportsEnvelopeTarget(target, index) {
        const automationTarget = Config.instrumentAutomationTargets[target];
        if (
          null == automationTarget.computeIndex &&
          "none" != automationTarget.name
        )
          return !1;
        if (index >= automationTarget.maxCount) return !1;
        if (
          null != automationTarget.compatibleInstruments &&
          -1 == automationTarget.compatibleInstruments.indexOf(this.type)
        )
          return !1;
        if (
          null != automationTarget.effect &&
          0 == (this.effects & (1 << automationTarget.effect))
        )
          return !1;
        if (automationTarget.isFilter) {
          let useControlPointCount = this.noteFilter.controlPointCount;
          if (
            (this.noteFilterType && (useControlPointCount = 1),
            index >= useControlPointCount)
          )
            return !1;
        }
        return (
          ("operatorFrequency" != automationTarget.name &&
            "operatorAmplitude" != automationTarget.name) ||
          !(index >= 4 + (11 == this.type ? 2 : 0))
        );
      }
      clearInvalidEnvelopeTargets() {
        for (
          let envelopeIndex = 0;
          envelopeIndex < this.envelopeCount;
          envelopeIndex++
        ) {
          const target = this.envelopes[envelopeIndex].target,
            index = this.envelopes[envelopeIndex].index;
          this.supportsEnvelopeTarget(target, index) ||
            ((this.envelopes[envelopeIndex].target =
              Config.instrumentAutomationTargets.dictionary.none.index),
            (this.envelopes[envelopeIndex].index = 0));
        }
      }
      getTransition() {
        return effectsIncludeTransition(this.effects)
          ? Config.transitions[this.transition]
          : 10 == this.type
            ? Config.transitions.dictionary.interrupt
            : Config.transitions.dictionary.normal;
      }
      getFadeInSeconds() {
        return 4 == this.type ? 0 : Synth.fadeInSettingToSeconds(this.fadeIn);
      }
      getFadeOutTicks() {
        return 4 == this.type
          ? Config.drumsetFadeOutTicks
          : Synth.fadeOutSettingToTicks(this.fadeOut);
      }
      getChord() {
        return effectsIncludeChord(this.effects)
          ? Config.chords[this.chord]
          : Config.chords.dictionary.simultaneous;
      }
      getDrumsetEnvelope(pitch) {
        if (4 != this.type)
          throw new Error("Can't getDrumsetEnvelope() for non-drumset.");
        return Config.envelopes[this.drumsetEnvelopes[pitch]];
      }
    }
    class Channel {
      constructor() {
        (this.octave = 0),
          (this.instruments = []),
          (this.patterns = []),
          (this.bars = []),
          (this.muted = !1),
          (this.name = "");
      }
    }
    class Song {
      constructor(string) {
        (this.scaleCustom = []),
          (this.channels = []),
          (this.limitDecay = 4),
          (this.limitRise = 4e3),
          (this.compressionThreshold = 1),
          (this.limitThreshold = 1),
          (this.compressionRatio = 1),
          (this.limitRatio = 1),
          (this.masterGain = 1),
          (this.inVolumeCap = 0),
          (this.outVolumeCap = 0),
          (this.getNewNoteVolume = (
            isMod,
            modChannel,
            modInstrument,
            modCount
          ) => {
            if (
              isMod &&
              null != modChannel &&
              null != modInstrument &&
              null != modCount
            ) {
              modCount = Config.modCount - modCount - 1;
              let vol =
                  Config.modulators[
                    this.channels[modChannel].instruments[modInstrument]
                      .modulators[modCount]
                  ].newNoteVol,
                tempoIndex = Config.modulators.dictionary.tempo.index;
              return (
                this.channels[modChannel].instruments[modInstrument].modulators[
                  modCount
                ] == tempoIndex &&
                  (vol =
                    this.tempo -
                    Config.modulators[tempoIndex].convertRealFactor),
                null != vol ? vol : 6
              );
            }
            return 6;
          }),
          (this.getVolumeCap = (isMod, modChannel, modInstrument, modCount) => {
            if (
              isMod &&
              null != modChannel &&
              null != modInstrument &&
              null != modCount
            ) {
              modCount = Config.modCount - modCount - 1;
              let instrument =
                  this.channels[modChannel].instruments[modInstrument],
                modulator = Config.modulators[instrument.modulators[modCount]],
                cap = modulator.maxRawVol;
              return null != cap
                ? (("eq filter" != modulator.name &&
                    "note filter" != modulator.name) ||
                    ((cap = Config.filterMorphCount - 1),
                    instrument.modFilterTypes[modCount] > 0 &&
                    instrument.modFilterTypes[modCount] % 2
                      ? (cap = Config.filterFreqRange)
                      : instrument.modFilterTypes[modCount] > 0 &&
                        (cap = Config.filterGainRange)),
                  cap)
                : 6;
            }
            return 6;
          }),
          (this.getVolumeCapForSetting = (isMod, modSetting, filterType) => {
            if (isMod) {
              let cap = Config.modulators[modSetting].maxRawVol;
              return null != cap
                ? (null == filterType ||
                    ("eq filter" != Config.modulators[modSetting].name &&
                      "note filter" != Config.modulators[modSetting].name) ||
                    ((cap = Config.filterMorphCount - 1),
                    filterType > 0 && filterType % 2
                      ? (cap = Config.filterFreqRange)
                      : filterType > 0 && (cap = Config.filterGainRange)),
                  cap)
                : Config.noteSizeMax;
            }
            return Config.noteSizeMax;
          }),
          null != string
            ? this.fromBase64String(string)
            : this.initToDefault(!0);
      }
      getChannelCount() {
        return (
          this.pitchChannelCount + this.noiseChannelCount + this.modChannelCount
        );
      }
      getMaxInstrumentsPerChannel() {
        return Math.max(
          this.layeredInstruments
            ? Config.layeredInstrumentCountMax
            : Config.instrumentCountMin,
          this.patternInstruments
            ? Config.patternInstrumentCountMax
            : Config.instrumentCountMin
        );
      }
      getMaxInstrumentsPerPattern(channelIndex) {
        return this.getMaxInstrumentsPerPatternForChannel(
          this.channels[channelIndex]
        );
      }
      getMaxInstrumentsPerPatternForChannel(channel) {
        return this.layeredInstruments
          ? Math.min(
              Config.layeredInstrumentCountMax,
              channel.instruments.length
            )
          : 1;
      }
      getChannelIsNoise(channelIndex) {
        return (
          channelIndex >= this.pitchChannelCount &&
          channelIndex < this.pitchChannelCount + this.noiseChannelCount
        );
      }
      getChannelIsMod(channelIndex) {
        return channelIndex >= this.pitchChannelCount + this.noiseChannelCount;
      }
      initToDefault(andResetChannels = !0) {
        if (
          ((this.scale = 0),
          (this.scaleCustom = [!0, !1, !0, !0, !1, !1, !1, !0, !0, !1, !0, !0]),
          (this.key = 0),
          (this.octave = 0),
          (this.loopStart = 0),
          (this.loopLength = 4),
          (this.tempo = 120),
          (this.reverb = 0),
          (this.beatsPerBar = 8),
          (this.barCount = 16),
          (this.patternsPerChannel = 8),
          (this.rhythm = 3),
          (this.layeredInstruments = !1),
          (this.patternInstruments = !1),
          (this.title = "Untitled"),
          (document.title =
            this.title + " - " + EditorConfig.versionDisplayName),
          andResetChannels)
        ) {
          (this.pitchChannelCount = 3),
            (this.noiseChannelCount = 1),
            (this.modChannelCount = 0);
          for (
            let channelIndex = 0;
            channelIndex < this.getChannelCount();
            channelIndex++
          ) {
            const isNoiseChannel =
                channelIndex >= this.pitchChannelCount &&
                channelIndex < this.pitchChannelCount + this.noiseChannelCount,
              isModChannel =
                channelIndex >= this.pitchChannelCount + this.noiseChannelCount;
            this.channels.length <= channelIndex &&
              (this.channels[channelIndex] = new Channel());
            const channel = this.channels[channelIndex];
            channel.octave = Math.max(3 - channelIndex, 0);
            for (let pattern = 0; pattern < this.patternsPerChannel; pattern++)
              channel.patterns.length <= pattern
                ? (channel.patterns[pattern] = new Pattern())
                : channel.patterns[pattern].reset();
            channel.patterns.length = this.patternsPerChannel;
            for (
              let instrument = 0;
              instrument < Config.instrumentCountMin;
              instrument++
            )
              channel.instruments.length <= instrument &&
                (channel.instruments[instrument] = new Instrument(
                  isNoiseChannel,
                  isModChannel
                )),
                channel.instruments[instrument].setTypeAndReset(
                  isModChannel ? 10 : isNoiseChannel ? 2 : 0,
                  isNoiseChannel,
                  isModChannel
                );
            channel.instruments.length = Config.instrumentCountMin;
            for (let bar = 0; bar < this.barCount; bar++)
              channel.bars[bar] = bar < 4 ? 1 : 0;
            channel.bars.length = this.barCount;
          }
          this.channels.length = this.getChannelCount();
        }
      }
      toBase64String() {
        let bits,
          buffer = [];
        buffer.push(Song._variant),
          buffer.push(base64IntToCharCode[Song._latestUltraBoxVersion]),
          buffer.push(78);
        var encodedSongTitle = encodeURIComponent(this.title);
        buffer.push(
          base64IntToCharCode[encodedSongTitle.length >> 6],
          base64IntToCharCode[63 & encodedSongTitle.length]
        );
        for (let i = 0; i < encodedSongTitle.length; i++)
          buffer.push(encodedSongTitle.charCodeAt(i));
        if (
          (buffer.push(
            110,
            base64IntToCharCode[this.pitchChannelCount],
            base64IntToCharCode[this.noiseChannelCount],
            base64IntToCharCode[this.modChannelCount]
          ),
          buffer.push(115, base64IntToCharCode[this.scale]),
          this.scale == Config.scales.dictionary.Custom.index)
        )
          for (var i = 1; i < Config.pitchesPerOctave; i++)
            buffer.push(base64IntToCharCode[this.scaleCustom[i] ? 1 : 0]);
        buffer.push(
          107,
          base64IntToCharCode[this.key],
          base64IntToCharCode[this.octave - Config.octaveMin]
        ),
          buffer.push(
            108,
            base64IntToCharCode[this.loopStart >> 6],
            base64IntToCharCode[63 & this.loopStart]
          ),
          buffer.push(
            101,
            base64IntToCharCode[(this.loopLength - 1) >> 6],
            base64IntToCharCode[(this.loopLength - 1) & 63]
          ),
          buffer.push(
            116,
            base64IntToCharCode[this.tempo >> 6],
            base64IntToCharCode[63 & this.tempo]
          ),
          buffer.push(97, base64IntToCharCode[this.beatsPerBar - 1]),
          buffer.push(
            103,
            base64IntToCharCode[(this.barCount - 1) >> 6],
            base64IntToCharCode[(this.barCount - 1) & 63]
          ),
          buffer.push(
            106,
            base64IntToCharCode[(this.patternsPerChannel - 1) >> 6],
            base64IntToCharCode[(this.patternsPerChannel - 1) & 63]
          ),
          buffer.push(114, base64IntToCharCode[this.rhythm]),
          buffer.push(79),
          1 != this.compressionRatio ||
          1 != this.limitRatio ||
          4e3 != this.limitRise ||
          4 != this.limitDecay ||
          1 != this.limitThreshold ||
          1 != this.compressionThreshold ||
          1 != this.masterGain
            ? (buffer.push(
                base64IntToCharCode[
                  Math.round(
                    this.compressionRatio < 1
                      ? 10 * this.compressionRatio
                      : 10 + 60 * (this.compressionRatio - 1)
                  )
                ]
              ),
              buffer.push(
                base64IntToCharCode[
                  Math.round(
                    this.limitRatio < 1
                      ? 10 * this.limitRatio
                      : 9 + this.limitRatio
                  )
                ]
              ),
              buffer.push(base64IntToCharCode[this.limitDecay]),
              buffer.push(
                base64IntToCharCode[Math.round((this.limitRise - 2e3) / 250)]
              ),
              buffer.push(
                base64IntToCharCode[Math.round(20 * this.compressionThreshold)]
              ),
              buffer.push(
                base64IntToCharCode[Math.round(20 * this.limitThreshold)]
              ),
              buffer.push(
                base64IntToCharCode[Math.round(50 * this.masterGain) >> 6],
                base64IntToCharCode[63 & Math.round(50 * this.masterGain)]
              ))
            : buffer.push(base64IntToCharCode[63]),
          buffer.push(85);
        for (let channel = 0; channel < this.getChannelCount(); channel++) {
          var encodedChannelName = encodeURIComponent(
            this.channels[channel].name
          );
          buffer.push(
            base64IntToCharCode[encodedChannelName.length >> 6],
            base64IntToCharCode[63 & encodedChannelName.length]
          );
          for (let i = 0; i < encodedChannelName.length; i++)
            buffer.push(encodedChannelName.charCodeAt(i));
        }
        if (
          (buffer.push(
            105,
            base64IntToCharCode[
              (this.layeredInstruments << 1) | this.patternInstruments
            ]
          ),
          this.layeredInstruments || this.patternInstruments)
        )
          for (
            let channelIndex = 0;
            channelIndex < this.getChannelCount();
            channelIndex++
          )
            buffer.push(
              base64IntToCharCode[
                this.channels[channelIndex].instruments.length -
                  Config.instrumentCountMin
              ]
            );
        buffer.push(111);
        for (
          let channelIndex = 0;
          channelIndex < this.pitchChannelCount;
          channelIndex++
        )
          buffer.push(base64IntToCharCode[this.channels[channelIndex].octave]);
        for (
          let channelIndex = 0;
          channelIndex < this.getChannelCount();
          channelIndex++
        )
          for (
            let i = 0;
            i < this.channels[channelIndex].instruments.length;
            i++
          ) {
            const instrument = this.channels[channelIndex].instruments[i];
            if (
              (buffer.push(84, base64IntToCharCode[instrument.type]),
              buffer.push(
                118,
                base64IntToCharCode[
                  (instrument.volume + Config.volumeRange / 2) >> 6
                ],
                base64IntToCharCode[
                  (instrument.volume + Config.volumeRange / 2) & 63
                ]
              ),
              buffer.push(
                117,
                base64IntToCharCode[instrument.preset >> 6],
                base64IntToCharCode[63 & instrument.preset]
              ),
              buffer.push(102),
              buffer.push(base64IntToCharCode[+instrument.eqFilterType]),
              instrument.eqFilterType)
            )
              buffer.push(base64IntToCharCode[instrument.eqFilterSimpleCut]),
                buffer.push(base64IntToCharCode[instrument.eqFilterSimplePeak]);
            else {
              if (null == instrument.eqFilter)
                buffer.push(base64IntToCharCode[0]),
                  console.log(
                    "Null EQ filter settings detected in toBase64String for channelIndex " +
                      channelIndex +
                      ", instrumentIndex " +
                      i
                  );
              else {
                buffer.push(
                  base64IntToCharCode[instrument.eqFilter.controlPointCount]
                );
                for (
                  let j = 0;
                  j < instrument.eqFilter.controlPointCount;
                  j++
                ) {
                  const point = instrument.eqFilter.controlPoints[j];
                  buffer.push(
                    base64IntToCharCode[point.type],
                    base64IntToCharCode[Math.round(point.freq)],
                    base64IntToCharCode[Math.round(point.gain)]
                  );
                }
              }
              let usingSubFilterBitfield = 0;
              for (let j = 0; j < Config.filterMorphCount - 1; j++)
                usingSubFilterBitfield |=
                  +(null != instrument.eqSubFilters[j + 1]) << j;
              buffer.push(
                base64IntToCharCode[usingSubFilterBitfield >> 6],
                base64IntToCharCode[63 & usingSubFilterBitfield]
              );
              for (let j = 0; j < Config.filterMorphCount - 1; j++)
                if (usingSubFilterBitfield & (1 << j)) {
                  buffer.push(
                    base64IntToCharCode[
                      instrument.eqSubFilters[j + 1].controlPointCount
                    ]
                  );
                  for (
                    let k = 0;
                    k < instrument.eqSubFilters[j + 1].controlPointCount;
                    k++
                  ) {
                    const point =
                      instrument.eqSubFilters[j + 1].controlPoints[k];
                    buffer.push(
                      base64IntToCharCode[point.type],
                      base64IntToCharCode[Math.round(point.freq)],
                      base64IntToCharCode[Math.round(point.gain)]
                    );
                  }
                }
            }
            if (
              (buffer.push(
                113,
                base64IntToCharCode[instrument.effects >> 6],
                base64IntToCharCode[63 & instrument.effects]
              ),
              effectsIncludeNoteFilter(instrument.effects))
            )
              if (
                (buffer.push(base64IntToCharCode[+instrument.noteFilterType]),
                instrument.noteFilterType)
              )
                buffer.push(
                  base64IntToCharCode[instrument.noteFilterSimpleCut]
                ),
                  buffer.push(
                    base64IntToCharCode[instrument.noteFilterSimplePeak]
                  );
              else {
                if (null == instrument.noteFilter)
                  buffer.push(base64IntToCharCode[0]),
                    console.log(
                      "Null note filter settings detected in toBase64String for channelIndex " +
                        channelIndex +
                        ", instrumentIndex " +
                        i
                    );
                else {
                  buffer.push(
                    base64IntToCharCode[instrument.noteFilter.controlPointCount]
                  );
                  for (
                    let j = 0;
                    j < instrument.noteFilter.controlPointCount;
                    j++
                  ) {
                    const point = instrument.noteFilter.controlPoints[j];
                    buffer.push(
                      base64IntToCharCode[point.type],
                      base64IntToCharCode[Math.round(point.freq)],
                      base64IntToCharCode[Math.round(point.gain)]
                    );
                  }
                }
                let usingSubFilterBitfield = 0;
                for (let j = 0; j < Config.filterMorphCount - 1; j++)
                  usingSubFilterBitfield |=
                    +(null != instrument.noteSubFilters[j + 1]) << j;
                buffer.push(
                  base64IntToCharCode[usingSubFilterBitfield >> 6],
                  base64IntToCharCode[63 & usingSubFilterBitfield]
                );
                for (let j = 0; j < Config.filterMorphCount - 1; j++)
                  if (usingSubFilterBitfield & (1 << j)) {
                    buffer.push(
                      base64IntToCharCode[
                        instrument.noteSubFilters[j + 1].controlPointCount
                      ]
                    );
                    for (
                      let k = 0;
                      k < instrument.noteSubFilters[j + 1].controlPointCount;
                      k++
                    ) {
                      const point =
                        instrument.noteSubFilters[j + 1].controlPoints[k];
                      buffer.push(
                        base64IntToCharCode[point.type],
                        base64IntToCharCode[Math.round(point.freq)],
                        base64IntToCharCode[Math.round(point.gain)]
                      );
                    }
                  }
              }
            if (
              (effectsIncludeTransition(instrument.effects) &&
                buffer.push(base64IntToCharCode[instrument.transition]),
              effectsIncludeChord(instrument.effects) &&
                (buffer.push(base64IntToCharCode[instrument.chord]),
                instrument.chord == Config.chords.dictionary.arpeggio.index &&
                  (buffer.push(base64IntToCharCode[instrument.arpeggioSpeed]),
                  buffer.push(
                    base64IntToCharCode[+instrument.fastTwoNoteArp]
                  ))),
              effectsIncludePitchShift(instrument.effects) &&
                buffer.push(base64IntToCharCode[instrument.pitchShift]),
              effectsIncludeDetune(instrument.effects) &&
                buffer.push(
                  base64IntToCharCode[
                    (instrument.detune - Config.detuneMin) >> 6
                  ],
                  base64IntToCharCode[
                    (instrument.detune - Config.detuneMin) & 63
                  ]
                ),
              effectsIncludeVibrato(instrument.effects) &&
                (buffer.push(base64IntToCharCode[instrument.vibrato]),
                instrument.vibrato == Config.vibratos.length &&
                  (buffer.push(
                    base64IntToCharCode[
                      Math.round(25 * instrument.vibratoDepth)
                    ]
                  ),
                  buffer.push(base64IntToCharCode[instrument.vibratoSpeed]),
                  buffer.push(
                    base64IntToCharCode[Math.round(instrument.vibratoDelay)]
                  ),
                  buffer.push(base64IntToCharCode[instrument.vibratoType]))),
              effectsIncludeDistortion(instrument.effects) &&
                (buffer.push(base64IntToCharCode[instrument.distortion]),
                buffer.push(base64IntToCharCode[+instrument.aliases])),
              effectsIncludeBitcrusher(instrument.effects) &&
                buffer.push(
                  base64IntToCharCode[instrument.bitcrusherFreq],
                  base64IntToCharCode[instrument.bitcrusherQuantization]
                ),
              effectsIncludePanning(instrument.effects) &&
                (buffer.push(
                  base64IntToCharCode[instrument.pan >> 6],
                  base64IntToCharCode[63 & instrument.pan]
                ),
                buffer.push(base64IntToCharCode[instrument.panDelay])),
              effectsIncludeChorus(instrument.effects) &&
                buffer.push(base64IntToCharCode[instrument.chorus]),
              effectsIncludeEcho(instrument.effects) &&
                buffer.push(
                  base64IntToCharCode[instrument.echoSustain],
                  base64IntToCharCode[instrument.echoDelay]
                ),
              effectsIncludeReverb(instrument.effects) &&
                buffer.push(base64IntToCharCode[instrument.reverb]),
              4 != instrument.type &&
                (buffer.push(
                  100,
                  base64IntToCharCode[instrument.fadeIn],
                  base64IntToCharCode[instrument.fadeOut]
                ),
                buffer.push(
                  base64IntToCharCode[+instrument.clicklessTransition]
                )),
              5 == instrument.type || 7 == instrument.type)
            ) {
              buffer.push(72);
              const harmonicsBits = new BitFieldWriter();
              for (let i = 0; i < Config.harmonicsControlPoints; i++)
                harmonicsBits.write(
                  Config.harmonicsControlPointBits,
                  instrument.harmonicsWave.harmonics[i]
                );
              harmonicsBits.encodeBase64(buffer);
            }
            if (0 == instrument.type) {
              instrument.chipWave > 186
                ? (buffer.push(
                    119,
                    base64IntToCharCode[instrument.chipWave - 186]
                  ),
                  buffer.push(base64IntToCharCode[3]))
                : instrument.chipWave > 124
                  ? (buffer.push(
                      119,
                      base64IntToCharCode[instrument.chipWave - 124]
                    ),
                    buffer.push(base64IntToCharCode[2]))
                  : instrument.chipWave > 62
                    ? (buffer.push(
                        119,
                        base64IntToCharCode[instrument.chipWave - 62]
                      ),
                      buffer.push(base64IntToCharCode[1]))
                    : (buffer.push(
                        119,
                        base64IntToCharCode[instrument.chipWave]
                      ),
                      buffer.push(base64IntToCharCode[0])),
                buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  ),
                buffer.push(121);
              const encodedLoopMode =
                (clamp(0, 32, instrument.chipWaveLoopMode) << 1) |
                (instrument.isUsingAdvancedLoopControls ? 1 : 0);
              buffer.push(base64IntToCharCode[encodedLoopMode]);
              const encodedReleaseMode =
                (clamp(0, 32, 0) << 1) |
                (instrument.chipWavePlayBackwards ? 1 : 0);
              buffer.push(base64IntToCharCode[encodedReleaseMode]),
                encode32BitNumber(buffer, instrument.chipWaveLoopStart),
                encode32BitNumber(buffer, instrument.chipWaveLoopEnd),
                encode32BitNumber(buffer, instrument.chipWaveStartOffset);
            } else if (1 == instrument.type || 11 == instrument.type) {
              if (1 == instrument.type)
                buffer.push(65, base64IntToCharCode[instrument.algorithm]),
                  buffer.push(70, base64IntToCharCode[instrument.feedbackType]);
              else {
                if (
                  (buffer.push(
                    65,
                    base64IntToCharCode[instrument.algorithm6Op]
                  ),
                  0 == instrument.algorithm6Op)
                ) {
                  buffer.push(
                    67,
                    base64IntToCharCode[instrument.customAlgorithm.carrierCount]
                  ),
                    buffer.push(113);
                  for (
                    let o = 0;
                    o < instrument.customAlgorithm.modulatedBy.length;
                    o++
                  ) {
                    for (
                      let j = 0;
                      j < instrument.customAlgorithm.modulatedBy[o].length;
                      j++
                    )
                      buffer.push(
                        base64IntToCharCode[
                          instrument.customAlgorithm.modulatedBy[o][j]
                        ]
                      );
                    buffer.push(82);
                  }
                  buffer.push(113);
                }
                if (
                  (buffer.push(
                    70,
                    base64IntToCharCode[instrument.feedbackType6Op]
                  ),
                  0 == instrument.feedbackType6Op)
                ) {
                  buffer.push(113);
                  for (
                    let o = 0;
                    o < instrument.customFeedbackType.indices.length;
                    o++
                  ) {
                    for (
                      let j = 0;
                      j < instrument.customFeedbackType.indices[o].length;
                      j++
                    )
                      buffer.push(
                        base64IntToCharCode[
                          instrument.customFeedbackType.indices[o][j]
                        ]
                      );
                    buffer.push(82);
                  }
                  buffer.push(113);
                }
              }
              buffer.push(
                66,
                base64IntToCharCode[instrument.feedbackAmplitude]
              ),
                buffer.push(81);
              for (
                let o = 0;
                o < (11 == instrument.type ? 6 : Config.operatorCount);
                o++
              )
                buffer.push(
                  base64IntToCharCode[instrument.operators[o].frequency]
                );
              buffer.push(80);
              for (
                let o = 0;
                o < (11 == instrument.type ? 6 : Config.operatorCount);
                o++
              )
                buffer.push(
                  base64IntToCharCode[instrument.operators[o].amplitude]
                );
              buffer.push(82);
              for (
                let o = 0;
                o < (11 == instrument.type ? 6 : Config.operatorCount);
                o++
              )
                buffer.push(
                  base64IntToCharCode[instrument.operators[o].waveform]
                ),
                  2 == instrument.operators[o].waveform &&
                    buffer.push(
                      base64IntToCharCode[instrument.operators[o].pulseWidth]
                    );
            } else if (9 == instrument.type) {
              instrument.chipWave > 186
                ? (buffer.push(
                    119,
                    base64IntToCharCode[instrument.chipWave - 186]
                  ),
                  buffer.push(base64IntToCharCode[3]))
                : instrument.chipWave > 124
                  ? (buffer.push(
                      119,
                      base64IntToCharCode[instrument.chipWave - 124]
                    ),
                    buffer.push(base64IntToCharCode[2]))
                  : instrument.chipWave > 62
                    ? (buffer.push(
                        119,
                        base64IntToCharCode[instrument.chipWave - 62]
                      ),
                      buffer.push(base64IntToCharCode[1]))
                    : (buffer.push(
                        119,
                        base64IntToCharCode[instrument.chipWave]
                      ),
                      buffer.push(base64IntToCharCode[0])),
                buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  ),
                buffer.push(77);
              for (let j = 0; j < 64; j++)
                buffer.push(
                  base64IntToCharCode[instrument.customChipWave[j] + 24]
                );
            } else if (2 == instrument.type)
              buffer.push(119, base64IntToCharCode[instrument.chipNoise]),
                buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  );
            else if (3 == instrument.type) {
              buffer.push(83);
              const spectrumBits = new BitFieldWriter();
              for (let i = 0; i < Config.spectrumControlPoints; i++)
                spectrumBits.write(
                  Config.spectrumControlPointBits,
                  instrument.spectrumWave.spectrum[i]
                );
              spectrumBits.encodeBase64(buffer),
                buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  );
            } else if (4 == instrument.type) {
              buffer.push(122);
              for (let j = 0; j < Config.drumCount; j++)
                buffer.push(
                  base64IntToCharCode[instrument.drumsetEnvelopes[j]]
                );
              buffer.push(83);
              const spectrumBits = new BitFieldWriter();
              for (let j = 0; j < Config.drumCount; j++)
                for (let i = 0; i < Config.spectrumControlPoints; i++)
                  spectrumBits.write(
                    Config.spectrumControlPointBits,
                    instrument.drumsetSpectrumWaves[j].spectrum[i]
                  );
              spectrumBits.encodeBase64(buffer);
            } else if (5 == instrument.type)
              buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  );
            else if (6 == instrument.type)
              buffer.push(87, base64IntToCharCode[instrument.pulseWidth]),
                buffer.push(
                  base64IntToCharCode[instrument.decimalOffset >> 6],
                  base64IntToCharCode[63 & instrument.decimalOffset]
                ),
                buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  );
            else if (8 == instrument.type)
              buffer.push(
                120,
                base64IntToCharCode[instrument.supersawDynamism],
                base64IntToCharCode[instrument.supersawSpread],
                base64IntToCharCode[instrument.supersawShape]
              ),
                buffer.push(87, base64IntToCharCode[instrument.pulseWidth]),
                buffer.push(
                  base64IntToCharCode[instrument.decimalOffset >> 6],
                  base64IntToCharCode[63 & instrument.decimalOffset]
                );
            else if (7 == instrument.type) {
              if (Config.stringSustainRange > 32)
                throw new Error(
                  "Not enough bits to represent sustain value and type in same base64 character."
                );
              buffer.push(104, base64IntToCharCode[instrument.unison]),
                instrument.unison == Config.unisons.length &&
                  encodeUnisonSettings(
                    buffer,
                    instrument.unisonVoices,
                    instrument.unisonSpread,
                    instrument.unisonOffset,
                    instrument.unisonExpression,
                    instrument.unisonSign
                  ),
                buffer.push(
                  73,
                  base64IntToCharCode[
                    instrument.stringSustain |
                      (instrument.stringSustainType << 5)
                  ]
                );
            } else if (10 != instrument.type)
              throw new Error("Unknown instrument type.");
            buffer.push(69, base64IntToCharCode[instrument.envelopeCount]),
              buffer.push(base64IntToCharCode[instrument.envelopeSpeed]),
              buffer.push(base64IntToCharCode[+instrument.discreteEnvelope]);
            for (
              let envelopeIndex = 0;
              envelopeIndex < instrument.envelopeCount;
              envelopeIndex++
            )
              buffer.push(
                base64IntToCharCode[instrument.envelopes[envelopeIndex].target]
              ),
                Config.instrumentAutomationTargets[
                  instrument.envelopes[envelopeIndex].target
                ].maxCount > 1 &&
                  buffer.push(
                    base64IntToCharCode[
                      instrument.envelopes[envelopeIndex].index
                    ]
                  ),
                buffer.push(
                  base64IntToCharCode[
                    instrument.envelopes[envelopeIndex].envelope
                  ]
                );
          }
        buffer.push(98), (bits = new BitFieldWriter());
        let neededBits = 0;
        for (; 1 << neededBits < this.patternsPerChannel + 1; ) neededBits++;
        for (
          let channelIndex = 0;
          channelIndex < this.getChannelCount();
          channelIndex++
        )
          for (let i = 0; i < this.barCount; i++)
            bits.write(neededBits, this.channels[channelIndex].bars[i]);
        bits.encodeBase64(buffer),
          buffer.push(112),
          (bits = new BitFieldWriter());
        const shapeBits = new BitFieldWriter(),
          bitsPerNoteSize = Song.getNeededBits(Config.noteSizeMax);
        for (
          let channelIndex = 0;
          channelIndex < this.getChannelCount();
          channelIndex++
        ) {
          const channel = this.channels[channelIndex],
            maxInstrumentsPerPattern =
              this.getMaxInstrumentsPerPattern(channelIndex),
            isNoiseChannel = this.getChannelIsNoise(channelIndex),
            isModChannel = this.getChannelIsMod(channelIndex),
            neededInstrumentCountBits = Song.getNeededBits(
              maxInstrumentsPerPattern - Config.instrumentCountMin
            ),
            neededInstrumentIndexBits = Song.getNeededBits(
              channel.instruments.length - 1
            );
          if (isModChannel) {
            const neededModInstrumentIndexBits = Song.getNeededBits(
              this.getMaxInstrumentsPerChannel() + 2
            );
            for (
              let instrumentIndex = 0;
              instrumentIndex < channel.instruments.length;
              instrumentIndex++
            ) {
              let instrument =
                this.channels[channelIndex].instruments[instrumentIndex];
              for (let mod = 0; mod < Config.modCount; mod++) {
                const modChannel = instrument.modChannels[mod],
                  modInstrument = instrument.modInstruments[mod],
                  modSetting = instrument.modulators[mod],
                  modFilter = instrument.modFilterTypes[mod];
                let status = Config.modulators[modSetting].forSong ? 2 : 0;
                modSetting == Config.modulators.dictionary.none.index &&
                  (status = 3),
                  bits.write(2, status),
                  (0 != status && 1 != status) ||
                    (bits.write(8, modChannel),
                    bits.write(neededModInstrumentIndexBits, modInstrument)),
                  3 != status && bits.write(6, modSetting),
                  ("eq filter" !=
                    Config.modulators[instrument.modulators[mod]].name &&
                    "note filter" !=
                      Config.modulators[instrument.modulators[mod]].name) ||
                    bits.write(6, modFilter);
              }
            }
          }
          const octaveOffset =
            isNoiseChannel || isModChannel
              ? 0
              : channel.octave * Config.pitchesPerOctave;
          let lastPitch = isNoiseChannel ? 4 : octaveOffset;
          const recentPitches = isModChannel
              ? [0, 1, 2, 3, 4, 5]
              : isNoiseChannel
                ? [4, 6, 7, 2, 3, 8, 0, 10]
                : [0, 7, 12, 19, 24, -5, -12],
            recentShapes = [];
          for (let i = 0; i < recentPitches.length; i++)
            recentPitches[i] += octaveOffset;
          for (const pattern of channel.patterns) {
            if (this.patternInstruments) {
              const instrumentCount = validateRange(
                Config.instrumentCountMin,
                maxInstrumentsPerPattern,
                pattern.instruments.length
              );
              bits.write(
                neededInstrumentCountBits,
                instrumentCount - Config.instrumentCountMin
              );
              for (let i = 0; i < instrumentCount; i++)
                bits.write(neededInstrumentIndexBits, pattern.instruments[i]);
            }
            if (pattern.notes.length > 0) {
              bits.write(1, 1);
              let curPart = 0;
              for (const note of pattern.notes) {
                note.start < curPart &&
                  isModChannel &&
                  (bits.write(2, 0),
                  bits.write(1, 1),
                  bits.writePartDuration(curPart - note.start)),
                  note.start > curPart &&
                    (bits.write(2, 0),
                    isModChannel && bits.write(1, 0),
                    bits.writePartDuration(note.start - curPart)),
                  shapeBits.clear(),
                  1 == note.pitches.length
                    ? shapeBits.write(1, 0)
                    : (shapeBits.write(1, 1),
                      shapeBits.write(3, note.pitches.length - 2)),
                  shapeBits.writePinCount(note.pins.length - 1),
                  isModChannel
                    ? shapeBits.write(9, note.pins[0].size)
                    : shapeBits.write(bitsPerNoteSize, note.pins[0].size);
                let shapePart = 0,
                  startPitch = note.pitches[0],
                  currentPitch = startPitch;
                const pitchBends = [];
                for (let i = 1; i < note.pins.length; i++) {
                  const pin = note.pins[i],
                    nextPitch = startPitch + pin.interval;
                  currentPitch != nextPitch
                    ? (shapeBits.write(1, 1),
                      pitchBends.push(nextPitch),
                      (currentPitch = nextPitch))
                    : shapeBits.write(1, 0),
                    shapeBits.writePartDuration(pin.time - shapePart),
                    (shapePart = pin.time),
                    isModChannel
                      ? shapeBits.write(9, pin.size)
                      : shapeBits.write(bitsPerNoteSize, pin.size);
                }
                const shapeString = String.fromCharCode.apply(
                    null,
                    shapeBits.encodeBase64([])
                  ),
                  shapeIndex = recentShapes.indexOf(shapeString);
                -1 == shapeIndex
                  ? (bits.write(2, 1), bits.concat(shapeBits))
                  : (bits.write(1, 1),
                    bits.writeLongTail(0, 0, shapeIndex),
                    recentShapes.splice(shapeIndex, 1)),
                  recentShapes.unshift(shapeString),
                  recentShapes.length > 10 && recentShapes.pop();
                const allPitches = note.pitches.concat(pitchBends);
                for (let i = 0; i < allPitches.length; i++) {
                  const pitch = allPitches[i],
                    pitchIndex = recentPitches.indexOf(pitch);
                  if (-1 == pitchIndex) {
                    let interval = 0,
                      pitchIter = lastPitch;
                    if (pitchIter < pitch)
                      for (; pitchIter != pitch; )
                        pitchIter++,
                          -1 == recentPitches.indexOf(pitchIter) && interval++;
                    else
                      for (; pitchIter != pitch; )
                        pitchIter--,
                          -1 == recentPitches.indexOf(pitchIter) && interval--;
                    bits.write(1, 0), bits.writePitchInterval(interval);
                  } else
                    bits.write(1, 1),
                      bits.write(4, pitchIndex),
                      recentPitches.splice(pitchIndex, 1);
                  recentPitches.unshift(pitch),
                    recentPitches.length > 16 && recentPitches.pop(),
                    (lastPitch =
                      i == note.pitches.length - 1 ? note.pitches[0] : pitch);
                }
                0 == note.start &&
                  bits.write(1, note.continuesLastPattern ? 1 : 0),
                  (curPart = note.end);
              }
              curPart <
                this.beatsPerBar * Config.partsPerBeat + +isModChannel &&
                (bits.write(2, 0),
                isModChannel && bits.write(1, 0),
                bits.writePartDuration(
                  this.beatsPerBar * Config.partsPerBeat +
                    +isModChannel -
                    curPart
                ));
            } else bits.write(1, 0);
          }
        }
        let stringLength = bits.lengthBase64(),
          digits = [];
        for (; stringLength > 0; )
          digits.unshift(base64IntToCharCode[63 & stringLength]),
            (stringLength >>= 6);
        buffer.push(base64IntToCharCode[digits.length]),
          Array.prototype.push.apply(buffer, digits),
          bits.encodeBase64(buffer);
        const maxApplyArgs = 64e3;
        let customSamplesStr = "";
        if (
          (null != EditorConfig.customSamples &&
            EditorConfig.customSamples.length > 0 &&
            (customSamplesStr = "|" + EditorConfig.customSamples.join("|")),
          buffer.length < 64e3)
        )
          return String.fromCharCode.apply(null, buffer) + customSamplesStr;
        {
          let result = "";
          for (let i = 0; i < buffer.length; i += 64e3)
            result += String.fromCharCode.apply(
              null,
              buffer.slice(i, i + 64e3)
            );
          return result + customSamplesStr;
        }
      }
      static _envelopeFromLegacyIndex(legacyIndex) {
        return (
          0 == legacyIndex
            ? (legacyIndex = 1)
            : 1 == legacyIndex && (legacyIndex = 0),
          Config.envelopes[clamp(0, Config.envelopes.length, legacyIndex)]
        );
      }
      fromBase64String(compressed, jsonFormat = "auto") {
        if (null == compressed || "" == compressed)
          return Song._clearSamples(), void this.initToDefault(!0);
        let charIndex = 0;
        for (; compressed.charCodeAt(charIndex) <= 32; ) charIndex++;
        if (
          (35 == compressed.charCodeAt(charIndex) && charIndex++,
          123 == compressed.charCodeAt(charIndex))
        )
          return void this.fromJsonObject(
            JSON.parse(
              0 == charIndex ? compressed : compressed.substring(charIndex)
            ),
            jsonFormat
          );
        const variantTest = compressed.charCodeAt(charIndex);
        let fromBeepBox, fromJummBox, fromGoldBox, fromUltraBox;
        106 == variantTest
          ? ((fromBeepBox = !1),
            (fromJummBox = !0),
            (fromGoldBox = !1),
            (fromUltraBox = !1),
            charIndex++)
          : 103 == variantTest
            ? ((fromBeepBox = !1),
              (fromJummBox = !1),
              (fromGoldBox = !0),
              (fromUltraBox = !1),
              charIndex++)
            : 117 == variantTest
              ? ((fromBeepBox = !1),
                (fromJummBox = !1),
                (fromGoldBox = !1),
                (fromUltraBox = !0),
                charIndex++)
              : 100 == variantTest
                ? ((fromBeepBox = !1),
                  (fromJummBox = !0),
                  (fromGoldBox = !1),
                  (fromUltraBox = !1),
                  charIndex++)
                : ((fromBeepBox = !0),
                  (fromJummBox = !1),
                  (fromGoldBox = !1),
                  (fromUltraBox = !1));
        const version = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
        if (
          fromBeepBox &&
          (-1 == version ||
            version > Song._latestBeepboxVersion ||
            version < Song._oldestBeepboxVersion)
        )
          return;
        if (
          fromJummBox &&
          (-1 == version ||
            version > Song._latestJummBoxVersion ||
            version < Song._oldestJummBoxVersion)
        )
          return;
        if (
          fromGoldBox &&
          (-1 == version ||
            version > Song._latestGoldBoxVersion ||
            version < Song._oldestGoldBoxVersion)
        )
          return;
        if (
          fromUltraBox &&
          (-1 == version ||
            version > Song._latestUltraBoxVersion ||
            version < Song._oldestUltraBoxVersion)
        )
          return;
        const beforeTwo = version < 2,
          beforeThree = version < 3,
          beforeFour = version < 4,
          beforeFive = version < 5,
          beforeSix = version < 6,
          beforeSeven = version < 7,
          beforeEight = version < 8,
          beforeNine = version < 9;
        this.initToDefault(
          (fromBeepBox && beforeNine) ||
            (fromJummBox && beforeFive) ||
            (beforeFour && fromGoldBox)
        );
        const forceSimpleFilter =
          (fromBeepBox && beforeNine) || (fromJummBox && beforeFive);
        let willLoadLegacySamplesForOldSongs = !1;
        if (fromUltraBox || fromGoldBox) {
          var compressed_array = (compressed = compressed.replaceAll(
            "%7C",
            "|"
          )).split("|");
          if (
            ((compressed = compressed_array.shift()),
            null == EditorConfig.customSamples ||
              EditorConfig.customSamples.join(", ") !=
                compressed_array.join(", "))
          ) {
            Song._restoreChipWaveListToDefault();
            let willLoadLegacySamples = !1,
              willLoadNintariboxSamples = !1,
              willLoadMarioPaintboxSamples = !1;
            const customSampleUrls = [],
              customSamplePresets = [];
            (sampleLoadingState.statusTable = {}),
              (sampleLoadingState.urlTable = {}),
              (sampleLoadingState.totalSamples = 0),
              (sampleLoadingState.samplesLoaded = 0),
              sampleLoadEvents.dispatchEvent(
                new SampleLoadedEvent(
                  sampleLoadingState.totalSamples,
                  sampleLoadingState.samplesLoaded
                )
              );
            for (const url of compressed_array)
              if ("legacysamples" === url.toLowerCase())
                willLoadLegacySamples ||
                  ((willLoadLegacySamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(0));
              else if ("nintariboxsamples" === url.toLowerCase())
                willLoadNintariboxSamples ||
                  ((willLoadNintariboxSamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(1));
              else if ("mariopaintboxsamples" === url.toLowerCase())
                willLoadMarioPaintboxSamples ||
                  ((willLoadMarioPaintboxSamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(2));
              else {
                const parseOldSyntax = beforeThree,
                  ok = Song._parseAndConfigureCustomSample(
                    url,
                    customSampleUrls,
                    customSamplePresets,
                    sampleLoadingState,
                    parseOldSyntax
                  );
                if (!ok) continue;
              }
            if (
              (customSampleUrls.length > 0 &&
                (EditorConfig.customSamples = customSampleUrls),
              customSamplePresets.length > 0)
            ) {
              const customSamplePresetsMap = toNameMap(customSamplePresets);
              EditorConfig.presetCategories[
                EditorConfig.presetCategories.length
              ] = {
                name: "Custom Sample Presets",
                presets: customSamplePresetsMap,
                index: EditorConfig.presetCategories.length,
              };
            }
          }
        }
        if (beforeThree && fromBeepBox) {
          for (const channel of this.channels)
            (channel.instruments[0].transition =
              Config.transitions.dictionary.interrupt.index),
              (channel.instruments[0].effects |= 1024);
          this.channels[3].instruments[0].chipNoise = 0;
        }
        let legacySettingsCache = null;
        if (
          (fromBeepBox && beforeNine) ||
          (fromJummBox && beforeFive) ||
          (beforeFour && fromGoldBox)
        ) {
          legacySettingsCache = [];
          for (
            let i = legacySettingsCache.length;
            i < this.getChannelCount();
            i++
          ) {
            legacySettingsCache[i] = [];
            for (let j = 0; j < Config.instrumentCountMin; j++)
              legacySettingsCache[i][j] = {};
          }
        }
        let legacyGlobalReverb = 0,
          instrumentChannelIterator = 0,
          instrumentIndexIterator = -1,
          command,
          useSlowerArpSpeed = !1,
          useFastTwoNoteArp = !1;
        for (; charIndex < compressed.length; )
          switch ((command = compressed.charCodeAt(charIndex++))) {
            case 78:
              var songNameLength =
                (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) +
                base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
              (this.title = decodeURIComponent(
                compressed.substring(charIndex, charIndex + songNameLength)
              )),
                (document.title =
                  this.title + " - " + EditorConfig.versionDisplayName),
                (charIndex += songNameLength);
              break;
            case 110:
              (this.pitchChannelCount =
                base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                (this.noiseChannelCount =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                (this.modChannelCount =
                  fromBeepBox || (fromJummBox && beforeTwo)
                    ? 0
                    : base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                (this.pitchChannelCount = validateRange(
                  Config.pitchChannelCountMin,
                  Config.pitchChannelCountMax,
                  this.pitchChannelCount
                )),
                (this.noiseChannelCount = validateRange(
                  Config.noiseChannelCountMin,
                  Config.noiseChannelCountMax,
                  this.noiseChannelCount
                )),
                (this.modChannelCount = validateRange(
                  Config.modChannelCountMin,
                  Config.modChannelCountMax,
                  this.modChannelCount
                ));
              for (
                let channelIndex = this.channels.length;
                channelIndex < this.getChannelCount();
                channelIndex++
              )
                this.channels[channelIndex] = new Channel();
              if (
                ((this.channels.length = this.getChannelCount()),
                (fromBeepBox && beforeNine) ||
                  (fromJummBox && beforeFive) ||
                  (beforeFour && fromGoldBox))
              )
                for (
                  let i = legacySettingsCache.length;
                  i < this.getChannelCount();
                  i++
                ) {
                  legacySettingsCache[i] = [];
                  for (let j = 0; j < Config.instrumentCountMin; j++)
                    legacySettingsCache[i][j] = {};
                }
              break;
            case 115:
              if (
                ((this.scale =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                this.scale == Config.scales.dictionary.Custom.index)
              )
                for (var i = 1; i < Config.pitchesPerOctave; i++)
                  this.scaleCustom[i] =
                    1 ==
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
              fromBeepBox && (this.scale = 0);
              break;
            case 107:
              if (beforeSeven && fromBeepBox)
                (this.key = clamp(
                  0,
                  Config.keys.length,
                  11 - base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (this.octave = 0);
              else if (fromBeepBox || fromJummBox)
                (this.key = clamp(
                  0,
                  Config.keys.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (this.octave = 0);
              else if (fromGoldBox || (beforeThree && fromUltraBox)) {
                const rawKeyIndex =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                  [key, octave] = convertLegacyKeyToKeyAndOctave(rawKeyIndex);
                (this.key = key), (this.octave = octave);
              } else
                (this.key = clamp(
                  0,
                  Config.keys.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (this.octave = clamp(
                    Config.octaveMin,
                    Config.octaveMax + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      Config.octaveMin
                  ));
              break;
            case 108:
              this.loopStart =
                beforeFive && fromBeepBox
                  ? base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  : (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                      6) +
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
              break;
            case 101:
              this.loopLength =
                beforeFive && fromBeepBox
                  ? base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  : (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                      6) +
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                    1;
              break;
            case 116:
              (this.tempo =
                beforeFour && fromBeepBox
                  ? [95, 120, 151, 190][
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    ]
                  : beforeSeven && fromBeepBox
                    ? [
                        88, 95, 103, 111, 120, 130, 140, 151, 163, 176, 190,
                        206, 222, 240, 259,
                      ][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]]
                    : (base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) |
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                (this.tempo = clamp(
                  Config.tempoMin,
                  Config.tempoMax + 1,
                  this.tempo
                ));
              break;
            case 109:
              beforeNine && fromBeepBox
                ? ((legacyGlobalReverb =
                    12 *
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                  (legacyGlobalReverb = clamp(
                    0,
                    Config.reverbRange,
                    legacyGlobalReverb
                  )))
                : ((fromJummBox && beforeFive) ||
                    (beforeFour && fromGoldBox)) &&
                  ((legacyGlobalReverb =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                  (legacyGlobalReverb = clamp(
                    0,
                    Config.reverbRange,
                    legacyGlobalReverb
                  )));
              break;
            case 97:
              (this.beatsPerBar =
                beforeThree && fromBeepBox
                  ? [6, 7, 8, 9, 10][
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    ]
                  : base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                    1),
                (this.beatsPerBar = Math.max(
                  Config.beatsPerBarMin,
                  Math.min(Config.beatsPerBarMax, this.beatsPerBar)
                ));
              break;
            case 103:
              {
                const barCount =
                  (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                    6) +
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                  1;
                this.barCount = validateRange(
                  Config.barCountMin,
                  Config.barCountMax,
                  barCount
                );
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                ) {
                  for (
                    let bar = this.channels[channelIndex].bars.length;
                    bar < this.barCount;
                    bar++
                  )
                    this.channels[channelIndex].bars[bar] = bar < 4 ? 1 : 0;
                  this.channels[channelIndex].bars.length = this.barCount;
                }
              }
              break;
            case 106:
              {
                let patternsPerChannel;
                (patternsPerChannel =
                  beforeEight && fromBeepBox
                    ? base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      1
                    : (base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) +
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      1),
                  (this.patternsPerChannel = validateRange(
                    1,
                    Config.barCountMax,
                    patternsPerChannel
                  ));
                const channelCount = this.getChannelCount();
                for (
                  let channelIndex = 0;
                  channelIndex < channelCount;
                  channelIndex++
                ) {
                  const patterns = this.channels[channelIndex].patterns;
                  for (
                    let pattern = patterns.length;
                    pattern < this.patternsPerChannel;
                    pattern++
                  )
                    patterns[pattern] = new Pattern();
                  patterns.length = this.patternsPerChannel;
                }
              }
              break;
            case 105:
              if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              ) {
                const instrumentsPerChannel = validateRange(
                  Config.instrumentCountMin,
                  Config.patternInstrumentCountMax,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                    Config.instrumentCountMin
                );
                (this.layeredInstruments = !1),
                  (this.patternInstruments = instrumentsPerChannel > 1);
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                ) {
                  const isNoiseChannel =
                      channelIndex >= this.pitchChannelCount &&
                      channelIndex <
                        this.pitchChannelCount + this.noiseChannelCount,
                    isModChannel =
                      channelIndex >=
                      this.pitchChannelCount + this.noiseChannelCount;
                  for (
                    let instrumentIndex =
                      this.channels[channelIndex].instruments.length;
                    instrumentIndex < instrumentsPerChannel;
                    instrumentIndex++
                  )
                    this.channels[channelIndex].instruments[instrumentIndex] =
                      new Instrument(isNoiseChannel, isModChannel);
                  if (
                    ((this.channels[channelIndex].instruments.length =
                      instrumentsPerChannel),
                    beforeSix && fromBeepBox)
                  )
                    for (
                      let instrumentIndex = 0;
                      instrumentIndex < instrumentsPerChannel;
                      instrumentIndex++
                    )
                      this.channels[channelIndex].instruments[
                        instrumentIndex
                      ].setTypeAndReset(
                        isNoiseChannel ? 2 : 0,
                        isNoiseChannel,
                        isModChannel
                      );
                  for (
                    let j = legacySettingsCache[channelIndex].length;
                    j < instrumentsPerChannel;
                    j++
                  )
                    legacySettingsCache[channelIndex][j] = {};
                }
              } else {
                const instrumentsFlagBits =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                (this.layeredInstruments = 0 != (2 & instrumentsFlagBits)),
                  (this.patternInstruments = 0 != (1 & instrumentsFlagBits));
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                ) {
                  let instrumentCount = 1;
                  (this.layeredInstruments || this.patternInstruments) &&
                    (instrumentCount = validateRange(
                      Config.instrumentCountMin,
                      this.getMaxInstrumentsPerChannel(),
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                        Config.instrumentCountMin
                    ));
                  const channel = this.channels[channelIndex],
                    isNoiseChannel = this.getChannelIsNoise(channelIndex),
                    isModChannel = this.getChannelIsMod(channelIndex);
                  for (
                    let i = channel.instruments.length;
                    i < instrumentCount;
                    i++
                  )
                    channel.instruments[i] = new Instrument(
                      isNoiseChannel,
                      isModChannel
                    );
                  channel.instruments.length = instrumentCount;
                }
              }
              break;
            case 114:
              if (fromUltraBox)
                this.rhythm =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
              else {
                let newRhythm =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                (this.rhythm = clamp(0, Config.rhythms.length, newRhythm + 2)),
                  ((fromJummBox && beforeThree) || fromBeepBox) &&
                    ((this.rhythm !=
                      Config.rhythms.dictionary["÷3 (triplets)"].index &&
                      this.rhythm !=
                        Config.rhythms.dictionary["÷6 (sextuplets)"].index) ||
                      (useSlowerArpSpeed = !0),
                    this.rhythm >=
                      Config.rhythms.dictionary["÷6 (sextuplets)"].index &&
                      (useFastTwoNoteArp = !0));
              }
              break;
            case 111:
              if (beforeThree && fromBeepBox) {
                const channelIndex =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                (this.channels[channelIndex].octave = clamp(
                  0,
                  Config.pitchOctaves,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1
                )),
                  channelIndex >= this.pitchChannelCount &&
                    (this.channels[channelIndex].octave = 0);
              } else if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              )
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                )
                  (this.channels[channelIndex].octave = clamp(
                    0,
                    Config.pitchOctaves,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1
                  )),
                    channelIndex >= this.pitchChannelCount &&
                      (this.channels[channelIndex].octave = 0);
              else {
                for (
                  let channelIndex = 0;
                  channelIndex < this.pitchChannelCount;
                  channelIndex++
                )
                  this.channels[channelIndex].octave = clamp(
                    0,
                    Config.pitchOctaves,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
                for (
                  let channelIndex = this.pitchChannelCount;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                )
                  this.channels[channelIndex].octave = 0;
              }
              break;
            case 84:
              {
                instrumentIndexIterator++,
                  instrumentIndexIterator >=
                    this.channels[instrumentChannelIterator].instruments
                      .length &&
                    (instrumentChannelIterator++,
                    (instrumentIndexIterator = 0)),
                  validateRange(
                    0,
                    this.channels.length - 1,
                    instrumentChannelIterator
                  );
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                let instrumentType = validateRange(
                  0,
                  11,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
                (fromJummBox && beforeFive) || (beforeFour && fromGoldBox)
                  ? (7 != instrumentType && 8 != instrumentType) ||
                    (instrumentType += 2)
                  : ((fromJummBox && beforeSix) ||
                      (fromGoldBox && !beforeFour) ||
                      (fromUltraBox && beforeFive)) &&
                    ((8 != instrumentType &&
                      9 != instrumentType &&
                      10 != instrumentType) ||
                      (instrumentType += 1)),
                  instrument.setTypeAndReset(
                    instrumentType,
                    instrumentChannelIterator >= this.pitchChannelCount &&
                      instrumentChannelIterator <
                        this.pitchChannelCount + this.noiseChannelCount,
                    instrumentChannelIterator >=
                      this.pitchChannelCount + this.noiseChannelCount
                  ),
                  !(
                    (beforeSeven && fromBeepBox) ||
                    (beforeTwo && fromJummBox)
                  ) ||
                    (0 != instrumentType &&
                      9 != instrumentType &&
                      6 != instrumentType) ||
                    ((instrument.aliases = !0),
                    (instrument.distortion = 0),
                    (instrument.effects |= 8)),
                  useSlowerArpSpeed && (instrument.arpeggioSpeed = 9),
                  useFastTwoNoteArp && (instrument.fastTwoNoteArp = !0),
                  beforeSeven &&
                    fromBeepBox &&
                    instrument.chord !=
                      Config.chords.dictionary.simultaneous.index &&
                    (instrument.effects |= 2048);
              }
              break;
            case 117:
              {
                const presetValue =
                  (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                    6) |
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                (this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].preset = presetValue),
                  (fromJummBox && beforeFive) || (beforeFour && fromGoldBox)
                    ? 7 ==
                        this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].preset &&
                      ((this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ].preset = 9),
                      (this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ].type = 9))
                    : ((fromJummBox && beforeSix) ||
                        (fromUltraBox && beforeFive)) &&
                      (8 ==
                        this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].preset &&
                        ((this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].preset = 9),
                        (this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].type = 9)),
                      10 ==
                        this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].preset &&
                        ((this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].preset = 11),
                        (this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ].type = 11))),
                  fromBeepBox &&
                    presetValue ==
                      EditorConfig.nameToPresetValue("grand piano 1") &&
                    (this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ].preset = EditorConfig.nameToPresetValue("grand piano 3"));
              }
              break;
            case 119:
              if (beforeThree && fromBeepBox) {
                const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 0],
                  channelIndex =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                  instrument = this.channels[channelIndex].instruments[0];
                (instrument.chipWave = clamp(
                  0,
                  Config.chipWaves.length,
                  0 |
                    legacyWaves[
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    ]
                )),
                  instrument.convertLegacySettings(
                    legacySettingsCache[channelIndex][0],
                    forceSimpleFilter
                  );
              } else if (beforeSix && fromBeepBox) {
                const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                )
                  for (const instrument of this.channels[channelIndex]
                    .instruments)
                    channelIndex >= this.pitchChannelCount
                      ? (instrument.chipNoise = clamp(
                          0,
                          Config.chipNoises.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        ))
                      : (instrument.chipWave = clamp(
                          0,
                          Config.chipWaves.length,
                          0 |
                            legacyWaves[
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                            ]
                        ));
              } else if (beforeSeven && fromBeepBox) {
                const legacyWaves = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                instrumentChannelIterator >= this.pitchChannelCount
                  ? (this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ].chipNoise = clamp(
                      0,
                      Config.chipNoises.length,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    ))
                  : (this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ].chipWave = clamp(
                      0,
                      Config.chipWaves.length,
                      0 |
                        legacyWaves[
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        ]
                    ));
              } else if (
                2 ==
                this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].type
              )
                this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].chipNoise = clamp(
                  0,
                  Config.chipNoises.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
              else if (fromUltraBox) {
                const chipWaveReal =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                  chipWaveCounter =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].chipWave = clamp(
                  0,
                  Config.chipWaves.length,
                  3 == chipWaveCounter
                    ? chipWaveReal + 186
                    : 2 == chipWaveCounter
                      ? chipWaveReal + 124
                      : 1 == chipWaveCounter
                        ? chipWaveReal + 62
                        : chipWaveReal
                );
              } else
                this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].chipWave = clamp(
                  0,
                  Config.chipWaves.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
              break;
            case 102:
              if (
                (beforeNine && fromBeepBox) ||
                (beforeFive && fromJummBox) ||
                (beforeFour && fromGoldBox)
              )
                if (beforeSeven && fromBeepBox) {
                  const legacyToCutoff = [10, 6, 3, 0, 8, 5, 2],
                    legacyToEnvelope = [
                      "none",
                      "none",
                      "none",
                      "none",
                      "decay 1",
                      "decay 2",
                      "decay 3",
                    ];
                  if (beforeThree && fromBeepBox) {
                    const channelIndex =
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                      instrument = this.channels[channelIndex].instruments[0],
                      legacySettings = legacySettingsCache[channelIndex][0],
                      legacyFilter = [1, 3, 4, 5][
                        clamp(
                          0,
                          legacyToCutoff.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ];
                    (legacySettings.filterCutoff =
                      legacyToCutoff[legacyFilter]),
                      (legacySettings.filterResonance = 0),
                      (legacySettings.filterEnvelope =
                        Config.envelopes.dictionary[
                          legacyToEnvelope[legacyFilter]
                        ]),
                      instrument.convertLegacySettings(
                        legacySettings,
                        forceSimpleFilter
                      );
                  } else if (beforeSix && fromBeepBox)
                    for (
                      let channelIndex = 0;
                      channelIndex < this.getChannelCount();
                      channelIndex++
                    )
                      for (
                        let i = 0;
                        i < this.channels[channelIndex].instruments.length;
                        i++
                      ) {
                        const instrument =
                            this.channels[channelIndex].instruments[i],
                          legacySettings = legacySettingsCache[channelIndex][i],
                          legacyFilter = clamp(
                            0,
                            legacyToCutoff.length,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ] + 1
                          );
                        channelIndex < this.pitchChannelCount
                          ? ((legacySettings.filterCutoff =
                              legacyToCutoff[legacyFilter]),
                            (legacySettings.filterResonance = 0),
                            (legacySettings.filterEnvelope =
                              Config.envelopes.dictionary[
                                legacyToEnvelope[legacyFilter]
                              ]))
                          : ((legacySettings.filterCutoff = 10),
                            (legacySettings.filterResonance = 0),
                            (legacySettings.filterEnvelope =
                              Config.envelopes.dictionary.none)),
                          instrument.convertLegacySettings(
                            legacySettings,
                            forceSimpleFilter
                          );
                      }
                  else {
                    const legacyFilter = clamp(
                        0,
                        legacyToCutoff.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ),
                      instrument =
                        this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ],
                      legacySettings =
                        legacySettingsCache[instrumentChannelIterator][
                          instrumentIndexIterator
                        ];
                    (legacySettings.filterCutoff =
                      legacyToCutoff[legacyFilter]),
                      (legacySettings.filterResonance = 0),
                      (legacySettings.filterEnvelope =
                        Config.envelopes.dictionary[
                          legacyToEnvelope[legacyFilter]
                        ]),
                      instrument.convertLegacySettings(
                        legacySettings,
                        forceSimpleFilter
                      );
                  }
                } else {
                  const filterCutoffRange = 11,
                    instrument =
                      this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ],
                    legacySettings =
                      legacySettingsCache[instrumentChannelIterator][
                        instrumentIndexIterator
                      ];
                  (legacySettings.filterCutoff = clamp(
                    0,
                    filterCutoffRange,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                    instrument.convertLegacySettings(
                      legacySettings,
                      forceSimpleFilter
                    );
                }
              else {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                let typeCheck =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                if (fromBeepBox || 0 == typeCheck) {
                  (instrument.eqFilterType = !1),
                    (fromJummBox || fromGoldBox || fromUltraBox) &&
                      (typeCheck =
                        base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ]);
                  const originalControlPointCount = typeCheck;
                  instrument.eqFilter.controlPointCount = clamp(
                    0,
                    Config.filterMaxPoints + 1,
                    originalControlPointCount
                  );
                  for (
                    let i = instrument.eqFilter.controlPoints.length;
                    i < instrument.eqFilter.controlPointCount;
                    i++
                  )
                    instrument.eqFilter.controlPoints[i] =
                      new FilterControlPoint();
                  for (
                    let i = 0;
                    i < instrument.eqFilter.controlPointCount;
                    i++
                  ) {
                    const point = instrument.eqFilter.controlPoints[i];
                    (point.type = clamp(
                      0,
                      3,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    )),
                      (point.freq = clamp(
                        0,
                        Config.filterFreqRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      (point.gain = clamp(
                        0,
                        Config.filterGainRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ));
                  }
                  for (
                    let i = instrument.eqFilter.controlPointCount;
                    i < originalControlPointCount;
                    i++
                  )
                    charIndex += 3;
                  if (
                    ((instrument.eqSubFilters[0] = instrument.eqFilter),
                    (fromJummBox && !beforeFive) ||
                      (fromGoldBox && !beforeFour) ||
                      fromUltraBox)
                  ) {
                    let usingSubFilterBitfield =
                      (base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) |
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    for (let j = 0; j < Config.filterMorphCount - 1; j++)
                      if (usingSubFilterBitfield & (1 << j)) {
                        const originalSubfilterControlPointCount =
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ];
                        null == instrument.eqSubFilters[j + 1] &&
                          (instrument.eqSubFilters[j + 1] =
                            new FilterSettings()),
                          (instrument.eqSubFilters[j + 1].controlPointCount =
                            clamp(
                              0,
                              Config.filterMaxPoints + 1,
                              originalSubfilterControlPointCount
                            ));
                        for (
                          let i =
                            instrument.eqSubFilters[j + 1].controlPoints.length;
                          i < instrument.eqSubFilters[j + 1].controlPointCount;
                          i++
                        )
                          instrument.eqSubFilters[j + 1].controlPoints[i] =
                            new FilterControlPoint();
                        for (
                          let i = 0;
                          i < instrument.eqSubFilters[j + 1].controlPointCount;
                          i++
                        ) {
                          const point =
                            instrument.eqSubFilters[j + 1].controlPoints[i];
                          (point.type = clamp(
                            0,
                            3,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                            (point.freq = clamp(
                              0,
                              Config.filterFreqRange,
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                            )),
                            (point.gain = clamp(
                              0,
                              Config.filterGainRange,
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                            ));
                        }
                        for (
                          let i =
                            instrument.eqSubFilters[j + 1].controlPointCount;
                          i < originalSubfilterControlPointCount;
                          i++
                        )
                          charIndex += 3;
                      }
                  }
                } else
                  (instrument.eqFilterType = !0),
                    (instrument.eqFilterSimpleCut = clamp(
                      0,
                      Config.filterSimpleCutRange,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    )),
                    (instrument.eqFilterSimplePeak = clamp(
                      0,
                      Config.filterSimplePeakRange,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    ));
              }
              break;
            case 121:
              if (fromUltraBox)
                if (beforeThree) {
                  const sampleLoopInfoEncodedLength = decode32BitNumber(
                    compressed,
                    charIndex
                  );
                  charIndex += 6;
                  const sampleLoopInfoEncoded = compressed.slice(
                    charIndex,
                    charIndex + sampleLoopInfoEncodedLength
                  );
                  charIndex += sampleLoopInfoEncodedLength;
                  const sampleLoopInfo = JSON.parse(
                    atob(sampleLoopInfoEncoded)
                  );
                  for (const entry of sampleLoopInfo) {
                    const channelIndex = entry.channel,
                      instrumentIndex = entry.instrument,
                      info = entry.info,
                      instrument =
                        this.channels[channelIndex].instruments[
                          instrumentIndex
                        ];
                    (instrument.isUsingAdvancedLoopControls =
                      info.isUsingAdvancedLoopControls),
                      (instrument.chipWaveLoopStart = info.chipWaveLoopStart),
                      (instrument.chipWaveLoopEnd = info.chipWaveLoopEnd),
                      (instrument.chipWaveLoopMode = info.chipWaveLoopMode),
                      (instrument.chipWavePlayBackwards =
                        info.chipWavePlayBackwards),
                      (instrument.chipWaveStartOffset =
                        info.chipWaveStartOffset);
                  }
                } else {
                  const encodedLoopMode =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    isUsingAdvancedLoopControls = Boolean(1 & encodedLoopMode),
                    chipWaveLoopMode = encodedLoopMode >> 1,
                    encodedReleaseMode =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    chipWavePlayBackwards = Boolean(1 & encodedReleaseMode),
                    chipWaveLoopStart = decode32BitNumber(
                      compressed,
                      charIndex
                    );
                  charIndex += 6;
                  const chipWaveLoopEnd = decode32BitNumber(
                    compressed,
                    charIndex
                  );
                  charIndex += 6;
                  const chipWaveStartOffset = decode32BitNumber(
                    compressed,
                    charIndex
                  );
                  charIndex += 6;
                  const instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ];
                  (instrument.isUsingAdvancedLoopControls =
                    isUsingAdvancedLoopControls),
                    (instrument.chipWaveLoopStart = chipWaveLoopStart),
                    (instrument.chipWaveLoopEnd = chipWaveLoopEnd),
                    (instrument.chipWaveLoopMode = chipWaveLoopMode),
                    (instrument.chipWavePlayBackwards = chipWavePlayBackwards),
                    (instrument.chipWaveStartOffset = chipWaveStartOffset);
                }
              else if (fromGoldBox && !beforeFour && beforeSix)
                "legacysamples" !=
                  document.URL.substring(
                    document.URL.length - 13
                  ).toLowerCase() &&
                  (willLoadLegacySamplesForOldSongs ||
                    ((willLoadLegacySamplesForOldSongs = !0),
                    (Config.willReloadForCustomSamples = !0),
                    (EditorConfig.customSamples = ["legacySamples"]),
                    loadBuiltInSamples(0))),
                  (this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ].chipWave = clamp(
                    0,
                    Config.chipWaves.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      125
                  ));
              else if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              ) {
                const filterResonanceRange = 8,
                  instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ],
                  legacySettings =
                    legacySettingsCache[instrumentChannelIterator][
                      instrumentIndexIterator
                    ];
                (legacySettings.filterResonance = clamp(
                  0,
                  filterResonanceRange,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  instrument.convertLegacySettings(
                    legacySettings,
                    forceSimpleFilter
                  );
              }
              break;
            case 122:
              {
                const instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ],
                  pregoldToEnvelope = [
                    0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20,
                    21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11,
                  ];
                if (
                  (beforeNine && fromBeepBox) ||
                  (beforeFive && fromJummBox) ||
                  (beforeFour && fromGoldBox)
                )
                  if (4 == instrument.type)
                    for (let i = 0; i < Config.drumCount; i++) {
                      let aa =
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                      ((beforeTwo && fromGoldBox) ||
                        (!fromGoldBox && !fromUltraBox)) &&
                        (aa = pregoldToEnvelope[aa]),
                        (instrument.drumsetEnvelopes[i] =
                          Song._envelopeFromLegacyIndex(aa).index);
                    }
                  else {
                    const legacySettings =
                      legacySettingsCache[instrumentChannelIterator][
                        instrumentIndexIterator
                      ];
                    let aa =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    ((beforeTwo && fromGoldBox) ||
                      (!fromGoldBox && !fromUltraBox)) &&
                      (aa = pregoldToEnvelope[aa]),
                      (legacySettings.filterEnvelope =
                        Song._envelopeFromLegacyIndex(aa)),
                      instrument.convertLegacySettings(
                        legacySettings,
                        forceSimpleFilter
                      );
                  }
                else
                  for (let i = 0; i < Config.drumCount; i++) {
                    let aa =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    ((beforeTwo && fromGoldBox) ||
                      (!fromGoldBox && !fromUltraBox)) &&
                      (aa = pregoldToEnvelope[aa]),
                      (instrument.drumsetEnvelopes[i] = clamp(
                        0,
                        Config.envelopes.length,
                        aa
                      ));
                  }
              }
              break;
            case 87:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (
                  ((instrument.pulseWidth = clamp(
                    0,
                    Config.pulseWidthRange + +fromJummBox + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                  fromBeepBox &&
                    (instrument.pulseWidth = Math.round(
                      Math.pow(
                        0.5,
                        (7 - instrument.pulseWidth) * Config.pulseWidthStepPower
                      ) * Config.pulseWidthRange
                    )),
                  (beforeNine && fromBeepBox) ||
                    (beforeFive && fromJummBox) ||
                    (beforeFour && fromGoldBox))
                ) {
                  const pregoldToEnvelope = [
                      0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19,
                      20, 21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11,
                    ],
                    legacySettings =
                      legacySettingsCache[instrumentChannelIterator][
                        instrumentIndexIterator
                      ];
                  let aa =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                  ((beforeTwo && fromGoldBox) ||
                    (!fromGoldBox && !fromUltraBox)) &&
                    (aa = pregoldToEnvelope[aa]),
                    (legacySettings.pulseEnvelope =
                      Song._envelopeFromLegacyIndex(aa)),
                    instrument.convertLegacySettings(
                      legacySettings,
                      forceSimpleFilter
                    );
                }
                fromUltraBox &&
                  !beforeFour &&
                  (instrument.decimalOffset = clamp(
                    0,
                    100,
                    (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                      6) +
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  ));
              }
              break;
            case 73:
              {
                const instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ],
                  sustainValue =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                (instrument.stringSustain = clamp(
                  0,
                  Config.stringSustainRange,
                  31 & sustainValue
                )),
                  (instrument.stringSustainType = Config.enableAcousticSustain
                    ? clamp(0, 2, sustainValue >> 5)
                    : 0);
              }
              break;
            case 100:
              if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              ) {
                const legacySettings = [
                  {
                    transition: "interrupt",
                    fadeInSeconds: 0,
                    fadeOutTicks: -1,
                  },
                  { transition: "normal", fadeInSeconds: 0, fadeOutTicks: -3 },
                  {
                    transition: "normal",
                    fadeInSeconds: 0.025,
                    fadeOutTicks: -3,
                  },
                  {
                    transition: "slide in pattern",
                    fadeInSeconds: 0.025,
                    fadeOutTicks: -3,
                  },
                  {
                    transition: "normal",
                    fadeInSeconds: 0.04,
                    fadeOutTicks: 6,
                  },
                  { transition: "normal", fadeInSeconds: 0, fadeOutTicks: 48 },
                  {
                    transition: "normal",
                    fadeInSeconds: 0.0125,
                    fadeOutTicks: 72,
                  },
                  {
                    transition: "normal",
                    fadeInSeconds: 0.06,
                    fadeOutTicks: 96,
                  },
                  {
                    transition: "slide in pattern",
                    fadeInSeconds: 0.025,
                    fadeOutTicks: -3,
                  },
                ];
                if (beforeThree && fromBeepBox) {
                  const channelIndex =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    settings =
                      legacySettings[
                        clamp(
                          0,
                          legacySettings.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ],
                    instrument = this.channels[channelIndex].instruments[0];
                  (instrument.fadeIn = Synth.secondsToFadeInSetting(
                    settings.fadeInSeconds
                  )),
                    (instrument.fadeOut = Synth.ticksToFadeOutSetting(
                      settings.fadeOutTicks
                    )),
                    (instrument.transition =
                      Config.transitions.dictionary[settings.transition].index),
                    instrument.transition !=
                      Config.transitions.dictionary.normal.index &&
                      (instrument.effects |= 1024);
                } else if (beforeSix && fromBeepBox)
                  for (
                    let channelIndex = 0;
                    channelIndex < this.getChannelCount();
                    channelIndex++
                  )
                    for (const instrument of this.channels[channelIndex]
                      .instruments) {
                      const settings =
                        legacySettings[
                          clamp(
                            0,
                            legacySettings.length,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )
                        ];
                      (instrument.fadeIn = Synth.secondsToFadeInSetting(
                        settings.fadeInSeconds
                      )),
                        (instrument.fadeOut = Synth.ticksToFadeOutSetting(
                          settings.fadeOutTicks
                        )),
                        (instrument.transition =
                          Config.transitions.dictionary[
                            settings.transition
                          ].index),
                        instrument.transition !=
                          Config.transitions.dictionary.normal.index &&
                          (instrument.effects |= 1024);
                    }
                else if (
                  (beforeFour && !fromGoldBox && !fromUltraBox) ||
                  fromBeepBox
                ) {
                  const settings =
                      legacySettings[
                        clamp(
                          0,
                          legacySettings.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ],
                    instrument =
                      this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ];
                  (instrument.fadeIn = Synth.secondsToFadeInSetting(
                    settings.fadeInSeconds
                  )),
                    (instrument.fadeOut = Synth.ticksToFadeOutSetting(
                      settings.fadeOutTicks
                    )),
                    (instrument.transition =
                      Config.transitions.dictionary[settings.transition].index),
                    instrument.transition !=
                      Config.transitions.dictionary.normal.index &&
                      (instrument.effects |= 1024);
                } else {
                  const settings =
                      legacySettings[
                        clamp(
                          0,
                          legacySettings.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ],
                    instrument =
                      this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ];
                  (instrument.fadeIn = Synth.secondsToFadeInSetting(
                    settings.fadeInSeconds
                  )),
                    (instrument.fadeOut = Synth.ticksToFadeOutSetting(
                      settings.fadeOutTicks
                    )),
                    (instrument.transition =
                      Config.transitions.dictionary[settings.transition].index),
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] >
                      0 && (instrument.legacyTieOver = !0),
                    (instrument.clicklessTransition =
                      !!base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ]),
                    (instrument.transition !=
                      Config.transitions.dictionary.normal.index ||
                      instrument.clicklessTransition) &&
                      (instrument.effects |= 1024);
                }
              } else {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.fadeIn = clamp(
                  0,
                  Config.fadeInRange,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (instrument.fadeOut = clamp(
                    0,
                    Config.fadeOutTicks.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                  (fromJummBox || fromGoldBox || fromUltraBox) &&
                    (instrument.clicklessTransition =
                      !!base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ]);
              }
              break;
            case 99:
              if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              )
                if (beforeSeven && fromBeepBox)
                  if (beforeThree && fromBeepBox) {
                    const legacyEffects = [0, 3, 2, 0],
                      legacyEnvelopes = ["none", "none", "none", "tremolo2"],
                      channelIndex =
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                      effect = clamp(
                        0,
                        legacyEffects.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ),
                      instrument = this.channels[channelIndex].instruments[0],
                      legacySettings = legacySettingsCache[channelIndex][0];
                    (instrument.vibrato = legacyEffects[effect]),
                      (null != legacySettings.filterEnvelope &&
                        1 != legacySettings.filterEnvelope.type) ||
                        ((legacySettings.filterEnvelope =
                          Config.envelopes.dictionary[legacyEnvelopes[effect]]),
                        instrument.convertLegacySettings(
                          legacySettings,
                          forceSimpleFilter
                        )),
                      instrument.vibrato !=
                        Config.vibratos.dictionary.none.index &&
                        (instrument.effects |= 512);
                  } else if (beforeSix && fromBeepBox) {
                    const legacyEffects = [0, 1, 2, 3, 0, 0],
                      legacyEnvelopes = [
                        "none",
                        "none",
                        "none",
                        "none",
                        "tremolo5",
                        "tremolo2",
                      ];
                    for (
                      let channelIndex = 0;
                      channelIndex < this.getChannelCount();
                      channelIndex++
                    )
                      for (
                        let i = 0;
                        i < this.channels[channelIndex].instruments.length;
                        i++
                      ) {
                        const effect = clamp(
                            0,
                            legacyEffects.length,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          ),
                          instrument =
                            this.channels[channelIndex].instruments[i],
                          legacySettings = legacySettingsCache[channelIndex][i];
                        (instrument.vibrato = legacyEffects[effect]),
                          (null != legacySettings.filterEnvelope &&
                            1 != legacySettings.filterEnvelope.type) ||
                            ((legacySettings.filterEnvelope =
                              Config.envelopes.dictionary[
                                legacyEnvelopes[effect]
                              ]),
                            instrument.convertLegacySettings(
                              legacySettings,
                              forceSimpleFilter
                            )),
                          instrument.vibrato !=
                            Config.vibratos.dictionary.none.index &&
                            (instrument.effects |= 512),
                          (0 != legacyGlobalReverb ||
                            (fromJummBox && beforeFive) ||
                            (beforeFour && fromGoldBox)) &&
                            !this.getChannelIsNoise(channelIndex) &&
                            ((instrument.effects |= 1),
                            (instrument.reverb = legacyGlobalReverb));
                      }
                  } else {
                    const legacyEffects = [0, 1, 2, 3, 0, 0],
                      legacyEnvelopes = [
                        "none",
                        "none",
                        "none",
                        "none",
                        "tremolo5",
                        "tremolo2",
                      ],
                      effect = clamp(
                        0,
                        legacyEffects.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ),
                      instrument =
                        this.channels[instrumentChannelIterator].instruments[
                          instrumentIndexIterator
                        ],
                      legacySettings =
                        legacySettingsCache[instrumentChannelIterator][
                          instrumentIndexIterator
                        ];
                    (instrument.vibrato = legacyEffects[effect]),
                      (null != legacySettings.filterEnvelope &&
                        1 != legacySettings.filterEnvelope.type) ||
                        ((legacySettings.filterEnvelope =
                          Config.envelopes.dictionary[legacyEnvelopes[effect]]),
                        instrument.convertLegacySettings(
                          legacySettings,
                          forceSimpleFilter
                        )),
                      instrument.vibrato !=
                        Config.vibratos.dictionary.none.index &&
                        (instrument.effects |= 512),
                      (0 != legacyGlobalReverb ||
                        (fromJummBox && beforeFive) ||
                        (beforeFour && fromGoldBox)) &&
                        ((instrument.effects |= 1),
                        (instrument.reverb = legacyGlobalReverb));
                  }
                else {
                  const instrument =
                      this.channels[instrumentChannelIterator].instruments[
                        instrumentIndexIterator
                      ],
                    vibrato = clamp(
                      0,
                      Config.vibratos.length + 1,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    );
                  (instrument.vibrato = vibrato),
                    instrument.vibrato !=
                      Config.vibratos.dictionary.none.index &&
                      (instrument.effects |= 512),
                    vibrato == Config.vibratos.length
                      ? ((instrument.vibratoDepth =
                          clamp(
                            0,
                            Config.modulators.dictionary["vibrato depth"]
                              .maxRawVol + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          ) / 50),
                        (instrument.vibratoSpeed = clamp(
                          0,
                          Config.modulators.dictionary["vibrato speed"]
                            .maxRawVol + 1,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )),
                        (instrument.vibratoDelay =
                          clamp(
                            0,
                            Config.modulators.dictionary["vibrato delay"]
                              .maxRawVol + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          ) / 2),
                        (instrument.vibratoType = clamp(
                          0,
                          Config.vibratoTypes.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )),
                        (instrument.effects |= 512))
                      : ((instrument.vibratoDepth =
                          Config.vibratos[instrument.vibrato].amplitude),
                        (instrument.vibratoSpeed = 10),
                        (instrument.vibratoDelay =
                          Config.vibratos[instrument.vibrato].delayTicks / 2),
                        (instrument.vibratoType =
                          Config.vibratos[instrument.vibrato].type));
                }
              break;
            case 71:
              if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.arpeggioSpeed = clamp(
                  0,
                  Config.modulators.dictionary["arp speed"].maxRawVol + 1,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (instrument.fastTwoNoteArp =
                    !!base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
              }
              break;
            case 104:
              if (beforeThree && fromBeepBox) {
                const channelIndex =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                this.channels[channelIndex].instruments[0].unison = clamp(
                  0,
                  Config.unisons.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
                const instrument = this.channels[channelIndex].instruments[0];
                (instrument.unisonVoices =
                  Config.unisons[instrument.unison].voices),
                  (instrument.unisonSpread =
                    Config.unisons[instrument.unison].spread),
                  (instrument.unisonOffset =
                    Config.unisons[instrument.unison].offset),
                  (instrument.unisonExpression =
                    Config.unisons[instrument.unison].expression),
                  (instrument.unisonSign =
                    Config.unisons[instrument.unison].sign);
              } else if (beforeSix && fromBeepBox)
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                )
                  for (const instrument of this.channels[channelIndex]
                    .instruments) {
                    const originalValue =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    let unison = clamp(0, Config.unisons.length, originalValue);
                    8 == originalValue &&
                      ((unison = 2), (instrument.chord = 3)),
                      (instrument.unison = unison),
                      (instrument.unisonVoices =
                        Config.unisons[instrument.unison].voices),
                      (instrument.unisonSpread =
                        Config.unisons[instrument.unison].spread),
                      (instrument.unisonOffset =
                        Config.unisons[instrument.unison].offset),
                      (instrument.unisonExpression =
                        Config.unisons[instrument.unison].expression),
                      (instrument.unisonSign =
                        Config.unisons[instrument.unison].sign);
                  }
              else if (beforeSeven && fromBeepBox) {
                const originalValue =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                let unison = clamp(0, Config.unisons.length, originalValue);
                8 == originalValue &&
                  ((unison = 2),
                  (this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ].chord = 3)),
                  (this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ].unison = unison);
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.unisonVoices =
                  Config.unisons[instrument.unison].voices),
                  (instrument.unisonSpread =
                    Config.unisons[instrument.unison].spread),
                  (instrument.unisonOffset =
                    Config.unisons[instrument.unison].offset),
                  (instrument.unisonExpression =
                    Config.unisons[instrument.unison].expression),
                  (instrument.unisonSign =
                    Config.unisons[instrument.unison].sign);
              } else {
                this.channels[instrumentChannelIterator].instruments[
                  instrumentIndexIterator
                ].unison = clamp(
                  0,
                  Config.unisons.length + 1,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (
                  fromUltraBox &&
                  !beforeFive &&
                  instrument.unison == Config.unisons.length
                ) {
                  instrument.unisonVoices =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                  const unisonSpreadNegative =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    unisonSpread =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      63 *
                        (base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ] +
                          63 *
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]),
                    unisonOffsetNegative =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    unisonOffset =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      63 *
                        (base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ] +
                          63 *
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]),
                    unisonExpressionNegative =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    unisonExpression =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      63 *
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    unisonSignNegative =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    unisonSign =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] +
                      63 *
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                  (instrument.unisonSpread = unisonSpread / 1e3),
                    0 == unisonSpreadNegative &&
                      (instrument.unisonSpread *= -1),
                    (instrument.unisonOffset = unisonOffset / 1e3),
                    0 == unisonOffsetNegative &&
                      (instrument.unisonOffset *= -1),
                    (instrument.unisonExpression = unisonExpression / 1e3),
                    0 == unisonExpressionNegative &&
                      (instrument.unisonExpression *= -1),
                    (instrument.unisonSign = unisonSign / 1e3),
                    0 == unisonSignNegative && (instrument.unisonSign *= -1);
                } else
                  (instrument.unisonVoices =
                    Config.unisons[instrument.unison].voices),
                    (instrument.unisonSpread =
                      Config.unisons[instrument.unison].spread),
                    (instrument.unisonOffset =
                      Config.unisons[instrument.unison].offset),
                    (instrument.unisonExpression =
                      Config.unisons[instrument.unison].expression),
                    (instrument.unisonSign =
                      Config.unisons[instrument.unison].sign);
              }
              break;
            case 67:
              if (
                (beforeNine && fromBeepBox) ||
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              ) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.chord = clamp(
                  0,
                  Config.chords.length,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  instrument.chord !=
                    Config.chords.dictionary.simultaneous.index &&
                    (instrument.effects |= 2048);
              }
              break;
            case 113:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (
                  (beforeNine && fromBeepBox) ||
                  (fromJummBox && beforeFive) ||
                  (beforeFour && fromGoldBox)
                ) {
                  (instrument.effects =
                    4095 &
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    0 != legacyGlobalReverb ||
                    (fromJummBox && beforeFive) ||
                    (beforeFour && fromGoldBox)
                      ? effectsIncludeReverb(instrument.effects) &&
                        (instrument.reverb = legacyGlobalReverb)
                      : (instrument.effects &= -2),
                    (instrument.effects |= 4),
                    instrument.vibrato !=
                      Config.vibratos.dictionary.none.index &&
                      (instrument.effects |= 512),
                    instrument.detune != Config.detuneCenter &&
                      (instrument.effects |= 256),
                    instrument.aliases
                      ? (instrument.effects |= 8)
                      : (instrument.effects &= -9);
                  const legacySettings =
                    legacySettingsCache[instrumentChannelIterator][
                      instrumentIndexIterator
                    ];
                  instrument.convertLegacySettings(
                    legacySettings,
                    forceSimpleFilter
                  );
                } else {
                  if (
                    ((instrument.effects =
                      (base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) |
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    effectsIncludeNoteFilter(instrument.effects))
                  ) {
                    let typeCheck =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    if (fromBeepBox || 0 == typeCheck) {
                      (instrument.noteFilterType = !1),
                        (fromJummBox || fromGoldBox || fromUltraBox) &&
                          (typeCheck =
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]),
                        (instrument.noteFilter.controlPointCount = clamp(
                          0,
                          Config.filterMaxPoints + 1,
                          typeCheck
                        ));
                      for (
                        let i = instrument.noteFilter.controlPoints.length;
                        i < instrument.noteFilter.controlPointCount;
                        i++
                      )
                        instrument.noteFilter.controlPoints[i] =
                          new FilterControlPoint();
                      for (
                        let i = 0;
                        i < instrument.noteFilter.controlPointCount;
                        i++
                      ) {
                        const point = instrument.noteFilter.controlPoints[i];
                        (point.type = clamp(
                          0,
                          3,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )),
                          (point.freq = clamp(
                            0,
                            Config.filterFreqRange,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                          (point.gain = clamp(
                            0,
                            Config.filterGainRange,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          ));
                      }
                      for (
                        let i = instrument.noteFilter.controlPointCount;
                        i < typeCheck;
                        i++
                      )
                        charIndex += 3;
                      if (
                        ((instrument.noteSubFilters[0] = instrument.noteFilter),
                        (fromJummBox && !beforeFive) ||
                          fromGoldBox ||
                          fromUltraBox)
                      ) {
                        let usingSubFilterBitfield =
                          (base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ] <<
                            6) |
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ];
                        for (let j = 0; j < Config.filterMorphCount - 1; j++)
                          if (usingSubFilterBitfield & (1 << j)) {
                            const originalSubfilterControlPointCount =
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ];
                            null == instrument.noteSubFilters[j + 1] &&
                              (instrument.noteSubFilters[j + 1] =
                                new FilterSettings()),
                              (instrument.noteSubFilters[
                                j + 1
                              ].controlPointCount = clamp(
                                0,
                                Config.filterMaxPoints + 1,
                                originalSubfilterControlPointCount
                              ));
                            for (
                              let i =
                                instrument.noteSubFilters[j + 1].controlPoints
                                  .length;
                              i <
                              instrument.noteSubFilters[j + 1]
                                .controlPointCount;
                              i++
                            )
                              instrument.noteSubFilters[j + 1].controlPoints[
                                i
                              ] = new FilterControlPoint();
                            for (
                              let i = 0;
                              i <
                              instrument.noteSubFilters[j + 1]
                                .controlPointCount;
                              i++
                            ) {
                              const point =
                                instrument.noteSubFilters[j + 1].controlPoints[
                                  i
                                ];
                              (point.type = clamp(
                                0,
                                3,
                                base64CharCodeToInt[
                                  compressed.charCodeAt(charIndex++)
                                ]
                              )),
                                (point.freq = clamp(
                                  0,
                                  Config.filterFreqRange,
                                  base64CharCodeToInt[
                                    compressed.charCodeAt(charIndex++)
                                  ]
                                )),
                                (point.gain = clamp(
                                  0,
                                  Config.filterGainRange,
                                  base64CharCodeToInt[
                                    compressed.charCodeAt(charIndex++)
                                  ]
                                ));
                            }
                            for (
                              let i =
                                instrument.noteSubFilters[j + 1]
                                  .controlPointCount;
                              i < originalSubfilterControlPointCount;
                              i++
                            )
                              charIndex += 3;
                          }
                      }
                    } else
                      (instrument.noteFilterType = !0),
                        instrument.noteFilter.reset(),
                        (instrument.noteFilterSimpleCut = clamp(
                          0,
                          Config.filterSimpleCutRange,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )),
                        (instrument.noteFilterSimplePeak = clamp(
                          0,
                          Config.filterSimplePeakRange,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        ));
                  }
                  effectsIncludeTransition(instrument.effects) &&
                    (instrument.transition = clamp(
                      0,
                      Config.transitions.length,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    )),
                    effectsIncludeChord(instrument.effects) &&
                      ((instrument.chord = clamp(
                        0,
                        Config.chords.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      instrument.chord ==
                        Config.chords.dictionary.arpeggio.index &&
                        (fromJummBox || fromGoldBox || fromUltraBox) &&
                        ((instrument.arpeggioSpeed =
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]),
                        (instrument.fastTwoNoteArp =
                          !!base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]))),
                    effectsIncludePitchShift(instrument.effects) &&
                      (instrument.pitchShift = clamp(
                        0,
                        Config.pitchShiftRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                    effectsIncludeDetune(instrument.effects) &&
                      (fromBeepBox
                        ? ((instrument.detune = clamp(
                            Config.detuneMin,
                            Config.detuneMax + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                          (instrument.detune = Math.round(
                            ((instrument.detune - 9) *
                              (Math.abs(instrument.detune - 9) + 1)) /
                              2 +
                              Config.detuneCenter
                          )))
                        : (instrument.detune = clamp(
                            Config.detuneMin,
                            Config.detuneMax + 1,
                            (base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ] <<
                              6) +
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                          ))),
                    effectsIncludeVibrato(instrument.effects) &&
                      ((instrument.vibrato = clamp(
                        0,
                        Config.vibratos.length + 1,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      instrument.vibrato == Config.vibratos.length &&
                      (fromJummBox || fromGoldBox || fromUltraBox)
                        ? ((instrument.vibratoDepth =
                            clamp(
                              0,
                              Config.modulators.dictionary["vibrato depth"]
                                .maxRawVol + 1,
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                            ) / 25),
                          (instrument.vibratoSpeed = clamp(
                            0,
                            Config.modulators.dictionary["vibrato speed"]
                              .maxRawVol + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                          (instrument.vibratoDelay = clamp(
                            0,
                            Config.modulators.dictionary["vibrato delay"]
                              .maxRawVol + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                          (instrument.vibratoType = clamp(
                            0,
                            Config.vibratoTypes.length,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )))
                        : ((instrument.vibratoDepth =
                            Config.vibratos[instrument.vibrato].amplitude),
                          (instrument.vibratoSpeed = 10),
                          (instrument.vibratoDelay =
                            Config.vibratos[instrument.vibrato].delayTicks / 2),
                          (instrument.vibratoType =
                            Config.vibratos[instrument.vibrato].type))),
                    effectsIncludeDistortion(instrument.effects) &&
                      ((instrument.distortion = clamp(
                        0,
                        Config.distortionRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      ((fromJummBox && !beforeFive) ||
                        fromGoldBox ||
                        fromUltraBox) &&
                        (instrument.aliases =
                          !!base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ])),
                    effectsIncludeBitcrusher(instrument.effects) &&
                      ((instrument.bitcrusherFreq = clamp(
                        0,
                        Config.bitcrusherFreqRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      (instrument.bitcrusherQuantization = clamp(
                        0,
                        Config.bitcrusherQuantizationRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ))),
                    effectsIncludePanning(instrument.effects) &&
                      ((instrument.pan = clamp(
                        0,
                        Config.panMax + 1,
                        fromBeepBox
                          ? Math.round(
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ] *
                                (Config.panMax / 8)
                            )
                          : (base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ] <<
                              6) +
                              base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ]
                      )),
                      ((fromJummBox && !beforeTwo) ||
                        fromGoldBox ||
                        fromUltraBox) &&
                        (instrument.panDelay =
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ])),
                    effectsIncludeChorus(instrument.effects) &&
                      (instrument.chorus = fromBeepBox
                        ? 2 *
                          clamp(
                            0,
                            Config.chorusRange / 2 + 1,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )
                        : clamp(
                            0,
                            Config.chorusRange,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )),
                    effectsIncludeEcho(instrument.effects) &&
                      ((instrument.echoSustain = clamp(
                        0,
                        Config.echoSustainRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      )),
                      (instrument.echoDelay = clamp(
                        0,
                        Config.echoDelayRange,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ))),
                    effectsIncludeReverb(instrument.effects) &&
                      (instrument.reverb = clamp(
                        0,
                        Config.reverbRange,
                        fromBeepBox
                          ? Math.round(
                              (base64CharCodeToInt[
                                compressed.charCodeAt(charIndex++)
                              ] *
                                Config.reverbRange) /
                                3
                            )
                          : base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                      ));
                }
                instrument.effects &= 4095;
              }
              break;
            case 118:
              if (beforeThree && fromBeepBox) {
                const channelIndex =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                  instrument = this.channels[channelIndex].instruments[0];
                instrument.volume = Math.round(
                  clamp(
                    -Config.volumeRange / 2,
                    1,
                    5 * -base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )
                );
              } else if (beforeSix && fromBeepBox)
                for (
                  let channelIndex = 0;
                  channelIndex < this.getChannelCount();
                  channelIndex++
                )
                  for (const instrument of this.channels[channelIndex]
                    .instruments)
                    instrument.volume = Math.round(
                      clamp(
                        -Config.volumeRange / 2,
                        1,
                        5 *
                          -base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                      )
                    );
              else if (beforeSeven && fromBeepBox) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                instrument.volume = Math.round(
                  clamp(
                    -Config.volumeRange / 2,
                    1,
                    5 * -base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )
                );
              } else if (fromBeepBox) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                instrument.volume = Math.round(
                  clamp(
                    -Config.volumeRange / 2,
                    1,
                    (25 *
                      -base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ]) /
                      7
                  )
                );
              } else {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                instrument.volume = Math.round(
                  clamp(
                    -Config.volumeRange / 2,
                    Config.volumeRange / 2 + 1,
                    ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                      6) |
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) -
                      Config.volumeRange / 2
                  )
                );
              }
              break;
            case 76:
              if (beforeNine && fromBeepBox) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                instrument.pan = clamp(
                  0,
                  Config.panMax + 1,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)] *
                    (Config.panMax / 8)
                );
              } else if (
                (fromJummBox && beforeFive) ||
                (beforeFour && fromGoldBox)
              ) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.pan = clamp(
                  0,
                  Config.panMax + 1,
                  (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] <<
                    6) +
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  ((fromJummBox && !beforeThree) ||
                    fromGoldBox ||
                    fromUltraBox) &&
                    (instrument.panDelay =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
              }
              break;
            case 68:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) &&
                  ((instrument.detune = clamp(
                    Config.detuneMin,
                    Config.detuneMax + 1,
                    4 *
                      ((base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) +
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)])
                  )),
                  (instrument.effects |= 256));
              }
              break;
            case 77:
              {
                let instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                for (let j = 0; j < 64; j++)
                  instrument.customChipWave[j] = clamp(
                    -24,
                    25,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)] - 24
                  );
                let sum = 0;
                for (let i = 0; i < instrument.customChipWave.length; i++)
                  sum += instrument.customChipWave[i];
                const average = sum / instrument.customChipWave.length;
                let cumulative = 0,
                  wavePrev = 0;
                for (let i = 0; i < instrument.customChipWave.length; i++)
                  (cumulative += wavePrev),
                    (wavePrev = instrument.customChipWave[i] - average),
                    (instrument.customChipWaveIntegral[i] = cumulative);
                instrument.customChipWaveIntegral[64] = 0;
              }
              break;
            case 79:
              {
                let nextValue =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                63 == nextValue
                  ? this.restoreLimiterDefaults()
                  : ((this.compressionRatio =
                      nextValue < 10
                        ? nextValue / 10
                        : 1 + (nextValue - 10) / 60),
                    (nextValue =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    (this.limitRatio =
                      nextValue < 10 ? nextValue / 10 : nextValue - 9),
                    (this.limitDecay =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    (this.limitRise =
                      250 *
                        base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ] +
                      2e3),
                    (this.compressionThreshold =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] /
                      20),
                    (this.limitThreshold =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)] /
                      20),
                    (this.masterGain =
                      ((base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) +
                        base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ]) /
                      50));
              }
              break;
            case 85:
              for (
                let channel = 0;
                channel < this.getChannelCount();
                channel++
              ) {
                var channelNameLength;
                (channelNameLength =
                  !beforeFour || fromGoldBox || fromUltraBox
                    ? (base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ] <<
                        6) +
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    : base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                  (this.channels[channel].name = decodeURIComponent(
                    compressed.substring(
                      charIndex,
                      charIndex + channelNameLength
                    )
                  )),
                  (charIndex += channelNameLength);
              }
              break;
            case 65:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (1 == instrument.type)
                  instrument.algorithm = clamp(
                    0,
                    Config.algorithms.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
                else if (
                  ((instrument.algorithm6Op = clamp(
                    0,
                    Config.algorithms6Op.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                  instrument.customAlgorithm.fromPreset(
                    instrument.algorithm6Op
                  ),
                  67 == compressed.charCodeAt(charIndex))
                ) {
                  let carrierCountTemp = clamp(
                    1,
                    Config.operatorCount + 2 + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex + 1)]
                  );
                  charIndex++;
                  let tempModArray = [];
                  if (113 == compressed.charCodeAt(charIndex + 1)) {
                    charIndex++;
                    let j = 0;
                    for (
                      charIndex++;
                      113 != compressed.charCodeAt(charIndex);

                    ) {
                      tempModArray[j] = [];
                      let o = 0;
                      for (; 82 != compressed.charCodeAt(charIndex); )
                        (tempModArray[j][o] = clamp(
                          1,
                          Config.operatorCount + 3,
                          base64CharCodeToInt[compressed.charCodeAt(charIndex)]
                        )),
                          o++,
                          charIndex++;
                      j++, charIndex++;
                    }
                    instrument.customAlgorithm.set(
                      carrierCountTemp,
                      tempModArray
                    ),
                      charIndex++;
                  }
                }
                if (
                  (beforeNine && fromBeepBox) ||
                  (beforeFive && fromJummBox) ||
                  (beforeFour && fromGoldBox)
                ) {
                  const legacySettings =
                    legacySettingsCache[instrumentChannelIterator][
                      instrumentIndexIterator
                    ];
                  instrument.convertLegacySettings(
                    legacySettings,
                    forceSimpleFilter
                  );
                }
              }
              break;
            case 120:
              if (fromGoldBox && !beforeFour && beforeSix) {
                const chipWaveForCompat =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                chipWaveForCompat + 62 > 85 &&
                  "legacysamples" !=
                    document.URL.substring(
                      document.URL.length - 13
                    ).toLowerCase() &&
                  (willLoadLegacySamplesForOldSongs ||
                    ((willLoadLegacySamplesForOldSongs = !0),
                    (Config.willReloadForCustomSamples = !0),
                    (EditorConfig.customSamples = ["legacySamples"]),
                    loadBuiltInSamples(0))),
                  (this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ].chipWave =
                    chipWaveForCompat + 62 > 78
                      ? clamp(
                          0,
                          Config.chipWaves.length,
                          chipWaveForCompat + 63
                        )
                      : chipWaveForCompat + 62 > 67
                        ? clamp(
                            0,
                            Config.chipWaves.length,
                            chipWaveForCompat + 61
                          )
                        : chipWaveForCompat + 62 == 67
                          ? 40
                          : clamp(
                              0,
                              Config.chipWaves.length,
                              chipWaveForCompat + 62
                            ));
              } else {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.supersawDynamism = clamp(
                  0,
                  Config.supersawDynamismMax + 1,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                )),
                  (instrument.supersawSpread = clamp(
                    0,
                    Config.supersawSpreadMax + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                  (instrument.supersawShape = clamp(
                    0,
                    Config.supersawShapeMax + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  ));
              }
              break;
            case 70:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (1 == instrument.type)
                  instrument.feedbackType = clamp(
                    0,
                    Config.feedbacks.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
                else {
                  (instrument.feedbackType6Op = clamp(
                    0,
                    Config.feedbacks6Op.length,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  )),
                    instrument.customFeedbackType.fromPreset(
                      instrument.feedbackType6Op
                    );
                  let tempModArray = [];
                  if (113 == compressed.charCodeAt(charIndex)) {
                    let j = 0;
                    for (
                      charIndex++;
                      113 != compressed.charCodeAt(charIndex);

                    ) {
                      tempModArray[j] = [];
                      let o = 0;
                      for (; 82 != compressed.charCodeAt(charIndex); )
                        (tempModArray[j][o] = clamp(
                          1,
                          Config.operatorCount + 2,
                          base64CharCodeToInt[compressed.charCodeAt(charIndex)]
                        )),
                          o++,
                          charIndex++;
                      j++, charIndex++;
                    }
                    instrument.customFeedbackType.set(tempModArray),
                      charIndex++;
                  }
                }
              }
              break;
            case 66:
              this.channels[instrumentChannelIterator].instruments[
                instrumentIndexIterator
              ].feedbackAmplitude = clamp(
                0,
                Config.operatorAmplitudeMax + 1,
                base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
              );
              break;
            case 86:
              if (
                (beforeNine && fromBeepBox) ||
                (beforeFive && fromJummBox) ||
                (beforeFour && fromGoldBox)
              ) {
                const pregoldToEnvelope = [
                    0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20,
                    21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11,
                  ],
                  instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ],
                  legacySettings =
                    legacySettingsCache[instrumentChannelIterator][
                      instrumentIndexIterator
                    ];
                let aa =
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                ((beforeTwo && fromGoldBox) ||
                  (!fromGoldBox && !fromUltraBox)) &&
                  (aa = pregoldToEnvelope[aa]),
                  (legacySettings.feedbackEnvelope =
                    Song._envelopeFromLegacyIndex(base64CharCodeToInt[aa])),
                  instrument.convertLegacySettings(
                    legacySettings,
                    forceSimpleFilter
                  );
              }
              break;
            case 81:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (beforeThree && fromGoldBox) {
                  const freqToGold3 = [
                    4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16, 18, 20, 22, 24, 2, 1,
                    9, 17, 19, 21, 23, 0, 3,
                  ];
                  for (
                    let o = 0;
                    o < (11 == instrument.type ? 6 : Config.operatorCount);
                    o++
                  )
                    instrument.operators[o].frequency =
                      freqToGold3[
                        clamp(
                          0,
                          freqToGold3.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ];
                } else if (fromGoldBox || fromUltraBox)
                  for (
                    let o = 0;
                    o < (11 == instrument.type ? 6 : Config.operatorCount);
                    o++
                  )
                    instrument.operators[o].frequency = clamp(
                      0,
                      Config.operatorFrequencies.length,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    );
                else {
                  const freqToUltraBox = [
                    4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16, 18, 20, 23, 27, 2, 1,
                    9, 17, 19, 21, 23, 0, 3,
                  ];
                  for (
                    let o = 0;
                    o < (11 == instrument.type ? 6 : Config.operatorCount);
                    o++
                  )
                    instrument.operators[o].frequency =
                      freqToUltraBox[
                        clamp(
                          0,
                          freqToUltraBox.length,
                          base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                          ]
                        )
                      ];
                }
              }
              break;
            case 80:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                for (
                  let o = 0;
                  o < (11 == instrument.type ? 6 : Config.operatorCount);
                  o++
                )
                  instrument.operators[o].amplitude = clamp(
                    0,
                    Config.operatorAmplitudeMax + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
              }
              break;
            case 69:
              {
                const pregoldToEnvelope = [
                    0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20,
                    21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11,
                  ],
                  jummToUltraEnvelope = [
                    0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20,
                    21, 23, 24, 25, 58, 59, 60,
                  ],
                  instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ];
                if (
                  (beforeNine && fromBeepBox) ||
                  (beforeFive && fromJummBox) ||
                  (beforeFour && fromGoldBox)
                ) {
                  const legacySettings =
                    legacySettingsCache[instrumentChannelIterator][
                      instrumentIndexIterator
                    ];
                  legacySettings.operatorEnvelopes = [];
                  for (
                    let o = 0;
                    o < (11 == instrument.type ? 6 : Config.operatorCount);
                    o++
                  ) {
                    let aa =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    ((beforeTwo && fromGoldBox) || fromBeepBox) &&
                      (aa = pregoldToEnvelope[aa]),
                      fromJummBox && (aa = jummToUltraEnvelope[aa]),
                      (legacySettings.operatorEnvelopes[o] =
                        Song._envelopeFromLegacyIndex(aa));
                  }
                  instrument.convertLegacySettings(
                    legacySettings,
                    forceSimpleFilter
                  );
                } else {
                  const envelopeCount = clamp(
                    0,
                    Config.maxEnvelopeCount + 1,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
                  ((fromJummBox && !beforeSix) ||
                    (fromUltraBox && !beforeFive)) &&
                    ((instrument.envelopeSpeed = clamp(
                      0,
                      Config.modulators.dictionary["envelope speed"].maxRawVol +
                        1,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    )),
                    (instrument.discreteEnvelope =
                      !!base64CharCodeToInt[
                        compressed.charCodeAt(charIndex++)
                      ]));
                  for (let i = 0; i < envelopeCount; i++) {
                    const target = clamp(
                      0,
                      Config.instrumentAutomationTargets.length,
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    );
                    let index = 0;
                    const maxCount =
                      Config.instrumentAutomationTargets[target].maxCount;
                    maxCount > 1 &&
                      (index = clamp(
                        0,
                        maxCount,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ));
                    let aa =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    ((beforeTwo && fromGoldBox) || fromBeepBox) &&
                      (aa = pregoldToEnvelope[aa]),
                      fromJummBox && (aa = jummToUltraEnvelope[aa]);
                    const envelope = clamp(0, Config.envelopes.length, aa);
                    instrument.addEnvelope(target, index, envelope);
                  }
                }
              }
              break;
            case 82:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (beforeThree && fromGoldBox)
                  for (let o = 0; o < Config.operatorCount; o++) {
                    const pre3To3g = [0, 1, 3, 2, 2, 2, 4, 5],
                      old = clamp(
                        0,
                        pre3To3g.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      );
                    3 == old
                      ? (instrument.operators[o].pulseWidth = 5)
                      : 4 == old
                        ? (instrument.operators[o].pulseWidth = 4)
                        : 5 == old && (instrument.operators[o].pulseWidth = 6),
                      (instrument.operators[o].waveform = pre3To3g[old]);
                  }
                else
                  for (
                    let o = 0;
                    o < (11 == instrument.type ? 6 : Config.operatorCount);
                    o++
                  ) {
                    if (fromJummBox) {
                      const jummToG = [0, 1, 3, 2, 4, 5];
                      instrument.operators[o].waveform =
                        jummToG[
                          clamp(
                            0,
                            Config.operatorWaves.length,
                            base64CharCodeToInt[
                              compressed.charCodeAt(charIndex++)
                            ]
                          )
                        ];
                    } else
                      instrument.operators[o].waveform = clamp(
                        0,
                        Config.operatorWaves.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      );
                    2 == instrument.operators[o].waveform &&
                      (instrument.operators[o].pulseWidth = clamp(
                        0,
                        Config.pwmOperatorWaves.length,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                      ));
                  }
              }
              break;
            case 83:
              {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                if (3 == instrument.type) {
                  const byteCount = Math.ceil(
                      (Config.spectrumControlPoints *
                        Config.spectrumControlPointBits) /
                        6
                    ),
                    bits = new BitFieldReader(
                      compressed,
                      charIndex,
                      charIndex + byteCount
                    );
                  for (let i = 0; i < Config.spectrumControlPoints; i++)
                    instrument.spectrumWave.spectrum[i] = bits.read(
                      Config.spectrumControlPointBits
                    );
                  instrument.spectrumWave.markCustomWaveDirty(),
                    (charIndex += byteCount);
                } else {
                  if (4 != instrument.type)
                    throw new Error(
                      "Unhandled instrument type for spectrum song tag code."
                    );
                  {
                    const byteCount = Math.ceil(
                        (Config.drumCount *
                          Config.spectrumControlPoints *
                          Config.spectrumControlPointBits) /
                          6
                      ),
                      bits = new BitFieldReader(
                        compressed,
                        charIndex,
                        charIndex + byteCount
                      );
                    for (let j = 0; j < Config.drumCount; j++) {
                      for (let i = 0; i < Config.spectrumControlPoints; i++)
                        instrument.drumsetSpectrumWaves[j].spectrum[i] =
                          bits.read(Config.spectrumControlPointBits);
                      instrument.drumsetSpectrumWaves[j].markCustomWaveDirty();
                    }
                    charIndex += byteCount;
                  }
                }
              }
              break;
            case 72:
              {
                const instrument =
                    this.channels[instrumentChannelIterator].instruments[
                      instrumentIndexIterator
                    ],
                  byteCount = Math.ceil(
                    (Config.harmonicsControlPoints *
                      Config.harmonicsControlPointBits) /
                      6
                  ),
                  bits = new BitFieldReader(
                    compressed,
                    charIndex,
                    charIndex + byteCount
                  );
                for (let i = 0; i < Config.harmonicsControlPoints; i++)
                  instrument.harmonicsWave.harmonics[i] = bits.read(
                    Config.harmonicsControlPointBits
                  );
                instrument.harmonicsWave.markCustomWaveDirty(),
                  (charIndex += byteCount);
              }
              break;
            case 88:
              if ((fromJummBox && beforeFive) || (fromGoldBox && beforeFour)) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                (instrument.aliases =
                  !!base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                  instrument.aliases &&
                    ((instrument.distortion = 0), (instrument.effects |= 8));
              } else if (fromUltraBox) {
                const instrument =
                  this.channels[instrumentChannelIterator].instruments[
                    instrumentIndexIterator
                  ];
                instrument.decimalOffset = clamp(
                  0,
                  51,
                  base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                );
              }
              break;
            case 98:
              {
                let subStringLength;
                if (beforeThree && fromBeepBox) {
                  const channelIndex =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)],
                    barCount =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                  subStringLength = Math.ceil(0.5 * barCount);
                  const bits = new BitFieldReader(
                    compressed,
                    charIndex,
                    charIndex + subStringLength
                  );
                  for (let i = 0; i < barCount; i++)
                    this.channels[channelIndex].bars[i] = bits.read(3) + 1;
                } else if (beforeFive && fromBeepBox) {
                  let neededBits = 0;
                  for (; 1 << neededBits < this.patternsPerChannel; )
                    neededBits++;
                  subStringLength = Math.ceil(
                    (this.getChannelCount() * this.barCount * neededBits) / 6
                  );
                  const bits = new BitFieldReader(
                    compressed,
                    charIndex,
                    charIndex + subStringLength
                  );
                  for (
                    let channelIndex = 0;
                    channelIndex < this.getChannelCount();
                    channelIndex++
                  )
                    for (let i = 0; i < this.barCount; i++)
                      this.channels[channelIndex].bars[i] =
                        bits.read(neededBits) + 1;
                } else {
                  let neededBits = 0;
                  for (; 1 << neededBits < this.patternsPerChannel + 1; )
                    neededBits++;
                  subStringLength = Math.ceil(
                    (this.getChannelCount() * this.barCount * neededBits) / 6
                  );
                  const bits = new BitFieldReader(
                    compressed,
                    charIndex,
                    charIndex + subStringLength
                  );
                  for (
                    let channelIndex = 0;
                    channelIndex < this.getChannelCount();
                    channelIndex++
                  )
                    for (let i = 0; i < this.barCount; i++)
                      this.channels[channelIndex].bars[i] =
                        bits.read(neededBits);
                }
                charIndex += subStringLength;
              }
              break;
            case 112:
              {
                let bitStringLength = 0,
                  channelIndex,
                  largerChords = !((beforeFour && fromJummBox) || fromBeepBox),
                  recentPitchBitLength = largerChords ? 4 : 3,
                  recentPitchLength = largerChords ? 16 : 8;
                if (beforeThree && fromBeepBox)
                  (channelIndex =
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    charIndex++,
                    (bitStringLength =
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]),
                    (bitStringLength <<= 6),
                    (bitStringLength +=
                      base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                else {
                  channelIndex = 0;
                  let bitStringLengthLength = validateRange(
                    1,
                    4,
                    base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                  );
                  for (; bitStringLengthLength > 0; )
                    (bitStringLength <<= 6),
                      (bitStringLength +=
                        base64CharCodeToInt[
                          compressed.charCodeAt(charIndex++)
                        ]),
                      bitStringLengthLength--;
                }
                const bits = new BitFieldReader(
                  compressed,
                  charIndex,
                  charIndex + bitStringLength
                );
                charIndex += bitStringLength;
                const bitsPerNoteSize = Song.getNeededBits(Config.noteSizeMax);
                let songReverbChannel = -1,
                  songReverbInstrument = -1,
                  songReverbIndex = -1;
                for (;;) {
                  const channel = this.channels[channelIndex],
                    isNoiseChannel = this.getChannelIsNoise(channelIndex),
                    isModChannel = this.getChannelIsMod(channelIndex),
                    maxInstrumentsPerPattern =
                      this.getMaxInstrumentsPerPattern(channelIndex),
                    neededInstrumentCountBits = Song.getNeededBits(
                      maxInstrumentsPerPattern - Config.instrumentCountMin
                    ),
                    neededInstrumentIndexBits = Song.getNeededBits(
                      channel.instruments.length - 1
                    );
                  if (isModChannel) {
                    let jumfive =
                      (beforeFive && fromJummBox) ||
                      (beforeFour && fromGoldBox);
                    const neededModInstrumentIndexBits = jumfive
                      ? neededInstrumentIndexBits
                      : Song.getNeededBits(
                          this.getMaxInstrumentsPerChannel() + 2
                        );
                    for (
                      let instrumentIndex = 0;
                      instrumentIndex < channel.instruments.length;
                      instrumentIndex++
                    ) {
                      let instrument = channel.instruments[instrumentIndex];
                      for (let mod = 0; mod < Config.modCount; mod++) {
                        let status = bits.read(2);
                        switch (status) {
                          case 0:
                            (instrument.modChannels[mod] = clamp(
                              0,
                              this.pitchChannelCount +
                                this.noiseChannelCount +
                                1,
                              bits.read(8)
                            )),
                              (instrument.modInstruments[mod] = clamp(
                                0,
                                this.channels[instrument.modChannels[mod]]
                                  .instruments.length + 2,
                                bits.read(neededModInstrumentIndexBits)
                              ));
                            break;
                          case 1:
                            (instrument.modChannels[mod] =
                              this.pitchChannelCount +
                              clamp(
                                0,
                                this.noiseChannelCount + 1,
                                bits.read(8)
                              )),
                              (instrument.modInstruments[mod] = clamp(
                                0,
                                this.channels[instrument.modChannels[mod]]
                                  .instruments.length + 2,
                                bits.read(neededInstrumentIndexBits)
                              ));
                            break;
                          case 2:
                            instrument.modChannels[mod] = -1;
                            break;
                          case 3:
                            instrument.modChannels[mod] = -2;
                        }
                        if (
                          (3 != status &&
                            (instrument.modulators[mod] = bits.read(6)),
                          jumfive ||
                            ("eq filter" !=
                              Config.modulators[instrument.modulators[mod]]
                                .name &&
                              "note filter" !=
                                Config.modulators[instrument.modulators[mod]]
                                  .name) ||
                            (instrument.modFilterTypes[mod] = bits.read(6)),
                          jumfive && instrument.modChannels[mod] >= 0)
                        ) {
                          let forNoteFilter = effectsIncludeNoteFilter(
                            this.channels[instrument.modChannels[mod]]
                              .instruments[instrument.modInstruments[mod]]
                              .effects
                          );
                          7 == instrument.modulators[mod]
                            ? ((instrument.modulators[mod] = forNoteFilter
                                ? Config.modulators.dictionary["note filt cut"]
                                    .index
                                : Config.modulators.dictionary["eq filt cut"]
                                    .index),
                              (instrument.modFilterTypes[mod] = 1))
                            : 8 == instrument.modulators[mod] &&
                              ((instrument.modulators[mod] = forNoteFilter
                                ? Config.modulators.dictionary["note filt peak"]
                                    .index
                                : Config.modulators.dictionary["eq filt peak"]
                                    .index),
                              (instrument.modFilterTypes[mod] = 2));
                        } else
                          jumfive &&
                            instrument.modulators[mod] ==
                              Config.modulators.dictionary["song reverb"]
                                .index &&
                            ((songReverbChannel = channelIndex),
                            (songReverbInstrument = instrumentIndex),
                            (songReverbIndex = mod));
                        jumfive &&
                          12 !=
                            Config.modulators[instrument.modulators[mod]]
                              .associatedEffect &&
                          (this.channels[
                            instrument.modChannels[mod]
                          ].instruments[
                            instrument.modInstruments[mod]
                          ].effects |=
                            1 <<
                            Config.modulators[instrument.modulators[mod]]
                              .associatedEffect);
                      }
                    }
                  }
                  const detuneScaleNotes = [];
                  for (let j = 0; j < channel.instruments.length; j++) {
                    detuneScaleNotes[j] = [];
                    for (let i = 0; i < Config.modCount; i++)
                      detuneScaleNotes[j][Config.modCount - 1 - i] =
                        1 +
                        3 *
                          +(
                            ((beforeFive && fromJummBox) ||
                              (beforeFour && fromGoldBox)) &&
                            isModChannel &&
                            channel.instruments[j].modulators[i] ==
                              Config.modulators.dictionary.detune.index
                          );
                  }
                  const octaveOffset =
                    isNoiseChannel || isModChannel ? 0 : 12 * channel.octave;
                  let lastPitch =
                    isNoiseChannel || isModChannel ? 4 : octaveOffset;
                  const recentPitches = isModChannel
                      ? [0, 1, 2, 3, 4, 5]
                      : isNoiseChannel
                        ? [4, 6, 7, 2, 3, 8, 0, 10]
                        : [0, 7, 12, 19, 24, -5, -12],
                    recentShapes = [];
                  for (let i = 0; i < recentPitches.length; i++)
                    recentPitches[i] += octaveOffset;
                  for (let i = 0; i < this.patternsPerChannel; i++) {
                    const newPattern = channel.patterns[i];
                    if (
                      (beforeNine && fromBeepBox) ||
                      (beforeFive && fromJummBox) ||
                      (beforeFour && fromGoldBox)
                    )
                      (newPattern.instruments[0] = validateRange(
                        0,
                        channel.instruments.length - 1,
                        bits.read(neededInstrumentIndexBits)
                      )),
                        (newPattern.instruments.length = 1);
                    else if (this.patternInstruments) {
                      const instrumentCount = validateRange(
                        Config.instrumentCountMin,
                        maxInstrumentsPerPattern,
                        bits.read(neededInstrumentCountBits) +
                          Config.instrumentCountMin
                      );
                      for (let j = 0; j < instrumentCount; j++)
                        newPattern.instruments[j] = validateRange(
                          0,
                          channel.instruments.length - 1 + 2 * +isModChannel,
                          bits.read(neededInstrumentIndexBits)
                        );
                      newPattern.instruments.length = instrumentCount;
                    } else
                      (newPattern.instruments[0] = 0),
                        (newPattern.instruments.length =
                          Config.instrumentCountMin);
                    if (!((fromBeepBox && beforeThree) || 0 != bits.read(1))) {
                      newPattern.notes.length = 0;
                      continue;
                    }
                    let curPart = 0;
                    const newNotes = newPattern.notes;
                    let noteCount = 0;
                    for (
                      ;
                      curPart <
                      this.beatsPerBar * Config.partsPerBeat + +isModChannel;

                    ) {
                      const useOldShape = 1 == bits.read(1);
                      let newNote = !1,
                        shapeIndex = 0;
                      if (
                        (useOldShape
                          ? (shapeIndex = validateRange(
                              0,
                              recentShapes.length - 1,
                              bits.readLongTail(0, 0)
                            ))
                          : (newNote = 1 == bits.read(1)),
                        useOldShape || newNote)
                      ) {
                        let shape, note, pitch;
                        if (useOldShape)
                          (shape = recentShapes[shapeIndex]),
                            recentShapes.splice(shapeIndex, 1);
                        else {
                          if (((shape = {}), largerChords))
                            1 == bits.read(1)
                              ? (shape.pitchCount = bits.read(3) + 2)
                              : (shape.pitchCount = 1);
                          else
                            for (
                              shape.pitchCount = 1;
                              shape.pitchCount < 4 && 1 == bits.read(1);

                            )
                              shape.pitchCount++;
                          (shape.pinCount = bits.readPinCount()),
                            (shape.initialSize = fromBeepBox
                              ? 2 * bits.read(2)
                              : isModChannel
                                ? bits.read(9)
                                : bits.read(bitsPerNoteSize)),
                            (shape.pins = []),
                            (shape.length = 0),
                            (shape.bendCount = 0);
                          for (let j = 0; j < shape.pinCount; j++) {
                            let pinObj = {};
                            (pinObj.pitchBend = 1 == bits.read(1)),
                              pinObj.pitchBend && shape.bendCount++,
                              (shape.length +=
                                beforeSeven && fromBeepBox
                                  ? (bits.readLegacyPartDuration() *
                                      Config.partsPerBeat) /
                                    Config.rhythms[this.rhythm].stepsPerBeat
                                  : bits.readPartDuration()),
                              (pinObj.time = shape.length),
                              (pinObj.size = fromBeepBox
                                ? 2 * bits.read(2)
                                : isModChannel
                                  ? bits.read(9)
                                  : bits.read(bitsPerNoteSize)),
                              shape.pins.push(pinObj);
                          }
                        }
                        recentShapes.unshift(shape),
                          recentShapes.length > 10 && recentShapes.pop(),
                          newNotes.length <= noteCount
                            ? ((note = new Note(
                                0,
                                curPart,
                                curPart + shape.length,
                                shape.initialSize
                              )),
                              (newNotes[noteCount++] = note))
                            : ((note = newNotes[noteCount++]),
                              (note.start = curPart),
                              (note.end = curPart + shape.length),
                              (note.pins[0].size = shape.initialSize));
                        let pitchCount = 0;
                        const pitchBends = [];
                        for (
                          let j = 0;
                          j < shape.pitchCount + shape.bendCount;
                          j++
                        ) {
                          const useOldPitch = 1 == bits.read(1);
                          if (useOldPitch) {
                            const pitchIndex = validateRange(
                              0,
                              recentPitches.length - 1,
                              bits.read(recentPitchBitLength)
                            );
                            (pitch = recentPitches[pitchIndex]),
                              recentPitches.splice(pitchIndex, 1);
                          } else {
                            const interval = bits.readPitchInterval();
                            pitch = lastPitch;
                            let intervalIter = interval;
                            for (; intervalIter > 0; ) {
                              for (
                                pitch++;
                                -1 != recentPitches.indexOf(pitch);

                              )
                                pitch++;
                              intervalIter--;
                            }
                            for (; intervalIter < 0; ) {
                              for (
                                pitch--;
                                -1 != recentPitches.indexOf(pitch);

                              )
                                pitch--;
                              intervalIter++;
                            }
                          }
                          recentPitches.unshift(pitch),
                            recentPitches.length > recentPitchLength &&
                              recentPitches.pop(),
                            j < shape.pitchCount
                              ? (note.pitches[pitchCount++] = pitch)
                              : pitchBends.push(pitch),
                            (lastPitch =
                              j == shape.pitchCount - 1
                                ? note.pitches[0]
                                : pitch);
                        }
                        (note.pitches.length = pitchCount),
                          pitchBends.unshift(note.pitches[0]),
                          isModChannel &&
                            (note.pins[0].size *=
                              detuneScaleNotes[newPattern.instruments[0]][
                                note.pitches[0]
                              ]);
                        let pinCount = 1;
                        for (const pinObj of shape.pins) {
                          pinObj.pitchBend && pitchBends.shift();
                          const interval = pitchBends[0] - note.pitches[0];
                          if (note.pins.length <= pinCount)
                            note.pins[pinCount++] = makeNotePin(
                              interval,
                              pinObj.time,
                              isModChannel
                                ? pinObj.size *
                                    detuneScaleNotes[newPattern.instruments[0]][
                                      note.pitches[0]
                                    ]
                                : pinObj.size
                            );
                          else {
                            const pin = note.pins[pinCount++];
                            (pin.interval = interval),
                              (pin.time = pinObj.time),
                              (pin.size = isModChannel
                                ? pinObj.size *
                                  detuneScaleNotes[newPattern.instruments[0]][
                                    note.pitches[0]
                                  ]
                                : pinObj.size);
                          }
                        }
                        (note.pins.length = pinCount),
                          0 == note.start &&
                            (note.continuesLastPattern =
                              (beforeNine && fromBeepBox) ||
                              (beforeFive && fromJummBox) ||
                              (beforeFour && fromGoldBox)
                                ? !(
                                    (beforeFour && !fromUltraBox) ||
                                    fromBeepBox
                                  ) &&
                                  channel.instruments[newPattern.instruments[0]]
                                    .legacyTieOver
                                : 1 == bits.read(1)),
                          (curPart = validateRange(
                            0,
                            this.beatsPerBar * Config.partsPerBeat,
                            note.end
                          ));
                      } else if (isModChannel) {
                        const isBackwards = 1 == bits.read(1),
                          restLength = bits.readPartDuration();
                        isBackwards
                          ? (curPart -= restLength)
                          : (curPart += restLength);
                      } else {
                        const restLength =
                          beforeSeven && fromBeepBox
                            ? (bits.readLegacyPartDuration() *
                                Config.partsPerBeat) /
                              Config.rhythms[this.rhythm].stepsPerBeat
                            : bits.readPartDuration();
                        curPart += restLength;
                      }
                    }
                    newNotes.length = noteCount;
                  }
                  if (beforeThree && fromBeepBox) break;
                  if ((channelIndex++, channelIndex >= this.getChannelCount()))
                    break;
                }
                if (
                  ((fromJummBox && beforeFive) ||
                    (beforeFour && fromGoldBox)) &&
                  songReverbIndex >= 0
                )
                  for (
                    let channelIndex = 0;
                    channelIndex < this.channels.length;
                    channelIndex++
                  )
                    for (
                      let instrumentIndex = 0;
                      instrumentIndex <
                      this.channels[channelIndex].instruments.length;
                      instrumentIndex++
                    ) {
                      const instrument =
                        this.channels[channelIndex].instruments[
                          instrumentIndex
                        ];
                      if (
                        (effectsIncludeReverb(instrument.effects) &&
                          (instrument.reverb = Config.reverbRange - 1),
                        songReverbChannel == channelIndex &&
                          songReverbInstrument == instrumentIndex)
                      ) {
                        const patternIndex =
                          this.channels[channelIndex].bars[0];
                        if (patternIndex > 0) {
                          const pattern =
                            this.channels[channelIndex].patterns[
                              patternIndex - 1
                            ];
                          let lowestPart = 6;
                          for (const note of pattern.notes)
                            note.pitches[0] ==
                              Config.modCount - 1 - songReverbIndex &&
                              (lowestPart = Math.min(lowestPart, note.start));
                          lowestPart > 0 &&
                            pattern.notes.push(
                              new Note(
                                Config.modCount - 1 - songReverbIndex,
                                0,
                                lowestPart,
                                legacyGlobalReverb
                              )
                            );
                        } else if (
                          this.channels[channelIndex].patterns.length <
                          Config.barCountMax
                        ) {
                          const pattern = new Pattern();
                          if (
                            (this.channels[channelIndex].patterns.push(pattern),
                            (this.channels[channelIndex].bars[0] =
                              this.channels[channelIndex].patterns.length),
                            this.channels[channelIndex].patterns.length >
                              this.patternsPerChannel)
                          ) {
                            for (let chn = 0; chn < this.channels.length; chn++)
                              this.channels[chn].patterns.length <=
                                this.patternsPerChannel &&
                                this.channels[chn].patterns.push(new Pattern());
                            this.patternsPerChannel++;
                          }
                          (pattern.instruments.length = 1),
                            (pattern.instruments[0] = songReverbInstrument),
                            (pattern.notes.length = 0),
                            pattern.notes.push(
                              new Note(
                                Config.modCount - 1 - songReverbIndex,
                                0,
                                6,
                                legacyGlobalReverb
                              )
                            );
                        }
                      }
                    }
              }
              break;
            default:
              throw new Error(
                "Unrecognized song tag code " +
                  String.fromCharCode(command) +
                  " at index " +
                  (charIndex - 1) +
                  " " +
                  compressed.substring(0, charIndex)
              );
          }
        Config.willReloadForCustomSamples &&
          ((window.location.hash = this.toBase64String()),
          setTimeout(() => {
            location.reload();
          }, 50));
      }
      static _isProperUrl(string) {
        try {
          return OFFLINE ? Boolean(string) : Boolean(new URL(string));
        } catch (x) {
          return !1;
        }
      }
      static _parseAndConfigureCustomSample(
        url,
        customSampleUrls,
        customSamplePresets,
        sampleLoadingState,
        parseOldSyntax
      ) {
        const defaultIndex = 0,
          defaultIntegratedSamples = Config.chipWaves[0].samples,
          defaultSamples = Config.rawRawChipWaves[0].samples,
          customSampleUrlIndex = customSampleUrls.length;
        customSampleUrls.push(url);
        const chipWaveIndex = Config.chipWaves.length;
        let urlSliced = url,
          customSampleRate = 44100,
          isCustomPercussive = !1,
          customRootKey = 60,
          presetIsUsingAdvancedLoopControls = !1,
          presetChipWaveLoopStart = null,
          presetChipWaveLoopEnd = null,
          presetChipWaveStartOffset = null,
          presetChipWaveLoopMode = null,
          presetChipWavePlayBackwards = !1,
          parsedSampleOptions = !1,
          optionsStartIndex = url.indexOf("!"),
          optionsEndIndex = -1;
        if (
          0 === optionsStartIndex &&
          ((optionsEndIndex = url.indexOf("!", optionsStartIndex + 1)),
          -1 !== optionsEndIndex)
        ) {
          const rawOptions = url
            .slice(optionsStartIndex + 1, optionsEndIndex)
            .split(",");
          for (const rawOption of rawOptions) {
            const optionCode = rawOption.charAt(0),
              optionData = rawOption.slice(1, rawOption.length);
            "s" === optionCode
              ? (customSampleRate = clamp(
                  8e3,
                  96001,
                  parseFloatWithDefault(optionData, 44100)
                ))
              : "r" === optionCode
                ? (customRootKey = parseFloatWithDefault(optionData, 60))
                : "p" === optionCode
                  ? (isCustomPercussive = !0)
                  : "a" === optionCode
                    ? ((presetChipWaveLoopStart = parseIntWithDefault(
                        optionData,
                        null
                      )),
                      null != presetChipWaveLoopStart &&
                        (presetIsUsingAdvancedLoopControls = !0))
                    : "b" === optionCode
                      ? ((presetChipWaveLoopEnd = parseIntWithDefault(
                          optionData,
                          null
                        )),
                        null != presetChipWaveLoopEnd &&
                          (presetIsUsingAdvancedLoopControls = !0))
                      : "c" === optionCode
                        ? ((presetChipWaveStartOffset = parseIntWithDefault(
                            optionData,
                            null
                          )),
                          null != presetChipWaveStartOffset &&
                            (presetIsUsingAdvancedLoopControls = !0))
                        : "d" === optionCode
                          ? ((presetChipWaveLoopMode = parseIntWithDefault(
                              optionData,
                              null
                            )),
                            null != presetChipWaveLoopMode &&
                              ((presetChipWaveLoopMode = clamp(
                                0,
                                4,
                                presetChipWaveLoopMode
                              )),
                              (presetIsUsingAdvancedLoopControls = !0)))
                          : "e" === optionCode &&
                            ((presetChipWavePlayBackwards = !0),
                            (presetIsUsingAdvancedLoopControls = !0));
          }
          (urlSliced = url.slice(optionsEndIndex + 1, url.length)),
            (parsedSampleOptions = !0);
        }
        let parsedUrl = null;
        if (!Song._isProperUrl(urlSliced))
          return alert(url + " is not a valid url"), !1;
        if (
          ((parsedUrl = OFFLINE ? urlSliced : new URL(urlSliced)),
          parseOldSyntax && !parsedSampleOptions && null != parsedUrl)
        ) {
          function sliceForSampleRate() {
            (urlSliced = url.slice(0, url.indexOf(","))),
              (parsedUrl = OFFLINE ? urlSliced : new URL(urlSliced)),
              (customSampleRate = clamp(
                8e3,
                96001,
                parseFloatWithDefault(url.slice(url.indexOf(",") + 1), 44100)
              ));
          }
          function sliceForRootKey() {
            (urlSliced = url.slice(0, url.indexOf("!"))),
              (parsedUrl = OFFLINE ? urlSliced : new URL(urlSliced)),
              (customRootKey = parseFloatWithDefault(
                url.slice(url.indexOf("!") + 1),
                60
              ));
          }
          -1 != url.indexOf("@") &&
            ((urlSliced = url.replaceAll("@", "")),
            (parsedUrl = OFFLINE ? urlSliced : new URL(urlSliced)),
            (isCustomPercussive = !0)),
            -1 != url.indexOf(",") && -1 != url.indexOf("!")
              ? url.indexOf(",") < url.indexOf("!")
                ? (sliceForRootKey(), sliceForSampleRate())
                : (sliceForSampleRate(), sliceForRootKey())
              : (-1 != url.indexOf(",") && sliceForSampleRate(),
                -1 != url.indexOf("!") && sliceForRootKey());
        }
        if (null != parsedUrl) {
          let urlWithNamedOptions = urlSliced;
          const namedOptions = [];
          let name;
          44100 !== customSampleRate &&
            namedOptions.push("s" + customSampleRate),
            60 !== customRootKey && namedOptions.push("r" + customRootKey),
            isCustomPercussive && namedOptions.push("p"),
            presetIsUsingAdvancedLoopControls &&
              (null != presetChipWaveLoopStart &&
                namedOptions.push("a" + presetChipWaveLoopStart),
              null != presetChipWaveLoopEnd &&
                namedOptions.push("b" + presetChipWaveLoopEnd),
              null != presetChipWaveStartOffset &&
                namedOptions.push("c" + presetChipWaveStartOffset),
              null != presetChipWaveLoopMode &&
                namedOptions.push("d" + presetChipWaveLoopMode),
              presetChipWavePlayBackwards && namedOptions.push("e")),
            namedOptions.length > 0 &&
              (urlWithNamedOptions =
                "!" + namedOptions.join(",") + "!" + urlSliced),
            (customSampleUrls[customSampleUrlIndex] = urlWithNamedOptions),
            (name = OFFLINE
              ? decodeURIComponent(parsedUrl.replace(/^([^\/]*\/)+/, ""))
              : decodeURIComponent(
                  parsedUrl.pathname.replace(/^([^\/]*\/)+/, "")
                ));
          const expression = 1;
          (Config.chipWaves[chipWaveIndex] = {
            name: name,
            expression: expression,
            isCustomSampled: !0,
            isPercussion: isCustomPercussive,
            rootKey: customRootKey,
            sampleRate: customSampleRate,
            samples: defaultIntegratedSamples,
            index: chipWaveIndex,
          }),
            (Config.rawChipWaves[chipWaveIndex] = {
              name: name,
              expression: expression,
              isCustomSampled: !0,
              isPercussion: isCustomPercussive,
              rootKey: customRootKey,
              sampleRate: customSampleRate,
              samples: defaultSamples,
              index: chipWaveIndex,
            }),
            (Config.rawRawChipWaves[chipWaveIndex] = {
              name: name,
              expression: expression,
              isCustomSampled: !0,
              isPercussion: isCustomPercussive,
              rootKey: customRootKey,
              sampleRate: customSampleRate,
              samples: defaultSamples,
              index: chipWaveIndex,
            });
          const customSamplePresetSettings = {
            type: "chip",
            eqFilter: [],
            effects: [],
            transition: "normal",
            fadeInSeconds: 0,
            fadeOutTicks: -3,
            chord: "harmony",
            wave: name,
            unison: "none",
            envelopes: [],
          };
          presetIsUsingAdvancedLoopControls &&
            ((customSamplePresetSettings.isUsingAdvancedLoopControls = !0),
            (customSamplePresetSettings.chipWaveLoopStart =
              null != presetChipWaveLoopStart ? presetChipWaveLoopStart : 0),
            (customSamplePresetSettings.chipWaveLoopEnd =
              null != presetChipWaveLoopEnd ? presetChipWaveLoopEnd : 2),
            (customSamplePresetSettings.chipWaveLoopMode =
              null != presetChipWaveLoopMode ? presetChipWaveLoopMode : 0),
            (customSamplePresetSettings.chipWavePlayBackwards =
              presetChipWavePlayBackwards),
            (customSamplePresetSettings.chipWaveStartOffset =
              null != presetChipWaveStartOffset
                ? presetChipWaveStartOffset
                : 0));
          const customSamplePreset = {
            index: 0,
            name: name,
            midiProgram: 80,
            settings: customSamplePresetSettings,
          };
          if (
            (customSamplePresets.push(customSamplePreset),
            !Config.willReloadForCustomSamples)
          ) {
            const rawLoopOptions = {
              isUsingAdvancedLoopControls: presetIsUsingAdvancedLoopControls,
              chipWaveLoopStart: presetChipWaveLoopStart,
              chipWaveLoopEnd: presetChipWaveLoopEnd,
              chipWaveLoopMode: presetChipWaveLoopMode,
              chipWavePlayBackwards: presetChipWavePlayBackwards,
              chipWaveStartOffset: presetChipWaveStartOffset,
            };
            startLoadingSample(
              urlSliced,
              chipWaveIndex,
              customSamplePresetSettings,
              rawLoopOptions,
              customSampleRate
            );
          }
          (sampleLoadingState.statusTable[chipWaveIndex] = 0),
            (sampleLoadingState.urlTable[chipWaveIndex] = urlSliced),
            sampleLoadingState.totalSamples++;
        }
        return !0;
      }
      static _restoreChipWaveListToDefault() {
        (Config.chipWaves = toNameMap(
          Config.chipWaves.slice(0, Config.firstIndexForSamplesInChipWaveList)
        )),
          (Config.rawChipWaves = toNameMap(
            Config.rawChipWaves.slice(
              0,
              Config.firstIndexForSamplesInChipWaveList
            )
          )),
          (Config.rawRawChipWaves = toNameMap(
            Config.rawRawChipWaves.slice(
              0,
              Config.firstIndexForSamplesInChipWaveList
            )
          ));
      }
      static _clearSamples() {
        (EditorConfig.customSamples = null),
          Song._restoreChipWaveListToDefault(),
          (sampleLoadingState.statusTable = {}),
          (sampleLoadingState.urlTable = {}),
          (sampleLoadingState.totalSamples = 0),
          (sampleLoadingState.samplesLoaded = 0),
          sampleLoadEvents.dispatchEvent(
            new SampleLoadedEvent(
              sampleLoadingState.totalSamples,
              sampleLoadingState.samplesLoaded
            )
          );
      }
      toJsonObject(enableIntro = !0, loopCount = 1, enableOutro = !0) {
        const channelArray = [];
        for (
          let channelIndex = 0;
          channelIndex < this.getChannelCount();
          channelIndex++
        ) {
          const channel = this.channels[channelIndex],
            instrumentArray = [],
            isNoiseChannel = this.getChannelIsNoise(channelIndex),
            isModChannel = this.getChannelIsMod(channelIndex);
          for (const instrument of channel.instruments)
            instrumentArray.push(instrument.toJsonObject());
          const patternArray = [];
          for (const pattern of channel.patterns)
            patternArray.push(
              pattern.toJsonObject(this, channel, isModChannel)
            );
          const sequenceArray = [];
          if (enableIntro)
            for (let i = 0; i < this.loopStart; i++)
              sequenceArray.push(channel.bars[i]);
          for (let l = 0; l < loopCount; l++)
            for (
              let i = this.loopStart;
              i < this.loopStart + this.loopLength;
              i++
            )
              sequenceArray.push(channel.bars[i]);
          if (enableOutro)
            for (
              let i = this.loopStart + this.loopLength;
              i < this.barCount;
              i++
            )
              sequenceArray.push(channel.bars[i]);
          const channelObject = {
            type: isModChannel ? "mod" : isNoiseChannel ? "drum" : "pitch",
            name: channel.name,
            instruments: instrumentArray,
            patterns: patternArray,
            sequence: sequenceArray,
          };
          isNoiseChannel ||
            (channelObject.octaveScrollBar = channel.octave - 1),
            channelArray.push(channelObject);
        }
        const result = {
          name: this.title,
          format: Song._format,
          version: Song._latestUltraBoxVersion,
          scale: Config.scales[this.scale].name,
          customScale: this.scaleCustom,
          key: Config.keys[this.key].name,
          keyOctave: this.octave,
          introBars: this.loopStart,
          loopBars: this.loopLength,
          beatsPerBar: this.beatsPerBar,
          ticksPerBeat: Config.rhythms[this.rhythm].stepsPerBeat,
          beatsPerMinute: this.tempo,
          reverb: this.reverb,
          masterGain: this.masterGain,
          compressionThreshold: this.compressionThreshold,
          limitThreshold: this.limitThreshold,
          limitDecay: this.limitDecay,
          limitRise: this.limitRise,
          limitRatio: this.limitRatio,
          compressionRatio: this.compressionRatio,
          layeredInstruments: this.layeredInstruments,
          patternInstruments: this.patternInstruments,
          channels: channelArray,
        };
        return (
          null != EditorConfig.customSamples &&
            EditorConfig.customSamples.length > 0 &&
            (result.customSamples = EditorConfig.customSamples),
          result
        );
      }
      fromJsonObject(jsonObject, jsonFormat = "auto") {
        if ((this.initToDefault(!0), !jsonObject)) return;
        const format = "auto" == jsonFormat ? jsonObject.format : jsonFormat;
        if (
          (null != jsonObject.name && (this.title = jsonObject.name),
          null != jsonObject.customSamples)
        ) {
          const customSamples = jsonObject.customSamples;
          if (
            null == EditorConfig.customSamples ||
            EditorConfig.customSamples.join(", ") != customSamples.join(", ")
          ) {
            (Config.willReloadForCustomSamples = !0),
              Song._restoreChipWaveListToDefault();
            let willLoadLegacySamples = !1,
              willLoadNintariboxSamples = !1,
              willLoadMarioPaintboxSamples = !1;
            const customSampleUrls = [],
              customSamplePresets = [];
            for (const url of customSamples)
              if ("legacysamples" === url.toLowerCase())
                willLoadLegacySamples ||
                  ((willLoadLegacySamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(0));
              else if ("nintariboxsamples" === url.toLowerCase())
                willLoadNintariboxSamples ||
                  ((willLoadNintariboxSamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(1));
              else if ("mariopaintboxsamples" === url.toLowerCase())
                willLoadMarioPaintboxSamples ||
                  ((willLoadMarioPaintboxSamples = !0),
                  customSampleUrls.push(url),
                  loadBuiltInSamples(2));
              else {
                const parseOldSyntax = !1;
                Song._parseAndConfigureCustomSample(
                  url,
                  customSampleUrls,
                  customSamplePresets,
                  sampleLoadingState,
                  parseOldSyntax
                );
              }
            if (
              (customSampleUrls.length > 0 &&
                (EditorConfig.customSamples = customSampleUrls),
              customSamplePresets.length > 0)
            ) {
              const customSamplePresetsMap = toNameMap(customSamplePresets);
              EditorConfig.presetCategories[
                EditorConfig.presetCategories.length
              ] = {
                name: "Custom Sample Presets",
                presets: customSamplePresetsMap,
                index: EditorConfig.presetCategories.length,
              };
            }
          }
        } else {
          let shouldLoadLegacySamples = !1;
          if (null != jsonObject.channels)
            for (
              let channelIndex = 0;
              channelIndex < jsonObject.channels.length;
              channelIndex++
            ) {
              const channelObject = jsonObject.channels[channelIndex];
              if (
                "pitch" === channelObject.type &&
                Array.isArray(channelObject.instruments)
              ) {
                const instrumentObjects = channelObject.instruments;
                for (let i = 0; i < instrumentObjects.length; i++) {
                  const instrumentObject = instrumentObjects[i];
                  if ("chip" !== instrumentObject.type) continue;
                  if (null == instrumentObject.wave) continue;
                  const waveName = instrumentObject.wave,
                    names = [
                      "paandorasbox kick",
                      "paandorasbox snare",
                      "paandorasbox piano1",
                      "paandorasbox WOW",
                      "paandorasbox overdrive",
                      "paandorasbox trumpet",
                      "paandorasbox saxophone",
                      "paandorasbox orchestrahit",
                      "paandorasbox detatched violin",
                      "paandorasbox synth",
                      "paandorasbox sonic3snare",
                      "paandorasbox come on",
                      "paandorasbox choir",
                      "paandorasbox overdriveguitar",
                      "paandorasbox flute",
                      "paandorasbox legato violin",
                      "paandorasbox tremolo violin",
                      "paandorasbox amen break",
                      "paandorasbox pizzicato violin",
                      "paandorasbox tim allen grunt",
                      "paandorasbox tuba",
                      "paandorasbox loopingcymbal",
                      "paandorasbox standardkick",
                      "paandorasbox standardsnare",
                      "paandorasbox closedhihat",
                      "paandorasbox foothihat",
                      "paandorasbox openhihat",
                      "paandorasbox crashcymbal",
                      "paandorasbox pianoC4",
                      "paandorasbox liver pad",
                      "paandorasbox marimba",
                      "paandorasbox susdotwav",
                      "paandorasbox wackyboxtts",
                      "paandorasbox peppersteak_1",
                      "paandorasbox peppersteak_2",
                      "paandorasbox vinyl_noise",
                      "paandorasbeta slap bass",
                      "paandorasbeta HD EB overdrive guitar",
                      "paandorasbeta sunsoft bass",
                      "paandorasbeta masculine choir",
                      "paandorasbeta feminine choir",
                      "paandorasbeta tololoche",
                      "paandorasbeta harp",
                      "paandorasbeta pan flute",
                      "paandorasbeta krumhorn",
                      "paandorasbeta timpani",
                      "paandorasbeta crowd hey",
                      "paandorasbeta wario land 4 brass",
                      "paandorasbeta wario land 4 rock organ",
                      "paandorasbeta wario land 4 DAOW",
                      "paandorasbeta wario land 4 hour chime",
                      "paandorasbeta wario land 4 tick",
                      "paandorasbeta kirby kick",
                      "paandorasbeta kirby snare",
                      "paandorasbeta kirby bongo",
                      "paandorasbeta kirby click",
                      "paandorasbeta sonor kick",
                      "paandorasbeta sonor snare",
                      "paandorasbeta sonor snare (left hand)",
                      "paandorasbeta sonor snare (right hand)",
                      "paandorasbeta sonor high tom",
                      "paandorasbeta sonor low tom",
                      "paandorasbeta sonor hihat (closed)",
                      "paandorasbeta sonor hihat (half opened)",
                      "paandorasbeta sonor hihat (open)",
                      "paandorasbeta sonor hihat (open tip)",
                      "paandorasbeta sonor hihat (pedal)",
                      "paandorasbeta sonor crash",
                      "paandorasbeta sonor crash (tip)",
                      "paandorasbeta sonor ride",
                    ],
                    oldNames = [
                      "pandoraasbox kick",
                      "pandoraasbox snare",
                      "pandoraasbox piano1",
                      "pandoraasbox WOW",
                      "pandoraasbox overdrive",
                      "pandoraasbox trumpet",
                      "pandoraasbox saxophone",
                      "pandoraasbox orchestrahit",
                      "pandoraasbox detatched violin",
                      "pandoraasbox synth",
                      "pandoraasbox sonic3snare",
                      "pandoraasbox come on",
                      "pandoraasbox choir",
                      "pandoraasbox overdriveguitar",
                      "pandoraasbox flute",
                      "pandoraasbox legato violin",
                      "pandoraasbox tremolo violin",
                      "pandoraasbox amen break",
                      "pandoraasbox pizzicato violin",
                      "pandoraasbox tim allen grunt",
                      "pandoraasbox tuba",
                      "pandoraasbox loopingcymbal",
                      "pandoraasbox standardkick",
                      "pandoraasbox standardsnare",
                      "pandoraasbox closedhihat",
                      "pandoraasbox foothihat",
                      "pandoraasbox openhihat",
                      "pandoraasbox crashcymbal",
                      "pandoraasbox pianoC4",
                      "pandoraasbox liver pad",
                      "pandoraasbox marimba",
                      "pandoraasbox susdotwav",
                      "pandoraasbox wackyboxtts",
                      "pandoraasbox peppersteak_1",
                      "pandoraasbox peppersteak_2",
                      "pandoraasbox vinyl_noise",
                      "pandoraasbeta slap bass",
                      "pandoraasbeta HD EB overdrive guitar",
                      "pandoraasbeta sunsoft bass",
                      "pandoraasbeta masculine choir",
                      "pandoraasbeta feminine choir",
                      "pandoraasbeta tololoche",
                      "pandoraasbeta harp",
                      "pandoraasbeta pan flute",
                      "pandoraasbeta krumhorn",
                      "pandoraasbeta timpani",
                      "pandoraasbeta crowd hey",
                      "pandoraasbeta wario land 4 brass",
                      "pandoraasbeta wario land 4 rock organ",
                      "pandoraasbeta wario land 4 DAOW",
                      "pandoraasbeta wario land 4 hour chime",
                      "pandoraasbeta wario land 4 tick",
                      "pandoraasbeta kirby kick",
                      "pandoraasbeta kirby snare",
                      "pandoraasbeta kirby bongo",
                      "pandoraasbeta kirby click",
                      "pandoraasbeta sonor kick",
                      "pandoraasbeta sonor snare",
                      "pandoraasbeta sonor snare (left hand)",
                      "pandoraasbeta sonor snare (right hand)",
                      "pandoraasbeta sonor high tom",
                      "pandoraasbeta sonor low tom",
                      "pandoraasbeta sonor hihat (closed)",
                      "pandoraasbeta sonor hihat (half opened)",
                      "pandoraasbeta sonor hihat (open)",
                      "pandoraasbeta sonor hihat (open tip)",
                      "pandoraasbeta sonor hihat (pedal)",
                      "pandoraasbeta sonor crash",
                      "pandoraasbeta sonor crash (tip)",
                      "pandoraasbeta sonor ride",
                    ],
                    veryOldNames = [
                      "kick",
                      "snare",
                      "piano1",
                      "WOW",
                      "overdrive",
                      "trumpet",
                      "saxophone",
                      "orchestrahit",
                      "detatched violin",
                      "synth",
                      "sonic3snare",
                      "come on",
                      "choir",
                      "overdriveguitar",
                      "flute",
                      "legato violin",
                      "tremolo violin",
                      "amen break",
                      "pizzicato violin",
                      "tim allen grunt",
                      "tuba",
                      "loopingcymbal",
                      "standardkick",
                      "standardsnare",
                      "closedhihat",
                      "foothihat",
                      "openhihat",
                      "crashcymbal",
                      "pianoC4",
                      "liver pad",
                      "marimba",
                      "susdotwav",
                      "wackyboxtts",
                    ];
                  names.includes(waveName)
                    ? (shouldLoadLegacySamples = !0)
                    : oldNames.includes(waveName)
                      ? ((shouldLoadLegacySamples = !0),
                        (instrumentObject.wave =
                          names[oldNames.findIndex((x) => x === waveName)]))
                      : veryOldNames.includes(waveName) &&
                        ("trumpet" === waveName ||
                          "flute" === waveName ||
                          ((shouldLoadLegacySamples = !0),
                          (instrumentObject.wave =
                            names[
                              veryOldNames.findIndex((x) => x === waveName)
                            ])));
                }
              }
            }
          shouldLoadLegacySamples
            ? ((Config.willReloadForCustomSamples = !0),
              Song._restoreChipWaveListToDefault(),
              loadBuiltInSamples(0),
              (EditorConfig.customSamples = ["legacySamples"]))
            : null != EditorConfig.customSamples &&
              EditorConfig.customSamples.length > 0 &&
              ((Config.willReloadForCustomSamples = !0), Song._clearSamples());
        }
        if (((this.scale = 0), null != jsonObject.scale)) {
          const oldScaleNames = {
              "romani :)": "double harmonic :)",
              "romani :(": "double harmonic :(",
              "dbl harmonic :)": "double harmonic :)",
              "dbl harmonic :(": "double harmonic :(",
              enigma: "strange",
            },
            scaleName =
              null != oldScaleNames[jsonObject.scale]
                ? oldScaleNames[jsonObject.scale]
                : jsonObject.scale,
            scale = Config.scales.findIndex((scale) => scale.name == scaleName);
          if (
            (-1 != scale && (this.scale = scale),
            this.scale == Config.scales.dictionary.Custom.index &&
              null != jsonObject.customScale)
          )
            for (var i of jsonObject.customScale.keys())
              this.scaleCustom[i] = jsonObject.customScale[i];
        }
        if (null != jsonObject.key)
          if ("number" == typeof jsonObject.key)
            this.key = ((jsonObject.key + 1200) >>> 0) % Config.keys.length;
          else if ("string" == typeof jsonObject.key) {
            const key = jsonObject.key;
            if ("C+" === key) (this.key = 0), (this.octave = 1);
            else if ("G- (actually F#-)" === key)
              (this.key = 6), (this.octave = -1);
            else if ("C-" === key) (this.key = 0), (this.octave = -1);
            else if ("oh no (F-)" === key) (this.key = 5), (this.octave = -1);
            else {
              const letter = key.charAt(0).toUpperCase(),
                symbol = key.charAt(1).toLowerCase(),
                letterMap = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 },
                accidentalMap = { "#": 1, "♯": 1, b: -1, "♭": -1 };
              let index = letterMap[letter];
              const offset = accidentalMap[symbol];
              null != index &&
                (null != offset && (index += offset),
                index < 0 && (index += 12),
                (index %= 12),
                (this.key = index));
            }
          }
        null != jsonObject.beatsPerMinute &&
          (this.tempo = clamp(
            Config.tempoMin,
            Config.tempoMax + 1,
            0 | jsonObject.beatsPerMinute
          )),
          null != jsonObject.keyOctave &&
            (this.octave = clamp(
              Config.octaveMin,
              Config.octaveMax + 1,
              0 | jsonObject.keyOctave
            ));
        let legacyGlobalReverb = 0;
        null != jsonObject.reverb &&
          (legacyGlobalReverb = clamp(0, 32, 0 | jsonObject.reverb)),
          null != jsonObject.beatsPerBar &&
            (this.beatsPerBar = Math.max(
              Config.beatsPerBarMin,
              Math.min(Config.beatsPerBarMax, 0 | jsonObject.beatsPerBar)
            ));
        let importedPartsPerBeat = 4;
        null != jsonObject.ticksPerBeat &&
          ((importedPartsPerBeat = 0 | jsonObject.ticksPerBeat || 4),
          (this.rhythm = Config.rhythms.findIndex(
            (rhythm) => rhythm.stepsPerBeat == importedPartsPerBeat
          )),
          -1 == this.rhythm && (this.rhythm = 1)),
          null != jsonObject.masterGain
            ? (this.masterGain = Math.max(
                0,
                Math.min(5, jsonObject.masterGain || 0)
              ))
            : (this.masterGain = 1),
          null != jsonObject.limitThreshold
            ? (this.limitThreshold = Math.max(
                0,
                Math.min(2, jsonObject.limitThreshold || 0)
              ))
            : (this.limitThreshold = 1),
          null != jsonObject.compressionThreshold
            ? (this.compressionThreshold = Math.max(
                0,
                Math.min(1.1, jsonObject.compressionThreshold || 0)
              ))
            : (this.compressionThreshold = 1),
          null != jsonObject.limitRise
            ? (this.limitRise = Math.max(
                2e3,
                Math.min(1e4, jsonObject.limitRise || 0)
              ))
            : (this.limitRise = 4e3),
          null != jsonObject.limitDecay
            ? (this.limitDecay = Math.max(
                1,
                Math.min(30, jsonObject.limitDecay || 0)
              ))
            : (this.limitDecay = 4),
          null != jsonObject.limitRatio
            ? (this.limitRatio = Math.max(
                0,
                Math.min(11, jsonObject.limitRatio || 0)
              ))
            : (this.limitRatio = 1),
          null != jsonObject.compressionRatio
            ? (this.compressionRatio = Math.max(
                0,
                Math.min(1.168, jsonObject.compressionRatio || 0)
              ))
            : (this.compressionRatio = 1);
        let maxInstruments = 1,
          maxPatterns = 1,
          maxBars = 1;
        if (null != jsonObject.channels)
          for (const channelObject of jsonObject.channels)
            channelObject.instruments &&
              (maxInstruments = Math.max(
                maxInstruments,
                0 | channelObject.instruments.length
              )),
              channelObject.patterns &&
                (maxPatterns = Math.max(
                  maxPatterns,
                  0 | channelObject.patterns.length
                )),
              channelObject.sequence &&
                (maxBars = Math.max(
                  maxBars,
                  0 | channelObject.sequence.length
                ));
        null != jsonObject.layeredInstruments
          ? (this.layeredInstruments = !!jsonObject.layeredInstruments)
          : (this.layeredInstruments = !1),
          null != jsonObject.patternInstruments
            ? (this.patternInstruments = !!jsonObject.patternInstruments)
            : (this.patternInstruments = maxInstruments > 1),
          (this.patternsPerChannel = Math.min(maxPatterns, Config.barCountMax)),
          (this.barCount = Math.min(maxBars, Config.barCountMax)),
          null != jsonObject.introBars &&
            (this.loopStart = clamp(
              0,
              this.barCount,
              0 | jsonObject.introBars
            )),
          null != jsonObject.loopBars &&
            (this.loopLength = clamp(
              1,
              this.barCount - this.loopStart + 1,
              0 | jsonObject.loopBars
            ));
        const newPitchChannels = [],
          newNoiseChannels = [],
          newModChannels = [];
        if (null != jsonObject.channels)
          for (
            let channelIndex = 0;
            channelIndex < jsonObject.channels.length;
            channelIndex++
          ) {
            let channelObject = jsonObject.channels[channelIndex];
            const channel = new Channel();
            let isNoiseChannel = !1,
              isModChannel = !1;
            if (
              (null != channelObject.type
                ? ((isNoiseChannel = "drum" == channelObject.type),
                  (isModChannel = "mod" == channelObject.type))
                : (isNoiseChannel = channelIndex >= 3),
              isNoiseChannel
                ? newNoiseChannels.push(channel)
                : isModChannel
                  ? newModChannels.push(channel)
                  : newPitchChannels.push(channel),
              null != channelObject.octaveScrollBar &&
                ((channel.octave = clamp(
                  0,
                  Config.pitchOctaves,
                  1 + (0 | channelObject.octaveScrollBar)
                )),
                isNoiseChannel && (channel.octave = 0)),
              null != channelObject.name
                ? (channel.name = channelObject.name)
                : (channel.name = ""),
              Array.isArray(channelObject.instruments))
            ) {
              const instrumentObjects = channelObject.instruments;
              for (
                let i = 0;
                i < instrumentObjects.length &&
                !(i >= this.getMaxInstrumentsPerChannel());
                i++
              ) {
                const instrument = new Instrument(isNoiseChannel, isModChannel);
                (channel.instruments[i] = instrument),
                  instrument.fromJsonObject(
                    instrumentObjects[i],
                    isNoiseChannel,
                    isModChannel,
                    !1,
                    !1,
                    legacyGlobalReverb,
                    format
                  );
              }
            }
            for (let i = 0; i < this.patternsPerChannel; i++) {
              const pattern = new Pattern();
              channel.patterns[i] = pattern;
              let patternObject = void 0;
              channelObject.patterns &&
                (patternObject = channelObject.patterns[i]),
                null != patternObject &&
                  pattern.fromJsonObject(
                    patternObject,
                    this,
                    channel,
                    importedPartsPerBeat,
                    isNoiseChannel,
                    isModChannel
                  );
            }
            channel.patterns.length = this.patternsPerChannel;
            for (let i = 0; i < this.barCount; i++)
              channel.bars[i] =
                null != channelObject.sequence
                  ? Math.min(
                      this.patternsPerChannel,
                      channelObject.sequence[i] >>> 0
                    )
                  : 0;
            channel.bars.length = this.barCount;
          }
        newPitchChannels.length > Config.pitchChannelCountMax &&
          (newPitchChannels.length = Config.pitchChannelCountMax),
          newNoiseChannels.length > Config.noiseChannelCountMax &&
            (newNoiseChannels.length = Config.noiseChannelCountMax),
          newModChannels.length > Config.modChannelCountMax &&
            (newModChannels.length = Config.modChannelCountMax),
          (this.pitchChannelCount = newPitchChannels.length),
          (this.noiseChannelCount = newNoiseChannels.length),
          (this.modChannelCount = newModChannels.length),
          (this.channels.length = 0),
          Array.prototype.push.apply(this.channels, newPitchChannels),
          Array.prototype.push.apply(this.channels, newNoiseChannels),
          Array.prototype.push.apply(this.channels, newModChannels),
          Config.willReloadForCustomSamples &&
            ((window.location.hash = this.toBase64String()),
            setTimeout(() => {
              location.reload();
            }, 50));
      }
      getPattern(channelIndex, bar) {
        if (bar < 0 || bar >= this.barCount) return null;
        const patternIndex = this.channels[channelIndex].bars[bar];
        return 0 == patternIndex
          ? null
          : this.channels[channelIndex].patterns[patternIndex - 1];
      }
      getBeatsPerMinute() {
        return this.tempo;
      }
      static getNeededBits(maxValue) {
        return 32 - Math.clz32(Math.ceil(maxValue + 1) - 1);
      }
      restoreLimiterDefaults() {
        (this.compressionRatio = 1),
          (this.limitRatio = 1),
          (this.limitRise = 4e3),
          (this.limitDecay = 4),
          (this.limitThreshold = 1),
          (this.compressionThreshold = 1),
          (this.masterGain = 1);
      }
    }
    (Song._format = Config.jsonFormat),
      (Song._oldestBeepboxVersion = 2),
      (Song._latestBeepboxVersion = 9),
      (Song._oldestJummBoxVersion = 1),
      (Song._latestJummBoxVersion = 6),
      (Song._oldestGoldBoxVersion = 1),
      (Song._latestGoldBoxVersion = 4),
      (Song._oldestUltraBoxVersion = 1),
      (Song._latestUltraBoxVersion = 5),
      (Song._variant = 117);
    class PickedString {
      constructor() {
        (this.delayLine = null),
          (this.allPassG = 0),
          (this.allPassGDelta = 0),
          (this.sustainFilterA1 = 0),
          (this.sustainFilterA1Delta = 0),
          (this.sustainFilterA2 = 0),
          (this.sustainFilterA2Delta = 0),
          (this.sustainFilterB0 = 0),
          (this.sustainFilterB0Delta = 0),
          (this.sustainFilterB1 = 0),
          (this.sustainFilterB1Delta = 0),
          (this.sustainFilterB2 = 0),
          (this.sustainFilterB2Delta = 0),
          this.reset();
      }
      reset() {
        (this.delayIndex = -1),
          (this.allPassSample = 0),
          (this.allPassPrevInput = 0),
          (this.sustainFilterSample = 0),
          (this.sustainFilterPrevOutput2 = 0),
          (this.sustainFilterPrevInput1 = 0),
          (this.sustainFilterPrevInput2 = 0),
          (this.fractionalDelaySample = 0),
          (this.prevDelayLength = -1),
          (this.delayResetOffset = 0);
      }
      update(
        synth,
        instrumentState,
        tone,
        stringIndex,
        roundedSamplesPerTick,
        stringDecayStart,
        stringDecayEnd,
        sustainType
      ) {
        const allPassCenter =
            (2 * Math.PI * Config.pickedStringDispersionCenterFreq) /
            synth.samplesPerSecond,
          prevDelayLength = this.prevDelayLength,
          phaseDeltaStart = tone.phaseDeltas[stringIndex],
          phaseDeltaScale = tone.phaseDeltaScales[stringIndex],
          phaseDeltaEnd =
            phaseDeltaStart * Math.pow(phaseDeltaScale, roundedSamplesPerTick),
          radiansPerSampleStart = 2 * Math.PI * phaseDeltaStart,
          radiansPerSampleEnd = 2 * Math.PI * phaseDeltaEnd,
          centerHarmonicStart = 2 * radiansPerSampleStart,
          centerHarmonicEnd = 2 * radiansPerSampleEnd,
          allPassRadiansStart = Math.min(
            Math.PI,
            radiansPerSampleStart *
              Config.pickedStringDispersionFreqMult *
              Math.pow(
                allPassCenter / radiansPerSampleStart,
                Config.pickedStringDispersionFreqScale
              )
          ),
          allPassRadiansEnd = Math.min(
            Math.PI,
            radiansPerSampleEnd *
              Config.pickedStringDispersionFreqMult *
              Math.pow(
                allPassCenter / radiansPerSampleEnd,
                Config.pickedStringDispersionFreqScale
              )
          ),
          shelfRadians =
            (2 * Math.PI * Config.pickedStringShelfHz) / synth.samplesPerSecond,
          decayCurveStart = (Math.pow(100, stringDecayStart) - 1) / 99,
          decayCurveEnd = (Math.pow(100, stringDecayEnd) - 1) / 99,
          register = 1 == sustainType ? 0.25 : 0,
          registerShelfCenter = 15.6,
          registerLowpassCenter = (3 * synth.samplesPerSecond) / 48e3,
          decayRateStart = Math.pow(
            0.5,
            decayCurveStart *
              Math.pow(
                shelfRadians / (15.6 * radiansPerSampleStart),
                1 + 2 * register
              ) *
              15.6
          ),
          decayRateEnd = Math.pow(
            0.5,
            decayCurveEnd *
              Math.pow(
                shelfRadians / (15.6 * radiansPerSampleEnd),
                1 + 2 * register
              ) *
              15.6
          ),
          expressionDecayStart = Math.pow(decayRateStart, 0.002),
          expressionDecayEnd = Math.pow(decayRateEnd, 0.002);
        Synth.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(
          allPassRadiansStart
        ),
          synth.tempFrequencyResponse.analyze(
            Synth.tempFilterStartCoefficients,
            centerHarmonicStart
          );
        const allPassGStart = Synth.tempFilterStartCoefficients.b[0],
          allPassPhaseDelayStart =
            -synth.tempFrequencyResponse.angle() / centerHarmonicStart;
        Synth.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(
          allPassRadiansEnd
        ),
          synth.tempFrequencyResponse.analyze(
            Synth.tempFilterEndCoefficients,
            centerHarmonicEnd
          );
        const allPassGEnd = Synth.tempFilterEndCoefficients.b[0],
          allPassPhaseDelayEnd =
            -synth.tempFrequencyResponse.angle() / centerHarmonicEnd,
          brightnessType = 0 == sustainType ? 0 : 1;
        if (0 == brightnessType) {
          const shelfGainStart = Math.pow(
              decayRateStart,
              Config.stringDecayRate
            ),
            shelfGainEnd = Math.pow(decayRateEnd, Config.stringDecayRate);
          Synth.tempFilterStartCoefficients.highShelf2ndOrder(
            shelfRadians,
            shelfGainStart,
            0.5
          ),
            Synth.tempFilterEndCoefficients.highShelf2ndOrder(
              shelfRadians,
              shelfGainEnd,
              0.5
            );
        } else {
          const cornerHardness = Math.pow(1 == brightnessType ? 0 : 1, 0.25),
            lowpass1stOrderCutoffRadiansStart =
              Math.pow(
                (registerLowpassCenter *
                  registerLowpassCenter *
                  radiansPerSampleStart *
                  3.3 *
                  48e3) /
                  synth.samplesPerSecond,
                0.5 + register
              ) /
              registerLowpassCenter /
              Math.pow(decayCurveStart, 0.5),
            lowpass1stOrderCutoffRadiansEnd =
              Math.pow(
                (registerLowpassCenter *
                  registerLowpassCenter *
                  radiansPerSampleEnd *
                  3.3 *
                  48e3) /
                  synth.samplesPerSecond,
                0.5 + register
              ) /
              registerLowpassCenter /
              Math.pow(decayCurveEnd, 0.5),
            lowpass2ndOrderCutoffRadiansStart =
              lowpass1stOrderCutoffRadiansStart *
              Math.pow(
                2,
                0.5 - 1.75 * (1 - Math.pow(1 - cornerHardness, 0.85))
              ),
            lowpass2ndOrderCutoffRadiansEnd =
              lowpass1stOrderCutoffRadiansEnd *
              Math.pow(
                2,
                0.5 - 1.75 * (1 - Math.pow(1 - cornerHardness, 0.85))
              ),
            lowpass2ndOrderGainStart = Math.pow(
              2,
              -Math.pow(2, -Math.pow(cornerHardness, 0.9))
            ),
            lowpass2ndOrderGainEnd = Math.pow(
              2,
              -Math.pow(2, -Math.pow(cornerHardness, 0.9))
            );
          Synth.tempFilterStartCoefficients.lowPass2ndOrderButterworth(
            warpInfinityToNyquist(lowpass2ndOrderCutoffRadiansStart),
            lowpass2ndOrderGainStart
          ),
            Synth.tempFilterEndCoefficients.lowPass2ndOrderButterworth(
              warpInfinityToNyquist(lowpass2ndOrderCutoffRadiansEnd),
              lowpass2ndOrderGainEnd
            );
        }
        synth.tempFrequencyResponse.analyze(
          Synth.tempFilterStartCoefficients,
          centerHarmonicStart
        );
        const sustainFilterA1Start = Synth.tempFilterStartCoefficients.a[1],
          sustainFilterA2Start = Synth.tempFilterStartCoefficients.a[2],
          sustainFilterB0Start =
            Synth.tempFilterStartCoefficients.b[0] * expressionDecayStart,
          sustainFilterB1Start =
            Synth.tempFilterStartCoefficients.b[1] * expressionDecayStart,
          sustainFilterB2Start =
            Synth.tempFilterStartCoefficients.b[2] * expressionDecayStart,
          sustainFilterPhaseDelayStart =
            -synth.tempFrequencyResponse.angle() / centerHarmonicStart;
        synth.tempFrequencyResponse.analyze(
          Synth.tempFilterEndCoefficients,
          centerHarmonicEnd
        );
        const sustainFilterA1End = Synth.tempFilterEndCoefficients.a[1],
          sustainFilterA2End = Synth.tempFilterEndCoefficients.a[2],
          sustainFilterB0End =
            Synth.tempFilterEndCoefficients.b[0] * expressionDecayEnd,
          sustainFilterB1End =
            Synth.tempFilterEndCoefficients.b[1] * expressionDecayEnd,
          sustainFilterB2End =
            Synth.tempFilterEndCoefficients.b[2] * expressionDecayEnd,
          sustainFilterPhaseDelayEnd =
            -synth.tempFrequencyResponse.angle() / centerHarmonicEnd,
          periodLengthStart = 1 / phaseDeltaStart,
          periodLengthEnd = 1 / phaseDeltaEnd,
          minBufferLength = Math.ceil(
            2 * Math.max(periodLengthStart, periodLengthEnd)
          ),
          delayLength =
            periodLengthStart -
            allPassPhaseDelayStart -
            sustainFilterPhaseDelayStart,
          delayLengthEnd =
            periodLengthEnd - allPassPhaseDelayEnd - sustainFilterPhaseDelayEnd;
        (this.prevDelayLength = delayLength),
          (this.delayLengthDelta =
            (delayLengthEnd - delayLength) / roundedSamplesPerTick),
          (this.allPassG = allPassGStart),
          (this.sustainFilterA1 = sustainFilterA1Start),
          (this.sustainFilterA2 = sustainFilterA2Start),
          (this.sustainFilterB0 = sustainFilterB0Start),
          (this.sustainFilterB1 = sustainFilterB1Start),
          (this.sustainFilterB2 = sustainFilterB2Start),
          (this.allPassGDelta =
            (allPassGEnd - allPassGStart) / roundedSamplesPerTick),
          (this.sustainFilterA1Delta =
            (sustainFilterA1End - sustainFilterA1Start) /
            roundedSamplesPerTick),
          (this.sustainFilterA2Delta =
            (sustainFilterA2End - sustainFilterA2Start) /
            roundedSamplesPerTick),
          (this.sustainFilterB0Delta =
            (sustainFilterB0End - sustainFilterB0Start) /
            roundedSamplesPerTick),
          (this.sustainFilterB1Delta =
            (sustainFilterB1End - sustainFilterB1Start) /
            roundedSamplesPerTick),
          (this.sustainFilterB2Delta =
            (sustainFilterB2End - sustainFilterB2Start) /
            roundedSamplesPerTick);
        const pitchChanged =
            Math.abs(Math.log2(delayLength / prevDelayLength)) > 0.01,
          reinitializeImpulse = -1 == this.delayIndex || pitchChanged;
        if (
          null == this.delayLine ||
          this.delayLine.length <= minBufferLength
        ) {
          const likelyMaximumLength = Math.ceil(
              (2 * synth.samplesPerSecond) / Instrument.frequencyFromPitch(12)
            ),
            newDelayLine = new Float32Array(
              Synth.fittingPowerOfTwo(
                Math.max(likelyMaximumLength, minBufferLength)
              )
            );
          if (!reinitializeImpulse && null != this.delayLine) {
            const oldDelayBufferMask = (this.delayLine.length - 1) >> 0,
              startCopyingFromIndex = this.delayIndex + this.delayResetOffset;
            this.delayIndex = this.delayLine.length - this.delayResetOffset;
            for (let i = 0; i < this.delayLine.length; i++)
              newDelayLine[i] =
                this.delayLine[
                  (startCopyingFromIndex + i) & oldDelayBufferMask
                ];
          }
          this.delayLine = newDelayLine;
        }
        const delayLine = this.delayLine,
          delayBufferMask = (delayLine.length - 1) >> 0;
        if (reinitializeImpulse) {
          (this.delayIndex = 0),
            (this.allPassSample = 0),
            (this.allPassPrevInput = 0),
            (this.sustainFilterSample = 0),
            (this.sustainFilterPrevOutput2 = 0),
            (this.sustainFilterPrevInput1 = 0),
            (this.sustainFilterPrevInput2 = 0),
            (this.fractionalDelaySample = 0);
          const startImpulseFrom = -delayLength,
            startZerosFrom = Math.floor(
              startImpulseFrom - periodLengthStart / 2
            ),
            stopZerosAt = Math.ceil(startZerosFrom + 2 * periodLengthStart);
          this.delayResetOffset = stopZerosAt;
          for (let i = startZerosFrom; i <= stopZerosAt; i++)
            delayLine[i & delayBufferMask] = 0;
          const impulseWave = instrumentState.wave,
            impulseWaveLength = impulseWave.length - 1,
            impulsePhaseDelta = impulseWaveLength / periodLengthStart,
            fadeDuration = Math.min(
              0.2 * periodLengthStart,
              0.003 * synth.samplesPerSecond
            ),
            startImpulseFromSample = Math.ceil(startImpulseFrom),
            stopImpulseAt = startImpulseFrom + periodLengthStart + fadeDuration,
            stopImpulseAtSample = stopImpulseAt;
          let impulsePhase =
              (startImpulseFromSample - startImpulseFrom) * impulsePhaseDelta,
            prevWaveIntegral = 0;
          for (let i = startImpulseFromSample; i <= stopImpulseAtSample; i++) {
            const impulsePhaseInt = 0 | impulsePhase,
              index = impulsePhaseInt % impulseWaveLength;
            let nextWaveIntegral = impulseWave[index];
            const phaseRatio = impulsePhase - impulsePhaseInt;
            nextWaveIntegral +=
              (impulseWave[index + 1] - nextWaveIntegral) * phaseRatio;
            const sample =
                (nextWaveIntegral - prevWaveIntegral) / impulsePhaseDelta,
              fadeIn = Math.min(1, (i - startImpulseFrom) / fadeDuration),
              fadeOut = Math.min(1, (stopImpulseAt - i) / fadeDuration),
              combinedFade = fadeIn * fadeOut,
              curvedFade = combinedFade * combinedFade * (3 - 2 * combinedFade);
            (delayLine[i & delayBufferMask] += sample * curvedFade),
              (prevWaveIntegral = nextWaveIntegral),
              (impulsePhase += impulsePhaseDelta);
          }
        }
      }
    }
    class EnvelopeComputer {
      constructor() {
        (this.noteSecondsStart = 0),
          (this.noteSecondsStartUnscaled = 0),
          (this.noteSecondsEnd = 0),
          (this.noteSecondsEndUnscaled = 0),
          (this.noteTicksStart = 0),
          (this.noteTicksEnd = 0),
          (this.noteSizeStart = Config.noteSizeMax),
          (this.noteSizeEnd = Config.noteSizeMax),
          (this.prevNoteSize = Config.noteSizeMax),
          (this.nextNoteSize = Config.noteSizeMax),
          (this._noteSizeFinal = Config.noteSizeMax),
          (this.prevNoteSecondsStart = 0),
          (this.prevNoteSecondsStartUnscaled = 0),
          (this.prevNoteSecondsEnd = 0),
          (this.prevNoteSecondsEndUnscaled = 0),
          (this.prevNoteTicksStart = 0),
          (this.prevNoteTicksEnd = 0),
          (this._prevNoteSizeFinal = Config.noteSizeMax),
          (this.prevSlideStart = !1),
          (this.prevSlideEnd = !1),
          (this.nextSlideStart = !1),
          (this.nextSlideEnd = !1),
          (this.prevSlideRatioStart = 0),
          (this.prevSlideRatioEnd = 0),
          (this.nextSlideRatioStart = 0),
          (this.nextSlideRatioEnd = 0),
          (this.envelopeStarts = []),
          (this.envelopeEnds = []),
          (this._modifiedEnvelopeIndices = []),
          (this._modifiedEnvelopeCount = 0),
          (this.lowpassCutoffDecayVolumeCompensation = 1);
        const length = 41;
        for (let i = 0; i < 41; i++)
          (this.envelopeStarts[i] = 1), (this.envelopeEnds[i] = 1);
        this.reset();
      }
      reset() {
        (this.noteSecondsEnd = 0),
          (this.noteSecondsEndUnscaled = 0),
          (this.noteTicksEnd = 0),
          (this._noteSizeFinal = Config.noteSizeMax),
          (this.prevNoteSecondsEnd = 0),
          (this.prevNoteSecondsEndUnscaled = 0),
          (this.prevNoteTicksEnd = 0),
          (this._prevNoteSizeFinal = Config.noteSizeMax),
          (this._modifiedEnvelopeCount = 0);
      }
      computeEnvelopes(
        instrument,
        currentPart,
        tickTimeStart,
        tickTimeStartReal,
        secondsPerTick,
        tone,
        timeScale
      ) {
        const secondsPerTickUnscaled = secondsPerTick;
        secondsPerTick *= timeScale;
        const transition = instrument.getTransition();
        null == tone ||
          !tone.atNoteStart ||
          transition.continues ||
          tone.forceContinueAtStart ||
          ((this.prevNoteSecondsEnd = this.noteSecondsEnd),
          (this.prevNoteSecondsEndUnscaled = this.noteSecondsEndUnscaled),
          (this.prevNoteTicksEnd = this.noteTicksEnd),
          (this._prevNoteSizeFinal = this._noteSizeFinal),
          (this.noteSecondsEnd = 0),
          (this.noteSecondsEndUnscaled = 0),
          (this.noteTicksEnd = 0)),
          null != tone &&
            (null != tone.note
              ? (this._noteSizeFinal =
                  tone.note.pins[tone.note.pins.length - 1].size)
              : (this._noteSizeFinal = Config.noteSizeMax));
        const tickTimeEnd = tickTimeStart + timeScale,
          tickTimeEndReal = tickTimeStartReal + 1,
          noteSecondsStart = this.noteSecondsEnd,
          noteSecondsStartUnscaled = this.noteSecondsEndUnscaled,
          noteSecondsEnd = noteSecondsStart + secondsPerTick,
          noteSecondsEndUnscaled =
            noteSecondsStartUnscaled + secondsPerTickUnscaled,
          noteTicksStart = this.noteTicksEnd,
          noteTicksEnd = noteTicksStart + 1,
          prevNoteSecondsStart = this.prevNoteSecondsEnd,
          prevNoteSecondsStartUnscaled = this.prevNoteSecondsEndUnscaled,
          prevNoteSecondsEnd = prevNoteSecondsStart + secondsPerTick,
          prevNoteSecondsEndUnscaled =
            prevNoteSecondsStartUnscaled + secondsPerTickUnscaled,
          prevNoteTicksStart = this.prevNoteTicksEnd,
          prevNoteTicksEnd = prevNoteTicksStart + 1,
          beatsPerTick = 1 / (Config.ticksPerPart * Config.partsPerBeat),
          beatTimeStart = beatsPerTick * tickTimeStart,
          beatTimeEnd = beatsPerTick * tickTimeEnd;
        let noteSizeStart = this._noteSizeFinal,
          noteSizeEnd = this._noteSizeFinal,
          prevNoteSize = this._prevNoteSizeFinal,
          nextNoteSize = 0,
          prevSlideStart = !1,
          prevSlideEnd = !1,
          nextSlideStart = !1,
          nextSlideEnd = !1,
          prevSlideRatioStart = 0,
          prevSlideRatioEnd = 0,
          nextSlideRatioStart = 0,
          nextSlideRatioEnd = 0;
        if (null != tone && null != tone.note && !tone.passedEndOfNote) {
          const endPinIndex = tone.note.getEndPinIndex(currentPart),
            startPin = tone.note.pins[endPinIndex - 1],
            endPin = tone.note.pins[endPinIndex],
            startPinTick =
              (tone.note.start + startPin.time) * Config.ticksPerPart,
            endPinTick = (tone.note.start + endPin.time) * Config.ticksPerPart,
            ratioStart =
              (tickTimeStartReal - startPinTick) / (endPinTick - startPinTick),
            ratioEnd =
              (tickTimeEndReal - startPinTick) / (endPinTick - startPinTick);
          if (
            ((noteSizeStart =
              startPin.size + (endPin.size - startPin.size) * ratioStart),
            (noteSizeEnd =
              startPin.size + (endPin.size - startPin.size) * ratioEnd),
            transition.slides)
          ) {
            const noteStartTick = tone.noteStartPart * Config.ticksPerPart,
              noteEndTick = tone.noteEndPart * Config.ticksPerPart,
              noteLengthTicks = noteEndTick - noteStartTick,
              maximumSlideTicks = 0.5 * noteLengthTicks,
              slideTicks = Math.min(maximumSlideTicks, transition.slideTicks);
            null == tone.prevNote ||
              tone.forceContinueAtStart ||
              (tickTimeStartReal - noteStartTick < slideTicks &&
                ((prevSlideStart = !0),
                (prevSlideRatioStart =
                  0.5 *
                  (1 - (tickTimeStartReal - noteStartTick) / slideTicks))),
              tickTimeEndReal - noteStartTick < slideTicks &&
                ((prevSlideEnd = !0),
                (prevSlideRatioEnd =
                  0.5 * (1 - (tickTimeEndReal - noteStartTick) / slideTicks)))),
              null == tone.nextNote ||
                tone.forceContinueAtEnd ||
                ((nextNoteSize = tone.nextNote.pins[0].size),
                noteEndTick - tickTimeStartReal < slideTicks &&
                  ((nextSlideStart = !0),
                  (nextSlideRatioStart =
                    0.5 *
                    (1 - (noteEndTick - tickTimeStartReal) / slideTicks))),
                noteEndTick - tickTimeEndReal < slideTicks &&
                  ((nextSlideEnd = !0),
                  (nextSlideRatioEnd =
                    0.5 * (1 - (noteEndTick - tickTimeEndReal) / slideTicks))));
          }
        }
        let lowpassCutoffDecayVolumeCompensation = 1,
          usedNoteSize = !1;
        for (
          let envelopeIndex = 0;
          envelopeIndex <= instrument.envelopeCount;
          envelopeIndex++
        ) {
          let automationTarget, targetIndex, envelope;
          if (envelopeIndex == instrument.envelopeCount) {
            if (usedNoteSize) break;
            (automationTarget =
              Config.instrumentAutomationTargets.dictionary.noteVolume),
              (targetIndex = 0),
              (envelope = Config.envelopes.dictionary["note size"]);
          } else {
            let envelopeSettings = instrument.envelopes[envelopeIndex];
            (automationTarget =
              Config.instrumentAutomationTargets[envelopeSettings.target]),
              (targetIndex = envelopeSettings.index),
              (envelope = Config.envelopes[envelopeSettings.envelope]),
              0 == envelope.type && (usedNoteSize = !0);
          }
          if (null != automationTarget.computeIndex) {
            const computeIndex = automationTarget.computeIndex + targetIndex;
            let envelopeStart = EnvelopeComputer.computeEnvelope(
              envelope,
              noteSecondsStart,
              beatTimeStart,
              noteSizeStart
            );
            if (prevSlideStart) {
              const other = EnvelopeComputer.computeEnvelope(
                envelope,
                prevNoteSecondsStart,
                beatTimeStart,
                prevNoteSize
              );
              envelopeStart += (other - envelopeStart) * prevSlideRatioStart;
            }
            if (nextSlideStart) {
              const other = EnvelopeComputer.computeEnvelope(
                envelope,
                0,
                beatTimeStart,
                nextNoteSize
              );
              envelopeStart += (other - envelopeStart) * nextSlideRatioStart;
            }
            let envelopeEnd = envelopeStart;
            if (0 == instrument.discreteEnvelope) {
              if (
                ((envelopeEnd = EnvelopeComputer.computeEnvelope(
                  envelope,
                  noteSecondsEnd,
                  beatTimeEnd,
                  noteSizeEnd
                )),
                prevSlideEnd)
              ) {
                const other = EnvelopeComputer.computeEnvelope(
                  envelope,
                  prevNoteSecondsEnd,
                  beatTimeEnd,
                  prevNoteSize
                );
                envelopeEnd += (other - envelopeEnd) * prevSlideRatioEnd;
              }
              if (nextSlideEnd) {
                const other = EnvelopeComputer.computeEnvelope(
                  envelope,
                  0,
                  beatTimeEnd,
                  nextNoteSize
                );
                envelopeEnd += (other - envelopeEnd) * nextSlideRatioEnd;
              }
            }
            if (
              ((this.envelopeStarts[computeIndex] *= envelopeStart),
              (this.envelopeEnds[computeIndex] *= envelopeEnd),
              (this._modifiedEnvelopeIndices[this._modifiedEnvelopeCount++] =
                computeIndex),
              automationTarget.isFilter)
            ) {
              const filterSettings =
                null != instrument.tmpNoteFilterStart
                  ? instrument.tmpNoteFilterStart
                  : instrument.noteFilter;
              filterSettings.controlPointCount > targetIndex &&
                0 == filterSettings.controlPoints[targetIndex].type &&
                (lowpassCutoffDecayVolumeCompensation = Math.max(
                  lowpassCutoffDecayVolumeCompensation,
                  EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(
                    envelope
                  )
                ));
            }
          }
        }
        (this.noteSecondsStart = noteSecondsStart),
          (this.noteSecondsStartUnscaled = noteSecondsStartUnscaled),
          (this.noteSecondsEnd = noteSecondsEnd),
          (this.noteSecondsEndUnscaled = noteSecondsEndUnscaled),
          (this.noteTicksStart = noteTicksStart),
          (this.noteTicksEnd = noteTicksEnd),
          (this.prevNoteSecondsStart = prevNoteSecondsStart),
          (this.prevNoteSecondsStartUnscaled = prevNoteSecondsStartUnscaled),
          (this.prevNoteSecondsEnd = prevNoteSecondsEnd),
          (this.prevNoteSecondsEndUnscaled = prevNoteSecondsEndUnscaled),
          (this.prevNoteTicksStart = prevNoteTicksStart),
          (this.prevNoteTicksEnd = prevNoteTicksEnd),
          (this.prevNoteSize = prevNoteSize),
          (this.nextNoteSize = nextNoteSize),
          (this.noteSizeStart = noteSizeStart),
          (this.noteSizeEnd = noteSizeEnd),
          (this.prevSlideStart = prevSlideStart),
          (this.prevSlideEnd = prevSlideEnd),
          (this.nextSlideStart = nextSlideStart),
          (this.nextSlideEnd = nextSlideEnd),
          (this.prevSlideRatioStart = prevSlideRatioStart),
          (this.prevSlideRatioEnd = prevSlideRatioEnd),
          (this.nextSlideRatioStart = nextSlideRatioStart),
          (this.nextSlideRatioEnd = nextSlideRatioEnd),
          (this.lowpassCutoffDecayVolumeCompensation =
            lowpassCutoffDecayVolumeCompensation);
      }
      clearEnvelopes() {
        for (
          let envelopeIndex = 0;
          envelopeIndex < this._modifiedEnvelopeCount;
          envelopeIndex++
        ) {
          const computeIndex = this._modifiedEnvelopeIndices[envelopeIndex];
          (this.envelopeStarts[computeIndex] = 1),
            (this.envelopeEnds[computeIndex] = 1);
        }
        this._modifiedEnvelopeCount = 0;
      }
      static computeEnvelope(envelope, time, beats, noteSize) {
        switch (envelope.type) {
          case 0:
            return Synth.noteSizeToVolumeMult(noteSize);
          case 1:
            return 1;
          case 4:
            return 1 / (1 + time * envelope.speed);
          case 5:
            return 1 - 1 / (1 + time * envelope.speed);
          case 6:
            return 0.5 - 0.5 * Math.cos(2 * beats * Math.PI * envelope.speed);
          case 7:
            return 0.75 - 0.25 * Math.cos(2 * beats * Math.PI * envelope.speed);
          case 2:
            return Math.max(1, 2 - 10 * time);
          case 3:
            const attack = 0.25 / Math.sqrt(envelope.speed);
            return time < attack
              ? time / attack
              : 1 / (1 + (time - attack) * envelope.speed);
          case 8:
            return Math.pow(2, -envelope.speed * time);
          case 13:
            return 1 * +(time < 0.25 / Math.sqrt(envelope.speed));
          case 9:
            let temp = 0.5 - 0.5 * Math.cos(beats * envelope.speed);
            return (
              (temp =
                1 /
                (1 + time * (envelope.speed - temp / (1.5 / envelope.speed)))),
              (temp = temp > 0 ? temp : 0),
              temp
            );
          case 11: {
            let lin = 1 - time / (16 / envelope.speed);
            return (lin = lin > 0 ? lin : 0), lin;
          }
          case 12: {
            let lin = time / (16 / envelope.speed);
            return (lin = lin < 1 ? lin : 1), lin;
          }
          default:
            throw new Error("Unrecognized operator envelope type.");
        }
      }
      static getLowpassCutoffDecayVolumeCompensation(envelope) {
        return 8 == envelope.type
          ? 1.25 + 0.025 * envelope.speed
          : 4 == envelope.type
            ? 1 + 0.02 * envelope.speed
            : 1;
      }
    }
    class Tone {
      constructor() {
        (this.pitches = Array(Config.maxChordSize + 2).fill(0)),
          (this.pitchCount = 0),
          (this.chordSize = 0),
          (this.drumsetPitch = null),
          (this.note = null),
          (this.prevNote = null),
          (this.nextNote = null),
          (this.prevNotePitchIndex = 0),
          (this.nextNotePitchIndex = 0),
          (this.freshlyAllocated = !0),
          (this.atNoteStart = !1),
          (this.isOnLastTick = !1),
          (this.passedEndOfNote = !1),
          (this.forceContinueAtStart = !1),
          (this.forceContinueAtEnd = !1),
          (this.noteStartPart = 0),
          (this.noteEndPart = 0),
          (this.ticksSinceReleased = 0),
          (this.liveInputSamplesHeld = 0),
          (this.lastInterval = 0),
          (this.noiseSample = 0),
          (this.noiseSampleA = 0),
          (this.noiseSampleB = 0),
          (this.stringSustainStart = 0),
          (this.stringSustainEnd = 0),
          (this.phases = []),
          (this.operatorWaves = []),
          (this.phaseDeltas = []),
          (this.directions = []),
          (this.chipWaveCompletions = []),
          (this.chipWavePrevWaves = []),
          (this.chipWaveCompletionsLastWave = []),
          (this.phaseDeltaScales = []),
          (this.expression = 0),
          (this.expressionDelta = 0),
          (this.operatorExpressions = []),
          (this.operatorExpressionDeltas = []),
          (this.prevPitchExpressions = Array(
            Config.maxPitchOrOperatorCount
          ).fill(null)),
          (this.prevVibrato = null),
          (this.prevStringDecay = null),
          (this.pulseWidth = 0),
          (this.pulseWidthDelta = 0),
          (this.decimalOffset = 0),
          (this.supersawDynamism = 0),
          (this.supersawDynamismDelta = 0),
          (this.supersawUnisonDetunes = []),
          (this.supersawShape = 0),
          (this.supersawShapeDelta = 0),
          (this.supersawDelayLength = 0),
          (this.supersawDelayLengthDelta = 0),
          (this.supersawDelayLine = null),
          (this.supersawDelayIndex = -1),
          (this.supersawPrevPhaseDelta = null),
          (this.pickedStrings = []),
          (this.noteFilters = []),
          (this.noteFilterCount = 0),
          (this.initialNoteFilterInput1 = 0),
          (this.initialNoteFilterInput2 = 0),
          (this.specialIntervalExpressionMult = 1),
          (this.feedbackOutputs = []),
          (this.feedbackMult = 0),
          (this.feedbackDelta = 0),
          (this.stereoVolumeLStart = 0),
          (this.stereoVolumeRStart = 0),
          (this.stereoVolumeLDelta = 0),
          (this.stereoVolumeRDelta = 0),
          (this.stereoDelayStart = 0),
          (this.stereoDelayEnd = 0),
          (this.stereoDelayDelta = 0),
          (this.customVolumeStart = 0),
          (this.customVolumeEnd = 0),
          (this.filterResonanceStart = 0),
          (this.filterResonanceDelta = 0),
          (this.isFirstOrder = !1),
          (this.envelopeComputer = new EnvelopeComputer()),
          this.reset();
      }
      reset() {
        (this.noiseSample = 0),
          (this.noiseSampleA = 0),
          (this.noiseSampleB = 0);
        for (let i = 0; i < Config.maxPitchOrOperatorCount; i++)
          (this.phases[i] = 0),
            (this.directions[i] = 1),
            (this.chipWaveCompletions[i] = 0),
            (this.chipWavePrevWaves[i] = 0),
            (this.chipWaveCompletionsLastWave[i] = 0),
            (this.operatorWaves[i] = Config.operatorWaves[0]),
            (this.feedbackOutputs[i] = 0),
            (this.prevPitchExpressions[i] = null);
        for (let i = 0; i < this.noteFilterCount; i++)
          this.noteFilters[i].resetOutput();
        (this.noteFilterCount = 0),
          (this.initialNoteFilterInput1 = 0),
          (this.initialNoteFilterInput2 = 0),
          (this.liveInputSamplesHeld = 0),
          (this.supersawDelayIndex = -1);
        for (const pickedString of this.pickedStrings) pickedString.reset();
        this.envelopeComputer.reset(),
          (this.prevVibrato = null),
          (this.prevStringDecay = null),
          (this.supersawPrevPhaseDelta = null),
          (this.drumsetPitch = null);
      }
    }
    class InstrumentState {
      constructor() {
        (this.awake = !1),
          (this.computed = !1),
          (this.tonesAddedInThisTick = !1),
          (this.flushingDelayLines = !1),
          (this.deactivateAfterThisTick = !1),
          (this.attentuationProgress = 0),
          (this.flushedSamples = 0),
          (this.activeTones = new Deque()),
          (this.activeModTones = new Deque()),
          (this.releasedTones = new Deque()),
          (this.liveInputTones = new Deque()),
          (this.type = 0),
          (this.synthesizer = null),
          (this.wave = null),
          (this.isUsingAdvancedLoopControls = !1),
          (this.chipWaveLoopStart = 0),
          (this.chipWaveLoopEnd = 0),
          (this.chipWaveLoopMode = 0),
          (this.chipWavePlayBackwards = !1),
          (this.chipWaveStartOffset = 0),
          (this.noisePitchFilterMult = 1),
          (this.unison = null),
          (this.unisonVoices = 1),
          (this.unisonSpread = 0),
          (this.unisonOffset = 0),
          (this.unisonExpression = 1.4),
          (this.unisonSign = 1),
          (this.chord = null),
          (this.effects = 0),
          (this.volumeScale = 0),
          (this.aliases = !1),
          (this.arpTime = 0),
          (this.vibratoTime = 0),
          (this.nextVibratoTime = 0),
          (this.envelopeTime = 0),
          (this.eqFilterVolume = 1),
          (this.eqFilterVolumeDelta = 0),
          (this.mixVolume = 1),
          (this.mixVolumeDelta = 0),
          (this.delayInputMult = 0),
          (this.delayInputMultDelta = 0),
          (this.distortion = 0),
          (this.distortionDelta = 0),
          (this.distortionDrive = 0),
          (this.distortionDriveDelta = 0),
          (this.distortionFractionalInput1 = 0),
          (this.distortionFractionalInput2 = 0),
          (this.distortionFractionalInput3 = 0),
          (this.distortionPrevInput = 0),
          (this.distortionNextOutput = 0),
          (this.bitcrusherPrevInput = 0),
          (this.bitcrusherCurrentOutput = 0),
          (this.bitcrusherPhase = 1),
          (this.bitcrusherPhaseDelta = 0),
          (this.bitcrusherPhaseDeltaScale = 1),
          (this.bitcrusherScale = 1),
          (this.bitcrusherScaleScale = 1),
          (this.bitcrusherFoldLevel = 1),
          (this.bitcrusherFoldLevelScale = 1),
          (this.eqFilters = []),
          (this.eqFilterCount = 0),
          (this.initialEqFilterInput1 = 0),
          (this.initialEqFilterInput2 = 0),
          (this.panningDelayLine = null),
          (this.panningDelayPos = 0),
          (this.panningVolumeL = 0),
          (this.panningVolumeR = 0),
          (this.panningVolumeDeltaL = 0),
          (this.panningVolumeDeltaR = 0),
          (this.panningOffsetL = 0),
          (this.panningOffsetR = 0),
          (this.panningOffsetDeltaL = 0),
          (this.panningOffsetDeltaR = 0),
          (this.chorusDelayLineL = null),
          (this.chorusDelayLineR = null),
          (this.chorusDelayLineDirty = !1),
          (this.chorusDelayPos = 0),
          (this.chorusPhase = 0),
          (this.chorusVoiceMult = 0),
          (this.chorusVoiceMultDelta = 0),
          (this.chorusCombinedMult = 0),
          (this.chorusCombinedMultDelta = 0),
          (this.echoDelayLineL = null),
          (this.echoDelayLineR = null),
          (this.echoDelayLineDirty = !1),
          (this.echoDelayPos = 0),
          (this.echoDelayOffsetStart = 0),
          (this.echoDelayOffsetEnd = null),
          (this.echoDelayOffsetRatio = 0),
          (this.echoDelayOffsetRatioDelta = 0),
          (this.echoMult = 0),
          (this.echoMultDelta = 0),
          (this.echoShelfA1 = 0),
          (this.echoShelfB0 = 0),
          (this.echoShelfB1 = 0),
          (this.echoShelfSampleL = 0),
          (this.echoShelfSampleR = 0),
          (this.echoShelfPrevInputL = 0),
          (this.echoShelfPrevInputR = 0),
          (this.reverbDelayLine = null),
          (this.reverbDelayLineDirty = !1),
          (this.reverbDelayPos = 0),
          (this.reverbMult = 0),
          (this.reverbMultDelta = 0),
          (this.reverbShelfA1 = 0),
          (this.reverbShelfB0 = 0),
          (this.reverbShelfB1 = 0),
          (this.reverbShelfSample0 = 0),
          (this.reverbShelfSample1 = 0),
          (this.reverbShelfSample2 = 0),
          (this.reverbShelfSample3 = 0),
          (this.reverbShelfPrevInput0 = 0),
          (this.reverbShelfPrevInput1 = 0),
          (this.reverbShelfPrevInput2 = 0),
          (this.reverbShelfPrevInput3 = 0),
          (this.spectrumWave = new SpectrumWaveState()),
          (this.harmonicsWave = new HarmonicsWaveState()),
          (this.drumsetSpectrumWaves = []);
        for (let i = 0; i < Config.drumCount; i++)
          this.drumsetSpectrumWaves[i] = new SpectrumWaveState();
      }
      allocateNecessaryBuffers(synth, instrument, samplesPerTick) {
        if (
          (effectsIncludePanning(instrument.effects) &&
            (null == this.panningDelayLine ||
              this.panningDelayLine.length < synth.panningDelayBufferSize) &&
            (this.panningDelayLine = new Float32Array(
              synth.panningDelayBufferSize
            )),
          effectsIncludeChorus(instrument.effects) &&
            ((null == this.chorusDelayLineL ||
              this.chorusDelayLineL.length < synth.chorusDelayBufferSize) &&
              (this.chorusDelayLineL = new Float32Array(
                synth.chorusDelayBufferSize
              )),
            (null == this.chorusDelayLineR ||
              this.chorusDelayLineR.length < synth.chorusDelayBufferSize) &&
              (this.chorusDelayLineR = new Float32Array(
                synth.chorusDelayBufferSize
              ))),
          effectsIncludeEcho(instrument.effects))
        ) {
          const safeEchoDelaySteps = Math.max(
              Config.echoDelayRange >> 1,
              instrument.echoDelay + 1
            ),
            baseEchoDelayBufferSize = Synth.fittingPowerOfTwo(
              safeEchoDelaySteps * Config.echoDelayStepTicks * samplesPerTick
            ),
            safeEchoDelayBufferSize = 2 * baseEchoDelayBufferSize;
          if (null == this.echoDelayLineL || null == this.echoDelayLineR)
            (this.echoDelayLineL = new Float32Array(safeEchoDelayBufferSize)),
              (this.echoDelayLineR = new Float32Array(safeEchoDelayBufferSize));
          else if (
            this.echoDelayLineL.length < safeEchoDelayBufferSize ||
            this.echoDelayLineR.length < safeEchoDelayBufferSize
          ) {
            const newDelayLineL = new Float32Array(safeEchoDelayBufferSize),
              newDelayLineR = new Float32Array(safeEchoDelayBufferSize),
              oldMask = this.echoDelayLineL.length - 1;
            for (let i = 0; i < this.echoDelayLineL.length; i++)
              (newDelayLineL[i] =
                this.echoDelayLineL[(this.echoDelayPos + i) & oldMask]),
                (newDelayLineR[i] =
                  this.echoDelayLineL[(this.echoDelayPos + i) & oldMask]);
            (this.echoDelayPos = this.echoDelayLineL.length),
              (this.echoDelayLineL = newDelayLineL),
              (this.echoDelayLineR = newDelayLineR);
          }
        }
        effectsIncludeReverb(instrument.effects) &&
          null == this.reverbDelayLine &&
          (this.reverbDelayLine = new Float32Array(
            Config.reverbDelayBufferSize
          ));
      }
      deactivate() {
        (this.bitcrusherPrevInput = 0),
          (this.bitcrusherCurrentOutput = 0),
          (this.bitcrusherPhase = 1);
        for (let i = 0; i < this.eqFilterCount; i++)
          this.eqFilters[i].resetOutput();
        if (
          ((this.eqFilterCount = 0),
          (this.initialEqFilterInput1 = 0),
          (this.initialEqFilterInput2 = 0),
          (this.distortionFractionalInput1 = 0),
          (this.distortionFractionalInput2 = 0),
          (this.distortionFractionalInput3 = 0),
          (this.distortionPrevInput = 0),
          (this.distortionNextOutput = 0),
          (this.panningDelayPos = 0),
          null != this.panningDelayLine)
        )
          for (let i = 0; i < this.panningDelayLine.length; i++)
            this.panningDelayLine[i] = 0;
        (this.echoDelayOffsetEnd = null),
          (this.echoShelfSampleL = 0),
          (this.echoShelfSampleR = 0),
          (this.echoShelfPrevInputL = 0),
          (this.echoShelfPrevInputR = 0),
          (this.reverbShelfSample0 = 0),
          (this.reverbShelfSample1 = 0),
          (this.reverbShelfSample2 = 0),
          (this.reverbShelfSample3 = 0),
          (this.reverbShelfPrevInput0 = 0),
          (this.reverbShelfPrevInput1 = 0),
          (this.reverbShelfPrevInput2 = 0),
          (this.reverbShelfPrevInput3 = 0),
          (this.volumeScale = 1),
          (this.aliases = !1),
          (this.awake = !1),
          (this.flushingDelayLines = !1),
          (this.deactivateAfterThisTick = !1),
          (this.attentuationProgress = 0),
          (this.flushedSamples = 0);
      }
      resetAllEffects() {
        if (
          (this.deactivate(),
          (this.vibratoTime = 0),
          (this.nextVibratoTime = 0),
          (this.arpTime = 0),
          (this.envelopeTime = 0),
          this.chorusDelayLineDirty)
        ) {
          for (let i = 0; i < this.chorusDelayLineL.length; i++)
            this.chorusDelayLineL[i] = 0;
          for (let i = 0; i < this.chorusDelayLineR.length; i++)
            this.chorusDelayLineR[i] = 0;
        }
        if (this.echoDelayLineDirty) {
          for (let i = 0; i < this.echoDelayLineL.length; i++)
            this.echoDelayLineL[i] = 0;
          for (let i = 0; i < this.echoDelayLineR.length; i++)
            this.echoDelayLineR[i] = 0;
        }
        if (this.reverbDelayLineDirty)
          for (let i = 0; i < this.reverbDelayLine.length; i++)
            this.reverbDelayLine[i] = 0;
        this.chorusPhase = 0;
      }
      compute(
        synth,
        instrument,
        samplesPerTick,
        roundedSamplesPerTick,
        tone,
        channelIndex,
        instrumentIndex
      ) {
        (this.computed = !0),
          (this.type = instrument.type),
          (this.synthesizer = Synth.getInstrumentSynthFunction(instrument)),
          (this.unison = Config.unisons[instrument.unison]),
          (this.chord = instrument.getChord()),
          (this.noisePitchFilterMult =
            Config.chipNoises[instrument.chipNoise].pitchFilterMult),
          (this.effects = instrument.effects),
          (this.aliases = instrument.aliases),
          (this.volumeScale = 1),
          this.allocateNecessaryBuffers(synth, instrument, samplesPerTick);
        const samplesPerSecond = synth.samplesPerSecond;
        this.updateWaves(instrument, samplesPerSecond);
        const usesDistortion = effectsIncludeDistortion(this.effects),
          usesBitcrusher = effectsIncludeBitcrusher(this.effects),
          usesPanning = effectsIncludePanning(this.effects),
          usesChorus = effectsIncludeChorus(this.effects),
          usesEcho = effectsIncludeEcho(this.effects),
          usesReverb = effectsIncludeReverb(this.effects);
        if (usesDistortion) {
          let useDistortionStart = instrument.distortion,
            useDistortionEnd = instrument.distortion;
          synth.isModActive(
            Config.modulators.dictionary.distortion.index,
            channelIndex,
            instrumentIndex
          ) &&
            ((useDistortionStart = synth.getModValue(
              Config.modulators.dictionary.distortion.index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (useDistortionEnd = synth.getModValue(
              Config.modulators.dictionary.distortion.index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          const distortionSliderStart = Math.min(
              1,
              useDistortionStart / (Config.distortionRange - 1)
            ),
            distortionSliderEnd = Math.min(
              1,
              useDistortionEnd / (Config.distortionRange - 1)
            ),
            distortionStart = Math.pow(
              1 - (0.895 * (Math.pow(20, distortionSliderStart) - 1)) / 19,
              2
            ),
            distortionEnd = Math.pow(
              1 - (0.895 * (Math.pow(20, distortionSliderEnd) - 1)) / 19,
              2
            ),
            distortionDriveStart =
              (1 + 2 * distortionSliderStart) / Config.distortionBaseVolume,
            distortionDriveEnd =
              (1 + 2 * distortionSliderEnd) / Config.distortionBaseVolume;
          (this.distortion = distortionStart),
            (this.distortionDelta =
              (distortionEnd - distortionStart) / roundedSamplesPerTick),
            (this.distortionDrive = distortionDriveStart),
            (this.distortionDriveDelta =
              (distortionDriveEnd - distortionDriveStart) /
              roundedSamplesPerTick);
        }
        if (usesBitcrusher) {
          let freqSettingStart = instrument.bitcrusherFreq,
            freqSettingEnd = instrument.bitcrusherFreq;
          synth.isModActive(
            Config.modulators.dictionary["freq crush"].index,
            channelIndex,
            instrumentIndex
          ) &&
            ((freqSettingStart = synth.getModValue(
              Config.modulators.dictionary["freq crush"].index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (freqSettingEnd = synth.getModValue(
              Config.modulators.dictionary["freq crush"].index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          let quantizationSettingStart = instrument.bitcrusherQuantization,
            quantizationSettingEnd = instrument.bitcrusherQuantization;
          synth.isModActive(
            Config.modulators.dictionary["bit crush"].index,
            channelIndex,
            instrumentIndex
          ) &&
            ((quantizationSettingStart = synth.getModValue(
              Config.modulators.dictionary["bit crush"].index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (quantizationSettingEnd = synth.getModValue(
              Config.modulators.dictionary["bit crush"].index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          const basePitch =
              Config.keys[synth.song.key].basePitch +
              Config.pitchesPerOctave * synth.song.octave,
            freqStart =
              Instrument.frequencyFromPitch(basePitch + 60) *
              Math.pow(
                2,
                (Config.bitcrusherFreqRange - 1 - freqSettingStart) *
                  Config.bitcrusherOctaveStep
              ),
            freqEnd =
              Instrument.frequencyFromPitch(basePitch + 60) *
              Math.pow(
                2,
                (Config.bitcrusherFreqRange - 1 - freqSettingEnd) *
                  Config.bitcrusherOctaveStep
              ),
            phaseDeltaStart = Math.min(1, freqStart / samplesPerSecond),
            phaseDeltaEnd = Math.min(1, freqEnd / samplesPerSecond);
          (this.bitcrusherPhaseDelta = phaseDeltaStart),
            (this.bitcrusherPhaseDeltaScale = Math.pow(
              phaseDeltaEnd / phaseDeltaStart,
              1 / roundedSamplesPerTick
            ));
          const scaleStart =
              2 *
              Config.bitcrusherBaseVolume *
              Math.pow(
                2,
                1 -
                  Math.pow(
                    2,
                    0.5 *
                      (Config.bitcrusherQuantizationRange -
                        1 -
                        quantizationSettingStart)
                  )
              ),
            scaleEnd =
              2 *
              Config.bitcrusherBaseVolume *
              Math.pow(
                2,
                1 -
                  Math.pow(
                    2,
                    0.5 *
                      (Config.bitcrusherQuantizationRange -
                        1 -
                        quantizationSettingEnd)
                  )
              );
          (this.bitcrusherScale = scaleStart),
            (this.bitcrusherScaleScale = Math.pow(
              scaleEnd / scaleStart,
              1 / roundedSamplesPerTick
            ));
          const foldLevelStart =
              2 *
              Config.bitcrusherBaseVolume *
              Math.pow(
                1.5,
                Config.bitcrusherQuantizationRange -
                  1 -
                  quantizationSettingStart
              ),
            foldLevelEnd =
              2 *
              Config.bitcrusherBaseVolume *
              Math.pow(
                1.5,
                Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd
              );
          (this.bitcrusherFoldLevel = foldLevelStart),
            (this.bitcrusherFoldLevelScale = Math.pow(
              foldLevelEnd / foldLevelStart,
              1 / roundedSamplesPerTick
            ));
        }
        let eqFilterVolume = 1;
        if (instrument.eqFilterType) {
          const eqFilterSettingsStart = instrument.eqFilter;
          null == instrument.eqSubFilters[1] &&
            (instrument.eqSubFilters[1] = new FilterSettings());
          const eqFilterSettingsEnd = instrument.eqSubFilters[1];
          let startSimpleFreq = instrument.eqFilterSimpleCut,
            startSimpleGain = instrument.eqFilterSimplePeak,
            endSimpleFreq = instrument.eqFilterSimpleCut,
            endSimpleGain = instrument.eqFilterSimplePeak,
            filterChanges = !1,
            startPoint;
          if (
            (synth.isModActive(
              Config.modulators.dictionary["eq filt cut"].index,
              channelIndex,
              instrumentIndex
            ) &&
              ((startSimpleFreq = synth.getModValue(
                Config.modulators.dictionary["eq filt cut"].index,
                channelIndex,
                instrumentIndex,
                !1
              )),
              (endSimpleFreq = synth.getModValue(
                Config.modulators.dictionary["eq filt cut"].index,
                channelIndex,
                instrumentIndex,
                !0
              )),
              (filterChanges = !0)),
            synth.isModActive(
              Config.modulators.dictionary["eq filt peak"].index,
              channelIndex,
              instrumentIndex
            ) &&
              ((startSimpleGain = synth.getModValue(
                Config.modulators.dictionary["eq filt peak"].index,
                channelIndex,
                instrumentIndex,
                !1
              )),
              (endSimpleGain = synth.getModValue(
                Config.modulators.dictionary["eq filt peak"].index,
                channelIndex,
                instrumentIndex,
                !0
              )),
              (filterChanges = !0)),
            filterChanges)
          ) {
            eqFilterSettingsStart.convertLegacySettingsForSynth(
              startSimpleFreq,
              startSimpleGain
            ),
              eqFilterSettingsEnd.convertLegacySettingsForSynth(
                endSimpleFreq,
                endSimpleGain
              ),
              (startPoint = eqFilterSettingsStart.controlPoints[0]);
            let endPoint = eqFilterSettingsEnd.controlPoints[0];
            startPoint.toCoefficients(
              Synth.tempFilterStartCoefficients,
              samplesPerSecond,
              1,
              1
            ),
              endPoint.toCoefficients(
                Synth.tempFilterEndCoefficients,
                samplesPerSecond,
                1,
                1
              ),
              this.eqFilters.length < 1 &&
                (this.eqFilters[0] = new DynamicBiquadFilter()),
              this.eqFilters[0].loadCoefficientsWithGradient(
                Synth.tempFilterStartCoefficients,
                Synth.tempFilterEndCoefficients,
                1 / roundedSamplesPerTick,
                0 == startPoint.type
              );
          } else
            eqFilterSettingsStart.convertLegacySettingsForSynth(
              startSimpleFreq,
              startSimpleGain,
              !0
            ),
              (startPoint = eqFilterSettingsStart.controlPoints[0]),
              startPoint.toCoefficients(
                Synth.tempFilterStartCoefficients,
                samplesPerSecond,
                1,
                1
              ),
              this.eqFilters.length < 1 &&
                (this.eqFilters[0] = new DynamicBiquadFilter()),
              this.eqFilters[0].loadCoefficientsWithGradient(
                Synth.tempFilterStartCoefficients,
                Synth.tempFilterStartCoefficients,
                1 / roundedSamplesPerTick,
                0 == startPoint.type
              );
          (eqFilterVolume *= startPoint.getVolumeCompensationMult()),
            (this.eqFilterCount = 1),
            (eqFilterVolume = Math.min(3, eqFilterVolume));
        } else {
          const eqFilterSettings =
            null != instrument.tmpEqFilterStart
              ? instrument.tmpEqFilterStart
              : instrument.eqFilter;
          for (let i = 0; i < eqFilterSettings.controlPointCount; i++) {
            let startPoint = eqFilterSettings.controlPoints[i],
              endPoint =
                null != instrument.tmpEqFilterEnd &&
                null != instrument.tmpEqFilterEnd.controlPoints[i]
                  ? instrument.tmpEqFilterEnd.controlPoints[i]
                  : eqFilterSettings.controlPoints[i];
            startPoint.type != endPoint.type && (startPoint = endPoint),
              startPoint.toCoefficients(
                Synth.tempFilterStartCoefficients,
                samplesPerSecond,
                1,
                1
              ),
              endPoint.toCoefficients(
                Synth.tempFilterEndCoefficients,
                samplesPerSecond,
                1,
                1
              ),
              this.eqFilters.length <= i &&
                (this.eqFilters[i] = new DynamicBiquadFilter()),
              this.eqFilters[i].loadCoefficientsWithGradient(
                Synth.tempFilterStartCoefficients,
                Synth.tempFilterEndCoefficients,
                1 / roundedSamplesPerTick,
                0 == startPoint.type
              ),
              (eqFilterVolume *= startPoint.getVolumeCompensationMult());
          }
          (this.eqFilterCount = eqFilterSettings.controlPointCount),
            (eqFilterVolume = Math.min(3, eqFilterVolume));
        }
        const mainInstrumentVolume = Synth.instrumentVolumeToVolumeMult(
          instrument.volume
        );
        this.mixVolume = mainInstrumentVolume;
        let mixVolumeEnd = mainInstrumentVolume;
        if (
          synth.isModActive(
            Config.modulators.dictionary["mix volume"].index,
            channelIndex,
            instrumentIndex
          )
        ) {
          const startVal = synth.getModValue(
              Config.modulators.dictionary["mix volume"].index,
              channelIndex,
              instrumentIndex,
              !1
            ),
            endVal = synth.getModValue(
              Config.modulators.dictionary["mix volume"].index,
              channelIndex,
              instrumentIndex,
              !0
            );
          (this.mixVolume *=
            startVal <= 0
              ? (startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)
              : Synth.instrumentVolumeToVolumeMult(startVal)),
            (mixVolumeEnd *=
              endVal <= 0
                ? (endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)
                : Synth.instrumentVolumeToVolumeMult(endVal));
        }
        synth.isModActive(Config.modulators.dictionary["song volume"].index) &&
          ((this.mixVolume *=
            synth.getModValue(
              Config.modulators.dictionary["song volume"].index,
              void 0,
              void 0,
              !1
            ) / 100),
          (mixVolumeEnd *=
            synth.getModValue(
              Config.modulators.dictionary["song volume"].index,
              void 0,
              void 0,
              !0
            ) / 100)),
          (this.mixVolumeDelta =
            (mixVolumeEnd - this.mixVolume) / roundedSamplesPerTick);
        let eqFilterVolumeStart = eqFilterVolume,
          eqFilterVolumeEnd = eqFilterVolume,
          delayInputMultStart = 1,
          delayInputMultEnd = 1;
        if (usesPanning) {
          let usePanStart = instrument.pan,
            usePanEnd = instrument.pan;
          synth.isModActive(
            Config.modulators.dictionary.pan.index,
            channelIndex,
            instrumentIndex
          ) &&
            ((usePanStart = synth.getModValue(
              Config.modulators.dictionary.pan.index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (usePanEnd = synth.getModValue(
              Config.modulators.dictionary.pan.index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          let panStart = Math.max(
              -1,
              Math.min(1, (usePanStart - Config.panCenter) / Config.panCenter)
            ),
            panEnd = Math.max(
              -1,
              Math.min(1, (usePanEnd - Config.panCenter) / Config.panCenter)
            );
          const volumeStartL =
              1.414 * Math.cos((1 + panStart) * Math.PI * 0.25),
            volumeStartR = 1.414 * Math.cos((1 - panStart) * Math.PI * 0.25),
            volumeEndL = 1.414 * Math.cos((1 + panEnd) * Math.PI * 0.25),
            volumeEndR = 1.414 * Math.cos((1 - panEnd) * Math.PI * 0.25),
            maxDelaySamples = samplesPerSecond * Config.panDelaySecondsMax;
          let usePanDelayStart = instrument.panDelay,
            usePanDelayEnd = instrument.panDelay;
          synth.isModActive(
            Config.modulators.dictionary["pan delay"].index,
            channelIndex,
            instrumentIndex
          ) &&
            ((usePanDelayStart = synth.getModValue(
              Config.modulators.dictionary["pan delay"].index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (usePanDelayEnd = synth.getModValue(
              Config.modulators.dictionary["pan delay"].index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          const delayStart =
              (panStart * usePanDelayStart * maxDelaySamples) / 10,
            delayEnd = (panEnd * usePanDelayEnd * maxDelaySamples) / 10,
            delayStartL = Math.max(0, delayStart),
            delayStartR = Math.max(0, -delayStart),
            delayEndL = Math.max(0, delayEnd),
            delayEndR = Math.max(0, -delayEnd);
          (this.panningVolumeL = volumeStartL),
            (this.panningVolumeR = volumeStartR),
            (this.panningVolumeDeltaL =
              (volumeEndL - volumeStartL) / roundedSamplesPerTick),
            (this.panningVolumeDeltaR =
              (volumeEndR - volumeStartR) / roundedSamplesPerTick),
            (this.panningOffsetL =
              this.panningDelayPos -
              delayStartL +
              synth.panningDelayBufferSize),
            (this.panningOffsetR =
              this.panningDelayPos -
              delayStartR +
              synth.panningDelayBufferSize),
            (this.panningOffsetDeltaL =
              (delayEndL - delayStartL) / roundedSamplesPerTick),
            (this.panningOffsetDeltaR =
              (delayEndR - delayStartR) / roundedSamplesPerTick);
        }
        if (usesChorus) {
          let useChorusStart = instrument.chorus,
            useChorusEnd = instrument.chorus;
          synth.isModActive(
            Config.modulators.dictionary.chorus.index,
            channelIndex,
            instrumentIndex
          ) &&
            ((useChorusStart = synth.getModValue(
              Config.modulators.dictionary.chorus.index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (useChorusEnd = synth.getModValue(
              Config.modulators.dictionary.chorus.index,
              channelIndex,
              instrumentIndex,
              !0
            )));
          let chorusStart = Math.min(
              1,
              useChorusStart / (Config.chorusRange - 1)
            ),
            chorusEnd = Math.min(1, useChorusEnd / (Config.chorusRange - 1));
          (chorusStart = 0.6 * chorusStart + 0.4 * Math.pow(chorusStart, 6)),
            (chorusEnd = 0.6 * chorusEnd + 0.4 * Math.pow(chorusEnd, 6));
          const chorusCombinedMultStart =
              1 / Math.sqrt(3 * chorusStart * chorusStart + 1),
            chorusCombinedMultEnd =
              1 / Math.sqrt(3 * chorusEnd * chorusEnd + 1);
          (this.chorusVoiceMult = chorusStart),
            (this.chorusVoiceMultDelta =
              (chorusEnd - chorusStart) / roundedSamplesPerTick),
            (this.chorusCombinedMult = chorusCombinedMultStart),
            (this.chorusCombinedMultDelta =
              (chorusCombinedMultEnd - chorusCombinedMultStart) /
              roundedSamplesPerTick);
        }
        let maxEchoMult = 0,
          averageEchoDelaySeconds = 0;
        if (usesEcho) {
          let useEchoSustainStart = instrument.echoSustain,
            useEchoSustainEnd = instrument.echoSustain;
          synth.isModActive(
            Config.modulators.dictionary.echo.index,
            channelIndex,
            instrumentIndex
          ) &&
            ((useEchoSustainStart = Math.max(
              0,
              synth.getModValue(
                Config.modulators.dictionary.echo.index,
                channelIndex,
                instrumentIndex,
                !1
              )
            )),
            (useEchoSustainEnd = Math.max(
              0,
              synth.getModValue(
                Config.modulators.dictionary.echo.index,
                channelIndex,
                instrumentIndex,
                !0
              )
            )));
          const echoMultStart =
              0.9 *
              Math.min(
                1,
                Math.pow(useEchoSustainStart / Config.echoSustainRange, 1.1)
              ),
            echoMultEnd =
              0.9 *
              Math.min(
                1,
                Math.pow(useEchoSustainEnd / Config.echoSustainRange, 1.1)
              );
          (this.echoMult = echoMultStart),
            (this.echoMultDelta = Math.max(
              0,
              (echoMultEnd - echoMultStart) / roundedSamplesPerTick
            )),
            (maxEchoMult = Math.max(echoMultStart, echoMultEnd));
          let useEchoDelayStart = instrument.echoDelay,
            useEchoDelayEnd = instrument.echoDelay,
            ignoreTicks = !1;
          synth.isModActive(
            Config.modulators.dictionary["echo delay"].index,
            channelIndex,
            instrumentIndex
          ) &&
            ((useEchoDelayStart = synth.getModValue(
              Config.modulators.dictionary["echo delay"].index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (useEchoDelayEnd = synth.getModValue(
              Config.modulators.dictionary["echo delay"].index,
              channelIndex,
              instrumentIndex,
              !0
            )),
            (ignoreTicks = !0));
          const tmpEchoDelayOffsetStart = Math.round(
              (useEchoDelayStart + 1) *
                Config.echoDelayStepTicks *
                samplesPerTick
            ),
            tmpEchoDelayOffsetEnd = Math.round(
              (useEchoDelayEnd + 1) * Config.echoDelayStepTicks * samplesPerTick
            );
          null == this.echoDelayOffsetEnd || ignoreTicks
            ? (this.echoDelayOffsetStart = tmpEchoDelayOffsetStart)
            : (this.echoDelayOffsetStart = this.echoDelayOffsetEnd),
            (this.echoDelayOffsetEnd = tmpEchoDelayOffsetEnd),
            (averageEchoDelaySeconds =
              (0.5 * (this.echoDelayOffsetStart + this.echoDelayOffsetEnd)) /
              samplesPerSecond),
            (this.echoDelayOffsetRatio = 0),
            (this.echoDelayOffsetRatioDelta = 1 / roundedSamplesPerTick);
          const shelfRadians =
            (2 * Math.PI * Config.echoShelfHz) / synth.samplesPerSecond;
          Synth.tempFilterStartCoefficients.highShelf1stOrder(
            shelfRadians,
            Config.echoShelfGain
          ),
            (this.echoShelfA1 = Synth.tempFilterStartCoefficients.a[1]),
            (this.echoShelfB0 = Synth.tempFilterStartCoefficients.b[0]),
            (this.echoShelfB1 = Synth.tempFilterStartCoefficients.b[1]);
        }
        let maxReverbMult = 0;
        if (usesReverb) {
          let useReverbStart = instrument.reverb,
            useReverbEnd = instrument.reverb;
          synth.isModActive(
            Config.modulators.dictionary.reverb.index,
            channelIndex,
            instrumentIndex
          ) &&
            ((useReverbStart = synth.getModValue(
              Config.modulators.dictionary.reverb.index,
              channelIndex,
              instrumentIndex,
              !1
            )),
            (useReverbEnd = synth.getModValue(
              Config.modulators.dictionary.reverb.index,
              channelIndex,
              instrumentIndex,
              !0
            ))),
            synth.isModActive(
              Config.modulators.dictionary["song reverb"].index,
              channelIndex,
              instrumentIndex
            ) &&
              ((useReverbStart *=
                (synth.getModValue(
                  Config.modulators.dictionary["song reverb"].index,
                  void 0,
                  void 0,
                  !1
                ) -
                  Config.modulators.dictionary["song reverb"]
                    .convertRealFactor) /
                Config.reverbRange),
              (useReverbEnd *=
                (synth.getModValue(
                  Config.modulators.dictionary["song reverb"].index,
                  void 0,
                  void 0,
                  !0
                ) -
                  Config.modulators.dictionary["song reverb"]
                    .convertRealFactor) /
                Config.reverbRange));
          const reverbStart =
              0.425 *
              Math.min(1, Math.pow(useReverbStart / Config.reverbRange, 0.667)),
            reverbEnd =
              0.425 *
              Math.min(1, Math.pow(useReverbEnd / Config.reverbRange, 0.667));
          (this.reverbMult = reverbStart),
            (this.reverbMultDelta =
              (reverbEnd - reverbStart) / roundedSamplesPerTick),
            (maxReverbMult = Math.max(reverbStart, reverbEnd));
          const shelfRadians =
            (2 * Math.PI * Config.reverbShelfHz) / synth.samplesPerSecond;
          Synth.tempFilterStartCoefficients.highShelf1stOrder(
            shelfRadians,
            Config.reverbShelfGain
          ),
            (this.reverbShelfA1 = Synth.tempFilterStartCoefficients.a[1]),
            (this.reverbShelfB0 = Synth.tempFilterStartCoefficients.b[0]),
            (this.reverbShelfB1 = Synth.tempFilterStartCoefficients.b[1]);
        }
        if (this.tonesAddedInThisTick)
          (this.attentuationProgress = 0),
            (this.flushedSamples = 0),
            (this.flushingDelayLines = !1);
        else if (this.flushingDelayLines) {
          (eqFilterVolumeStart = 0),
            (eqFilterVolumeEnd = 0),
            (delayInputMultStart = 0),
            (delayInputMultEnd = 0);
          let totalDelaySamples = 0;
          usesChorus && (totalDelaySamples += synth.chorusDelayBufferSize),
            usesEcho && (totalDelaySamples += this.echoDelayLineL.length),
            usesReverb && (totalDelaySamples += Config.reverbDelayBufferSize),
            (this.flushedSamples += roundedSamplesPerTick),
            this.flushedSamples >= totalDelaySamples &&
              (this.deactivateAfterThisTick = !0);
        } else {
          0 == this.attentuationProgress
            ? (eqFilterVolumeEnd = 0)
            : ((eqFilterVolumeStart = 0), (eqFilterVolumeEnd = 0));
          const attenuationThreshold = 1 / 256,
            halfLifeMult = -Math.log2(attenuationThreshold);
          let delayDuration = 0;
          if (
            (usesChorus && (delayDuration += Config.chorusMaxDelay), usesEcho)
          ) {
            const attenuationPerSecond = Math.pow(
                maxEchoMult,
                1 / averageEchoDelaySeconds
              ),
              halfLife = -1 / Math.log2(attenuationPerSecond),
              echoDuration = halfLife * halfLifeMult;
            delayDuration += echoDuration;
          }
          if (usesReverb) {
            const averageMult = 2 * maxReverbMult,
              averageReverbDelaySeconds =
                Config.reverbDelayBufferSize / 4 / samplesPerSecond,
              attenuationPerSecond = Math.pow(
                averageMult,
                1 / averageReverbDelaySeconds
              ),
              halfLife = -1 / Math.log2(attenuationPerSecond),
              reverbDuration = halfLife * halfLifeMult;
            delayDuration += reverbDuration;
          }
          const secondsInTick = samplesPerTick / samplesPerSecond,
            progressInTick = secondsInTick / delayDuration,
            progressAtEndOfTick = this.attentuationProgress + progressInTick;
          progressAtEndOfTick >= 1 && (delayInputMultEnd = 0),
            (this.attentuationProgress = progressAtEndOfTick),
            this.attentuationProgress >= 1 && (this.flushingDelayLines = !0);
        }
        (this.eqFilterVolume = eqFilterVolumeStart),
          (this.eqFilterVolumeDelta =
            (eqFilterVolumeEnd - eqFilterVolumeStart) / roundedSamplesPerTick),
          (this.delayInputMult = delayInputMultStart),
          (this.delayInputMultDelta =
            (delayInputMultEnd - delayInputMultStart) / roundedSamplesPerTick);
      }
      updateWaves(instrument, samplesPerSecond) {
        if (((this.volumeScale = 1), 0 == instrument.type))
          (this.wave = this.aliases
            ? Config.rawChipWaves[instrument.chipWave].samples
            : Config.chipWaves[instrument.chipWave].samples),
            (this.isUsingAdvancedLoopControls =
              instrument.isUsingAdvancedLoopControls),
            (this.chipWaveLoopStart = instrument.chipWaveLoopStart),
            (this.chipWaveLoopEnd = instrument.chipWaveLoopEnd),
            (this.chipWaveLoopMode = instrument.chipWaveLoopMode),
            (this.chipWavePlayBackwards = instrument.chipWavePlayBackwards),
            (this.chipWaveStartOffset = instrument.chipWaveStartOffset),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (6 == instrument.type)
          (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (9 == instrument.type)
          (this.wave = this.aliases
            ? instrument.customChipWave
            : instrument.customChipWaveIntegral),
            (this.volumeScale = 0.05),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (2 == instrument.type)
          (this.wave = getDrumWave(
            instrument.chipNoise,
            inverseRealFourierTransform,
            scaleElementsByFactor
          )),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (5 == instrument.type)
          (this.wave = this.harmonicsWave.getCustomWave(
            instrument.harmonicsWave,
            instrument.type
          )),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (7 == instrument.type)
          (this.wave = this.harmonicsWave.getCustomWave(
            instrument.harmonicsWave,
            instrument.type
          )),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (3 == instrument.type)
          (this.wave = this.spectrumWave.getCustomWave(
            instrument.spectrumWave,
            8
          )),
            (this.unisonVoices = instrument.unisonVoices),
            (this.unisonSpread = instrument.unisonSpread),
            (this.unisonOffset = instrument.unisonOffset),
            (this.unisonExpression = instrument.unisonExpression),
            (this.unisonSign = instrument.unisonSign);
        else if (4 == instrument.type) {
          for (let i = 0; i < Config.drumCount; i++)
            this.drumsetSpectrumWaves[i].getCustomWave(
              instrument.drumsetSpectrumWaves[i],
              InstrumentState._drumsetIndexToSpectrumOctave(i)
            );
          this.wave = null;
        } else this.wave = null;
      }
      getDrumsetWave(pitch) {
        if (4 == this.type) return this.drumsetSpectrumWaves[pitch].wave;
        throw new Error("Unhandled instrument type in getDrumsetWave");
      }
      static drumsetIndexReferenceDelta(index) {
        return (
          Instrument.frequencyFromPitch(Config.spectrumBasePitch + 6 * index) /
          44100
        );
      }
      static _drumsetIndexToSpectrumOctave(index) {
        return (
          15 + Math.log2(InstrumentState.drumsetIndexReferenceDelta(index))
        );
      }
    }
    class ChannelState {
      constructor() {
        (this.instruments = []),
          (this.muted = !1),
          (this.singleSeamlessInstrument = null);
      }
    }
    class Synth {
      syncSongState() {
        const channelCount = this.song.getChannelCount();
        for (let i = this.channels.length; i < channelCount; i++)
          this.channels[i] = new ChannelState();
        this.channels.length = channelCount;
        for (let i = 0; i < channelCount; i++) {
          const channel = this.song.channels[i],
            channelState = this.channels[i];
          for (
            let j = channelState.instruments.length;
            j < channel.instruments.length;
            j++
          )
            channelState.instruments[j] = new InstrumentState();
          if (
            ((channelState.instruments.length = channel.instruments.length),
            channelState.muted != channel.muted &&
              ((channelState.muted = channel.muted), channelState.muted))
          )
            for (const instrumentState of channelState.instruments)
              instrumentState.resetAllEffects();
        }
      }
      initModFilters(song) {
        if (null != song)
          for (
            let channelIndex = 0;
            channelIndex < song.getChannelCount();
            channelIndex++
          )
            for (
              let instrumentIndex = 0;
              instrumentIndex < song.channels[channelIndex].instruments.length;
              instrumentIndex++
            ) {
              const instrument =
                song.channels[channelIndex].instruments[instrumentIndex];
              (instrument.tmpEqFilterStart = instrument.eqFilter),
                (instrument.tmpEqFilterEnd = null),
                (instrument.tmpNoteFilterStart = instrument.noteFilter),
                (instrument.tmpNoteFilterEnd = null);
            }
      }
      warmUpSynthesizer(song) {
        if (null != song) {
          this.syncSongState();
          const samplesPerTick = this.getSamplesPerTick();
          for (
            let channelIndex = 0;
            channelIndex < song.getChannelCount();
            channelIndex++
          )
            for (
              let instrumentIndex = 0;
              instrumentIndex < song.channels[channelIndex].instruments.length;
              instrumentIndex++
            ) {
              const instrument =
                  song.channels[channelIndex].instruments[instrumentIndex],
                instrumentState =
                  this.channels[channelIndex].instruments[instrumentIndex];
              Synth.getInstrumentSynthFunction(instrument),
                (instrumentState.vibratoTime = 0),
                (instrumentState.nextVibratoTime = 0),
                (instrumentState.envelopeTime = 0),
                (instrumentState.arpTime = 0),
                instrumentState.updateWaves(instrument, this.samplesPerSecond),
                instrumentState.allocateNecessaryBuffers(
                  this,
                  instrument,
                  samplesPerTick
                );
            }
        }
        var dummyArray = new Float32Array(1);
        (this.isPlayingSong = !0),
          this.synthesize(dummyArray, dummyArray, 1, !0),
          (this.isPlayingSong = !1);
      }
      computeLatestModValues() {
        if (null != this.song && this.song.modChannelCount > 0) {
          let latestModTimes = [],
            latestModInsTimes = [];
          (this.modValues = []),
            (this.nextModValues = []),
            (this.modInsValues = []),
            (this.nextModInsValues = []),
            (this.heldMods = []);
          for (
            let channel = 0;
            channel < this.song.pitchChannelCount + this.song.noiseChannelCount;
            channel++
          ) {
            (latestModInsTimes[channel] = []),
              (this.modInsValues[channel] = []),
              (this.nextModInsValues[channel] = []);
            for (
              let instrument = 0;
              instrument < this.song.channels[channel].instruments.length;
              instrument++
            )
              (this.modInsValues[channel][instrument] = []),
                (this.nextModInsValues[channel][instrument] = []),
                (latestModInsTimes[channel][instrument] = []);
          }
          let currentPart = this.beat * Config.partsPerBeat + this.part;
          for (
            let channelIndex =
              this.song.pitchChannelCount + this.song.noiseChannelCount;
            channelIndex < this.song.getChannelCount();
            channelIndex++
          )
            if (!this.song.channels[channelIndex].muted) {
              let pattern;
              for (let currentBar = this.bar; currentBar >= 0; currentBar--)
                if (
                  ((pattern = this.song.getPattern(channelIndex, currentBar)),
                  null != pattern)
                ) {
                  let instrumentIdx = pattern.instruments[0],
                    instrument =
                      this.song.channels[channelIndex].instruments[
                        instrumentIdx
                      ],
                    latestPinParts = [],
                    latestPinValues = [],
                    partsInBar =
                      currentBar == this.bar
                        ? currentPart
                        : this.findPartsInBar(currentBar);
                  for (const note of pattern.notes)
                    if (
                      note.start <= partsInBar &&
                      (null ==
                        latestPinParts[Config.modCount - 1 - note.pitches[0]] ||
                        note.end >
                          latestPinParts[Config.modCount - 1 - note.pitches[0]])
                    )
                      if (
                        (note.start == partsInBar &&
                          ((latestPinParts[
                            Config.modCount - 1 - note.pitches[0]
                          ] = note.start),
                          (latestPinValues[
                            Config.modCount - 1 - note.pitches[0]
                          ] = note.pins[0].size)),
                        note.end <= partsInBar)
                      )
                        (latestPinParts[Config.modCount - 1 - note.pitches[0]] =
                          note.end),
                          (latestPinValues[
                            Config.modCount - 1 - note.pitches[0]
                          ] = note.pins[note.pins.length - 1].size);
                      else {
                        latestPinParts[Config.modCount - 1 - note.pitches[0]] =
                          partsInBar;
                        for (
                          let pinIdx = 0;
                          pinIdx < note.pins.length;
                          pinIdx++
                        )
                          if (
                            note.pins[pinIdx].time + note.start >
                            partsInBar
                          ) {
                            const transitionLength =
                                note.pins[pinIdx].time -
                                note.pins[pinIdx - 1].time,
                              toNextBarLength =
                                partsInBar -
                                note.start -
                                note.pins[pinIdx - 1].time,
                              deltaVolume =
                                note.pins[pinIdx].size -
                                note.pins[pinIdx - 1].size;
                            (latestPinValues[
                              Config.modCount - 1 - note.pitches[0]
                            ] = Math.round(
                              note.pins[pinIdx - 1].size +
                                (deltaVolume * toNextBarLength) /
                                  transitionLength
                            )),
                              (pinIdx = note.pins.length);
                          }
                      }
                  for (let mod = 0; mod < Config.modCount; mod++)
                    if (null != latestPinParts[mod])
                      if (Config.modulators[instrument.modulators[mod]].forSong)
                        (null == latestModTimes[instrument.modulators[mod]] ||
                          currentBar *
                            Config.partsPerBeat *
                            this.song.beatsPerBar +
                            latestPinParts[mod] >
                            latestModTimes[instrument.modulators[mod]]) &&
                          (this.setModValue(
                            latestPinValues[mod],
                            latestPinValues[mod],
                            instrument.modChannels[mod],
                            instrument.modInstruments[mod],
                            instrument.modulators[mod]
                          ),
                          (latestModTimes[instrument.modulators[mod]] =
                            currentBar *
                              Config.partsPerBeat *
                              this.song.beatsPerBar +
                            latestPinParts[mod]));
                      else {
                        let usedInstruments = [];
                        if (
                          instrument.modInstruments[mod] ==
                          this.song.channels[instrument.modChannels[mod]]
                            .instruments.length
                        )
                          for (
                            let i = 0;
                            i <
                            this.song.channels[instrument.modChannels[mod]]
                              .instruments.length;
                            i++
                          )
                            usedInstruments.push(i);
                        else if (
                          instrument.modInstruments[mod] >
                          this.song.channels[instrument.modChannels[mod]]
                            .instruments.length
                        ) {
                          const tgtPattern = this.song.getPattern(
                            instrument.modChannels[mod],
                            currentBar
                          );
                          null != tgtPattern &&
                            (usedInstruments = tgtPattern.instruments);
                        } else
                          usedInstruments.push(instrument.modInstruments[mod]);
                        for (
                          let instrumentIndex = 0;
                          instrumentIndex < usedInstruments.length;
                          instrumentIndex++
                        ) {
                          const eqFilterParam =
                              instrument.modulators[mod] ==
                              Config.modulators.dictionary["eq filter"].index,
                            noteFilterParam =
                              instrument.modulators[mod] ==
                              Config.modulators.dictionary["note filter"].index;
                          let modulatorAdjust = instrument.modulators[mod];
                          if (
                            (eqFilterParam
                              ? (modulatorAdjust =
                                  Config.modulators.length +
                                  (0 | instrument.modFilterTypes[mod]))
                              : noteFilterParam &&
                                (modulatorAdjust =
                                  Config.modulators.length +
                                  1 +
                                  2 * Config.filterMaxPoints +
                                  (0 | instrument.modFilterTypes[mod])),
                            null ==
                              latestModInsTimes[instrument.modChannels[mod]][
                                usedInstruments[instrumentIndex]
                              ][modulatorAdjust] ||
                              currentBar *
                                Config.partsPerBeat *
                                this.song.beatsPerBar +
                                latestPinParts[mod] >
                                latestModInsTimes[instrument.modChannels[mod]][
                                  usedInstruments[instrumentIndex]
                                ][modulatorAdjust])
                          ) {
                            if (eqFilterParam) {
                              let tgtInstrument =
                                this.song.channels[instrument.modChannels[mod]]
                                  .instruments[
                                  usedInstruments[instrumentIndex]
                                ];
                              if (0 == instrument.modFilterTypes[mod])
                                tgtInstrument.tmpEqFilterStart =
                                  tgtInstrument.eqSubFilters[
                                    latestPinValues[mod]
                                  ];
                              else {
                                for (
                                  let i = 0;
                                  i < Config.filterMorphCount;
                                  i++
                                )
                                  null != tgtInstrument.tmpEqFilterStart &&
                                    tgtInstrument.tmpEqFilterStart ==
                                      tgtInstrument.eqSubFilters[i] &&
                                    ((tgtInstrument.tmpEqFilterStart =
                                      new FilterSettings()),
                                    tgtInstrument.tmpEqFilterStart.fromJsonObject(
                                      tgtInstrument.eqSubFilters[
                                        i
                                      ].toJsonObject()
                                    ),
                                    (i = Config.filterMorphCount));
                                null != tgtInstrument.tmpEqFilterStart &&
                                  Math.floor(
                                    (instrument.modFilterTypes[mod] - 1) / 2
                                  ) <
                                    tgtInstrument.tmpEqFilterStart
                                      .controlPointCount &&
                                  (instrument.modFilterTypes[mod] % 2
                                    ? (tgtInstrument.tmpEqFilterStart.controlPoints[
                                        Math.floor(
                                          (instrument.modFilterTypes[mod] - 1) /
                                            2
                                        )
                                      ].freq = latestPinValues[mod])
                                    : (tgtInstrument.tmpEqFilterStart.controlPoints[
                                        Math.floor(
                                          (instrument.modFilterTypes[mod] - 1) /
                                            2
                                        )
                                      ].gain = latestPinValues[mod]));
                              }
                              tgtInstrument.tmpEqFilterEnd =
                                tgtInstrument.tmpEqFilterStart;
                            } else if (noteFilterParam) {
                              let tgtInstrument =
                                this.song.channels[instrument.modChannels[mod]]
                                  .instruments[
                                  usedInstruments[instrumentIndex]
                                ];
                              if (0 == instrument.modFilterTypes[mod])
                                tgtInstrument.tmpNoteFilterStart =
                                  tgtInstrument.noteSubFilters[
                                    latestPinValues[mod]
                                  ];
                              else {
                                for (
                                  let i = 0;
                                  i < Config.filterMorphCount;
                                  i++
                                )
                                  null != tgtInstrument.tmpNoteFilterStart &&
                                    tgtInstrument.tmpNoteFilterStart ==
                                      tgtInstrument.noteSubFilters[i] &&
                                    ((tgtInstrument.tmpNoteFilterStart =
                                      new FilterSettings()),
                                    tgtInstrument.tmpNoteFilterStart.fromJsonObject(
                                      tgtInstrument.noteSubFilters[
                                        i
                                      ].toJsonObject()
                                    ),
                                    (i = Config.filterMorphCount));
                                null != tgtInstrument.tmpNoteFilterStart &&
                                  Math.floor(
                                    (instrument.modFilterTypes[mod] - 1) / 2
                                  ) <
                                    tgtInstrument.tmpNoteFilterStart
                                      .controlPointCount &&
                                  (instrument.modFilterTypes[mod] % 2
                                    ? (tgtInstrument.tmpNoteFilterStart.controlPoints[
                                        Math.floor(
                                          (instrument.modFilterTypes[mod] - 1) /
                                            2
                                        )
                                      ].freq = latestPinValues[mod])
                                    : (tgtInstrument.tmpNoteFilterStart.controlPoints[
                                        Math.floor(
                                          (instrument.modFilterTypes[mod] - 1) /
                                            2
                                        )
                                      ].gain = latestPinValues[mod]));
                              }
                              tgtInstrument.tmpNoteFilterEnd =
                                tgtInstrument.tmpNoteFilterStart;
                            } else
                              this.setModValue(
                                latestPinValues[mod],
                                latestPinValues[mod],
                                instrument.modChannels[mod],
                                usedInstruments[instrumentIndex],
                                modulatorAdjust
                              );
                            latestModInsTimes[instrument.modChannels[mod]][
                              usedInstruments[instrumentIndex]
                            ][modulatorAdjust] =
                              currentBar *
                                Config.partsPerBeat *
                                this.song.beatsPerBar +
                              latestPinParts[mod];
                          }
                        }
                      }
                }
            }
        }
      }
      determineInvalidModulators(instrument) {
        if (null != this.song)
          for (let mod = 0; mod < Config.modCount; mod++) {
            if (
              ((instrument.invalidModulators[mod] = !0),
              -1 == instrument.modChannels[mod])
            ) {
              0 != instrument.modulators[mod] &&
                (instrument.invalidModulators[mod] = !1);
              continue;
            }
            const channel = this.song.channels[instrument.modChannels[mod]];
            if (null == channel) continue;
            let tgtInstrumentList = [];
            tgtInstrumentList =
              instrument.modInstruments[mod] >= channel.instruments.length
                ? channel.instruments
                : [channel.instruments[instrument.modInstruments[mod]]];
            for (let i = 0; i < tgtInstrumentList.length; i++) {
              const tgtInstrument = tgtInstrumentList[i];
              if (null == tgtInstrument) continue;
              const str = Config.modulators[instrument.modulators[mod]].name;
              (12 !=
                Config.modulators[instrument.modulators[mod]]
                  .associatedEffect &&
                !(
                  tgtInstrument.effects &
                  (1 <<
                    Config.modulators[instrument.modulators[mod]]
                      .associatedEffect)
                )) ||
                (1 != tgtInstrument.type &&
                  11 != tgtInstrument.type &&
                  ("fm slider 1" == str ||
                    "fm slider 2" == str ||
                    "fm slider 3" == str ||
                    "fm slider 4" == str ||
                    "fm feedback" == str)) ||
                (11 != tgtInstrument.type &&
                  ("fm slider 5" == str || "fm slider 6" == str)) ||
                (6 != tgtInstrument.type &&
                  8 != tgtInstrument.type &&
                  ("pulse width" == str || "decimal offset" == str)) ||
                (8 != tgtInstrument.type &&
                  ("dynamism" == str ||
                    "spread" == str ||
                    "saw shape" == str)) ||
                (!tgtInstrument.getChord().arpeggiates &&
                  ("arp speed" == str || "reset arp" == str)) ||
                (tgtInstrument.eqFilterType && "eq filter" == str) ||
                (!tgtInstrument.eqFilterType &&
                  ("eq filt cut" == str || "eq filt peak" == str)) ||
                ("eq filter" == str &&
                  Math.floor((instrument.modFilterTypes[mod] + 1) / 2) >
                    tgtInstrument.getLargestControlPointCount(!1)) ||
                (tgtInstrument.noteFilterType && "note filter" == str) ||
                (!tgtInstrument.noteFilterType &&
                  ("note filt cut" == str || "note filt peak" == str)) ||
                ("note filter" == str &&
                  Math.floor((instrument.modFilterTypes[mod] + 1) / 2) >
                    tgtInstrument.getLargestControlPointCount(!0)) ||
                ((instrument.invalidModulators[mod] = !1),
                (i = tgtInstrumentList.length));
            }
          }
      }
      static operatorAmplitudeCurve(amplitude) {
        return (Math.pow(16, amplitude / 15) - 1) / 15;
      }
      get playing() {
        return this.isPlayingSong;
      }
      get recording() {
        return this.isRecording;
      }
      get playhead() {
        return this.playheadInternal;
      }
      set playhead(value) {
        if (null != this.song) {
          this.playheadInternal = Math.max(
            0,
            Math.min(this.song.barCount, value)
          );
          let remainder = this.playheadInternal;
          (this.bar = Math.floor(remainder)),
            (remainder = this.song.beatsPerBar * (remainder - this.bar)),
            (this.beat = Math.floor(remainder)),
            (remainder = Config.partsPerBeat * (remainder - this.beat)),
            (this.part = Math.floor(remainder)),
            (remainder = Config.ticksPerPart * (remainder - this.part)),
            (this.tick = Math.floor(remainder)),
            (this.tickSampleCountdown = 0),
            (this.isAtStartOfTick = !0),
            (this.prevBar = null);
        }
      }
      getSamplesPerBar() {
        if (null == this.song) throw new Error();
        return (
          this.getSamplesPerTick() *
          Config.ticksPerPart *
          Config.partsPerBeat *
          this.song.beatsPerBar
        );
      }
      getTicksIntoBar() {
        return (
          (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart +
          this.tick
        );
      }
      getCurrentPart() {
        return this.beat * Config.partsPerBeat + this.part;
      }
      findPartsInBar(bar) {
        if (null == this.song) return 0;
        let partsInBar = Config.partsPerBeat * this.song.beatsPerBar;
        for (
          let channel =
            this.song.pitchChannelCount + this.song.noiseChannelCount;
          channel < this.song.getChannelCount();
          channel++
        ) {
          let pattern = this.song.getPattern(channel, bar);
          if (null != pattern) {
            let instrument =
              this.song.channels[channel].instruments[pattern.instruments[0]];
            for (let mod = 0; mod < Config.modCount; mod++)
              if (
                instrument.modulators[mod] ==
                Config.modulators.dictionary["next bar"].index
              )
                for (const note of pattern.notes)
                  note.pitches[0] == Config.modCount - 1 - mod &&
                    partsInBar > note.start &&
                    (partsInBar = note.start);
          }
        }
        return partsInBar;
      }
      getTotalSamples(enableIntro, enableOutro, loop) {
        if (null == this.song) return -1;
        let startBar = enableIntro ? 0 : this.song.loopStart,
          endBar = enableOutro
            ? this.song.barCount
            : this.song.loopStart + this.song.loopLength,
          hasTempoMods = !1,
          hasNextBarMods = !1,
          prevTempo = this.song.tempo;
        for (
          let channel = this.song.getChannelCount() - 1;
          channel >= this.song.pitchChannelCount + this.song.noiseChannelCount;
          channel--
        )
          for (let bar = startBar; bar < endBar; bar++) {
            let pattern = this.song.getPattern(channel, bar);
            if (null != pattern) {
              let instrument =
                this.song.channels[channel].instruments[pattern.instruments[0]];
              for (let mod = 0; mod < Config.modCount; mod++)
                instrument.modulators[mod] ==
                  Config.modulators.dictionary.tempo.index &&
                  (hasTempoMods = !0),
                  instrument.modulators[mod] ==
                    Config.modulators.dictionary["next bar"].index &&
                    (hasNextBarMods = !0);
            }
          }
        if (startBar > 0) {
          let latestTempoPin = null,
            latestTempoValue = 0;
          for (let bar = startBar - 1; bar >= 0; bar--) {
            for (
              let channel = this.song.getChannelCount() - 1;
              channel >=
              this.song.pitchChannelCount + this.song.noiseChannelCount;
              channel--
            ) {
              let pattern = this.song.getPattern(channel, bar);
              if (null != pattern) {
                let instrumentIdx = pattern.instruments[0],
                  instrument =
                    this.song.channels[channel].instruments[instrumentIdx],
                  partsInBar = this.findPartsInBar(bar);
                for (const note of pattern.notes)
                  if (
                    instrument.modulators[
                      Config.modCount - 1 - note.pitches[0]
                    ] == Config.modulators.dictionary.tempo.index &&
                    note.start < partsInBar &&
                    (null == latestTempoPin || note.end > latestTempoPin)
                  )
                    if (note.end <= partsInBar)
                      (latestTempoPin = note.end),
                        (latestTempoValue =
                          note.pins[note.pins.length - 1].size);
                    else {
                      latestTempoPin = partsInBar;
                      for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++)
                        if (note.pins[pinIdx].time + note.start > partsInBar) {
                          const transitionLength =
                              note.pins[pinIdx].time -
                              note.pins[pinIdx - 1].time,
                            toNextBarLength =
                              partsInBar -
                              note.start -
                              note.pins[pinIdx - 1].time,
                            deltaVolume =
                              note.pins[pinIdx].size -
                              note.pins[pinIdx - 1].size;
                          (latestTempoValue = Math.round(
                            note.pins[pinIdx - 1].size +
                              (deltaVolume * toNextBarLength) / transitionLength
                          )),
                            (pinIdx = note.pins.length);
                        }
                    }
              }
            }
            null != latestTempoPin &&
              ((prevTempo =
                latestTempoValue +
                Config.modulators.dictionary.tempo.convertRealFactor),
              (bar = -1));
          }
        }
        if (hasTempoMods || hasNextBarMods) {
          let bar = startBar,
            ended = !1,
            totalSamples = 0;
          for (; !ended; ) {
            let partsInBar = Config.partsPerBeat * this.song.beatsPerBar,
              currentPart = 0;
            if (
              (hasNextBarMods && (partsInBar = this.findPartsInBar(bar)),
              hasTempoMods)
            ) {
              let foundMod = !1;
              for (
                let channel = this.song.getChannelCount() - 1;
                channel >=
                this.song.pitchChannelCount + this.song.noiseChannelCount;
                channel--
              )
                if (0 == foundMod) {
                  let pattern = this.song.getPattern(channel, bar);
                  if (null != pattern) {
                    let instrument =
                      this.song.channels[channel].instruments[
                        pattern.instruments[0]
                      ];
                    for (let mod = 0; mod < Config.modCount; mod++)
                      if (
                        0 == foundMod &&
                        instrument.modulators[mod] ==
                          Config.modulators.dictionary.tempo.index &&
                        pattern.notes.find(
                          (n) => n.pitches[0] == Config.modCount - 1 - mod
                        )
                      ) {
                        (foundMod = !0),
                          pattern.notes.sort(function (a, b) {
                            return a.start == b.start
                              ? a.pitches[0] - b.pitches[0]
                              : a.start - b.start;
                          });
                        for (const note of pattern.notes)
                          if (
                            note.pitches[0] == Config.modCount - 1 - mod &&
                            ((totalSamples +=
                              Math.min(
                                partsInBar - currentPart,
                                note.start - currentPart
                              ) *
                              Config.ticksPerPart *
                              this.getSamplesPerTickSpecificBPM(prevTempo)),
                            note.start < partsInBar)
                          )
                            for (
                              let pinIdx = 1;
                              pinIdx < note.pins.length;
                              pinIdx++
                            ) {
                              if (
                                note.pins[pinIdx - 1].time + note.start <=
                                partsInBar
                              ) {
                                const tickLength =
                                    Config.ticksPerPart *
                                    Math.min(
                                      partsInBar -
                                        (note.start +
                                          note.pins[pinIdx - 1].time),
                                      note.pins[pinIdx].time -
                                        note.pins[pinIdx - 1].time
                                    ),
                                  prevPinTempo =
                                    note.pins[pinIdx - 1].size +
                                    Config.modulators.dictionary.tempo
                                      .convertRealFactor;
                                let currPinTempo =
                                  note.pins[pinIdx].size +
                                  Config.modulators.dictionary.tempo
                                    .convertRealFactor;
                                note.pins[pinIdx].time + note.start >
                                  partsInBar &&
                                  (currPinTempo =
                                    note.pins[pinIdx - 1].size +
                                    ((note.pins[pinIdx].size -
                                      note.pins[pinIdx - 1].size) *
                                      (partsInBar -
                                        (note.start +
                                          note.pins[pinIdx - 1].time))) /
                                      (note.pins[pinIdx].time -
                                        note.pins[pinIdx - 1].time) +
                                    Config.modulators.dictionary.tempo
                                      .convertRealFactor);
                                let bpmScalar =
                                  (Config.partsPerBeat * Config.ticksPerPart) /
                                  60;
                                (totalSamples +=
                                  currPinTempo != prevPinTempo
                                    ? (-this.samplesPerSecond *
                                        tickLength *
                                        (Math.log(
                                          bpmScalar * currPinTempo * tickLength
                                        ) -
                                          Math.log(
                                            bpmScalar *
                                              prevPinTempo *
                                              tickLength
                                          ))) /
                                      (bpmScalar *
                                        (prevPinTempo - currPinTempo))
                                    : tickLength *
                                      this.getSamplesPerTickSpecificBPM(
                                        currPinTempo
                                      )),
                                  (prevTempo = currPinTempo);
                              }
                              currentPart = Math.min(
                                note.start + note.pins[pinIdx].time,
                                partsInBar
                              );
                            }
                      }
                  }
                }
            }
            (totalSamples +=
              (partsInBar - currentPart) *
              Config.ticksPerPart *
              this.getSamplesPerTickSpecificBPM(prevTempo)),
              bar++,
              0 != loop &&
                bar == this.song.loopStart + this.song.loopLength &&
                ((bar = this.song.loopStart), loop > 0 && loop--),
              bar >= endBar && (ended = !0);
          }
          return Math.ceil(totalSamples);
        }
        return (
          this.getSamplesPerBar() *
          this.getTotalBars(enableIntro, enableOutro, loop)
        );
      }
      getTotalBars(
        enableIntro,
        enableOutro,
        useLoopCount = this.loopRepeatCount
      ) {
        if (null == this.song) throw new Error();
        let bars = this.song.loopLength * (useLoopCount + 1);
        return (
          enableIntro && (bars += this.song.loopStart),
          enableOutro &&
            (bars +=
              this.song.barCount -
              (this.song.loopStart + this.song.loopLength)),
          bars
        );
      }
      constructor(song = null) {
        (this.samplesPerSecond = 44100),
          (this.song = null),
          (this.preferLowerLatency = !1),
          (this.anticipatePoorPerformance = !1),
          (this.liveInputDuration = 0),
          (this.liveBassInputDuration = 0),
          (this.liveInputStarted = !1),
          (this.liveBassInputStarted = !1),
          (this.liveInputPitches = []),
          (this.liveBassInputPitches = []),
          (this.liveInputChannel = 0),
          (this.liveBassInputChannel = 0),
          (this.liveInputInstruments = []),
          (this.liveBassInputInstruments = []),
          (this.loopRepeatCount = -1),
          (this.volume = 1),
          (this.oscRefreshEventTimer = 0),
          (this.oscEnabled = !0),
          (this.enableMetronome = !1),
          (this.countInMetronome = !1),
          (this.renderingSong = !1),
          (this.heldMods = []),
          (this.wantToSkip = !1),
          (this.playheadInternal = 0),
          (this.bar = 0),
          (this.prevBar = null),
          (this.nextBar = null),
          (this.beat = 0),
          (this.part = 0),
          (this.tick = 0),
          (this.isAtStartOfTick = !0),
          (this.isAtEndOfTick = !0),
          (this.tickSampleCountdown = 0),
          (this.modValues = []),
          (this.modInsValues = []),
          (this.nextModValues = []),
          (this.nextModInsValues = []),
          (this.isPlayingSong = !1),
          (this.isRecording = !1),
          (this.liveInputEndTime = 0),
          (this.browserAutomaticallyClearsAudioBuffer = !0),
          (this.tempDrumSetControlPoint = new FilterControlPoint()),
          (this.tempFrequencyResponse = new FrequencyResponse()),
          (this.loopBarStart = -1),
          (this.loopBarEnd = -1),
          (this.channels = []),
          (this.tonePool = new Deque()),
          (this.tempMatchedPitchTones = Array(Config.maxChordSize).fill(null)),
          (this.startedMetronome = !1),
          (this.metronomeSamplesRemaining = -1),
          (this.metronomeAmplitude = 0),
          (this.metronomePrevAmplitude = 0),
          (this.metronomeFilter = 0),
          (this.limit = 0),
          (this.tempMonoInstrumentSampleBuffer = null),
          (this.audioCtx = null),
          (this.scriptNode = null),
          (this.audioProcessCallback = (audioProcessingEvent) => {
            const outputBuffer = audioProcessingEvent.outputBuffer,
              outputDataL = outputBuffer.getChannelData(0),
              outputDataR = outputBuffer.getChannelData(1);
            if (
              (!this.browserAutomaticallyClearsAudioBuffer ||
                (0 == outputDataL[0] &&
                  0 == outputDataR[0] &&
                  0 == outputDataL[outputBuffer.length - 1] &&
                  0 == outputDataR[outputBuffer.length - 1]) ||
                (this.browserAutomaticallyClearsAudioBuffer = !1),
              !this.browserAutomaticallyClearsAudioBuffer)
            ) {
              const length = outputBuffer.length;
              for (let i = 0; i < length; i++)
                (outputDataL[i] = 0), (outputDataR[i] = 0);
            }
            !this.isPlayingSong && performance.now() >= this.liveInputEndTime
              ? this.deactivateAudio()
              : (this.synthesize(
                  outputDataL,
                  outputDataR,
                  outputBuffer.length,
                  this.isPlayingSong
                ),
                this.oscEnabled &&
                  (this.oscRefreshEventTimer <= 0
                    ? (events.raise(
                        "oscillascopeUpdate",
                        outputDataL,
                        outputDataR
                      ),
                      (this.oscRefreshEventTimer = 2))
                    : this.oscRefreshEventTimer--));
          }),
          this.computeDelayBufferSizes(),
          null != song && this.setSong(song);
      }
      setSong(song) {
        "string" == typeof song
          ? (this.song = new Song(song))
          : song instanceof Song && (this.song = song),
          (this.prevBar = null);
      }
      computeDelayBufferSizes() {
        (this.panningDelayBufferSize = Synth.fittingPowerOfTwo(
          this.samplesPerSecond * Config.panDelaySecondsMax
        )),
          (this.panningDelayBufferMask = this.panningDelayBufferSize - 1),
          (this.chorusDelayBufferSize = Synth.fittingPowerOfTwo(
            this.samplesPerSecond * Config.chorusMaxDelay
          )),
          (this.chorusDelayBufferMask = this.chorusDelayBufferSize - 1);
      }
      activateAudio() {
        const bufferSize = this.anticipatePoorPerformance
          ? this.preferLowerLatency
            ? 2048
            : 4096
          : this.preferLowerLatency
            ? 512
            : 2048;
        if (
          null == this.audioCtx ||
          null == this.scriptNode ||
          this.scriptNode.bufferSize != bufferSize
        ) {
          null != this.scriptNode && this.deactivateAudio();
          const latencyHint = this.anticipatePoorPerformance
            ? this.preferLowerLatency
              ? "balanced"
              : "playback"
            : this.preferLowerLatency
              ? "interactive"
              : "balanced";
          (this.audioCtx =
            this.audioCtx ||
            new (window.AudioContext || window.webkitAudioContext)({
              latencyHint: latencyHint,
            })),
            (this.samplesPerSecond = this.audioCtx.sampleRate),
            (this.scriptNode = this.audioCtx.createScriptProcessor
              ? this.audioCtx.createScriptProcessor(bufferSize, 0, 2)
              : this.audioCtx.createJavaScriptNode(bufferSize, 0, 2)),
            (this.scriptNode.onaudioprocess = this.audioProcessCallback),
            (this.scriptNode.channelCountMode = "explicit"),
            (this.scriptNode.channelInterpretation = "speakers"),
            this.scriptNode.connect(this.audioCtx.destination),
            this.computeDelayBufferSizes();
        }
        this.audioCtx.resume();
      }
      deactivateAudio() {
        null != this.audioCtx &&
          null != this.scriptNode &&
          (this.scriptNode.disconnect(this.audioCtx.destination),
          (this.scriptNode = null),
          this.audioCtx.close && this.audioCtx.close(),
          (this.audioCtx = null));
      }
      maintainLiveInput() {
        this.activateAudio(), (this.liveInputEndTime = performance.now() + 1e4);
      }
      play() {
        this.isPlayingSong ||
          (this.initModFilters(this.song),
          this.computeLatestModValues(),
          this.activateAudio(),
          this.warmUpSynthesizer(this.song),
          (this.isPlayingSong = !0));
      }
      pause() {
        if (
          this.isPlayingSong &&
          ((this.isPlayingSong = !1),
          (this.isRecording = !1),
          (this.modValues = []),
          (this.nextModValues = []),
          (this.heldMods = []),
          null != this.song)
        ) {
          (this.song.inVolumeCap = 0), (this.song.outVolumeCap = 0);
          for (
            let channelIndex = 0;
            channelIndex <
            this.song.pitchChannelCount + this.song.noiseChannelCount;
            channelIndex++
          )
            (this.modInsValues[channelIndex] = []),
              (this.nextModInsValues[channelIndex] = []);
        }
      }
      startRecording() {
        (this.preferLowerLatency = !0), (this.isRecording = !0), this.play();
      }
      resetEffects() {
        if (((this.limit = 0), this.freeAllTones(), null != this.song))
          for (const channelState of this.channels)
            for (const instrumentState of channelState.instruments)
              instrumentState.resetAllEffects();
      }
      setModValue(
        volumeStart,
        volumeEnd,
        channelIndex,
        instrumentIndex,
        setting
      ) {
        let val = volumeStart + Config.modulators[setting].convertRealFactor,
          nextVal = volumeEnd + Config.modulators[setting].convertRealFactor;
        return (
          Config.modulators[setting].forSong
            ? (null != this.modValues[setting] &&
                this.modValues[setting] == val &&
                this.nextModValues[setting] == nextVal) ||
              ((this.modValues[setting] = val),
              (this.nextModValues[setting] = nextVal))
            : (null !=
                this.modInsValues[channelIndex][instrumentIndex][setting] &&
                this.modInsValues[channelIndex][instrumentIndex][setting] ==
                  val &&
                this.nextModInsValues[channelIndex][instrumentIndex][setting] ==
                  nextVal) ||
              ((this.modInsValues[channelIndex][instrumentIndex][setting] =
                val),
              (this.nextModInsValues[channelIndex][instrumentIndex][setting] =
                nextVal)),
          val
        );
      }
      getModValue(setting, channel, instrument, nextVal) {
        const forSong = Config.modulators[setting].forSong;
        if (forSong) {
          if (
            null != this.modValues[setting] &&
            null != this.nextModValues[setting]
          )
            return nextVal
              ? this.nextModValues[setting]
              : this.modValues[setting];
        } else if (
          null != channel &&
          null != instrument &&
          null != this.modInsValues[channel][instrument][setting] &&
          null != this.nextModInsValues[channel][instrument][setting]
        )
          return nextVal
            ? this.nextModInsValues[channel][instrument][setting]
            : this.modInsValues[channel][instrument][setting];
        return -1;
      }
      isAnyModActive(channel, instrument) {
        for (let setting = 0; setting < Config.modulators.length; setting++)
          if (
            (null != this.modValues && null != this.modValues[setting]) ||
            (null != this.modInsValues &&
              null != this.modInsValues[channel] &&
              null != this.modInsValues[channel][instrument] &&
              null != this.modInsValues[channel][instrument][setting])
          )
            return !0;
        return !1;
      }
      unsetMod(setting, channel, instrument) {
        if (
          this.isModActive(setting) ||
          (null != channel &&
            null != instrument &&
            this.isModActive(setting, channel, instrument))
        ) {
          (this.modValues[setting] = null),
            (this.nextModValues[setting] = null);
          for (let i = 0; i < this.heldMods.length; i++)
            null != channel && null != instrument
              ? this.heldMods[i].channelIndex == channel &&
                this.heldMods[i].instrumentIndex == instrument &&
                this.heldMods[i].setting == setting &&
                this.heldMods.splice(i, 1)
              : this.heldMods[i].setting == setting &&
                this.heldMods.splice(i, 1);
          null != channel &&
            null != instrument &&
            ((this.modInsValues[channel][instrument][setting] = null),
            (this.nextModInsValues[channel][instrument][setting] = null));
        }
      }
      isFilterModActive(forNoteFilter, channelIdx, instrumentIdx) {
        const instrument =
          this.song.channels[channelIdx].instruments[instrumentIdx];
        if (forNoteFilter) {
          if (instrument.noteFilterType) return !1;
          if (null != instrument.tmpNoteFilterEnd) return !0;
        } else {
          if (instrument.eqFilterType) return !1;
          if (null != instrument.tmpEqFilterEnd) return !0;
        }
        return !1;
      }
      isModActive(setting, channel, instrument) {
        const forSong = Config.modulators[setting].forSong;
        return forSong
          ? null != this.modValues && null != this.modValues[setting]
          : null != channel &&
              null != instrument &&
              null != this.modInsValues &&
              null != this.modInsValues[channel] &&
              null != this.modInsValues[channel][instrument] &&
              null != this.modInsValues[channel][instrument][setting];
      }
      forceHoldMods(volumeStart, channelIndex, instrumentIndex, setting) {
        let found = !1;
        for (let i = 0; i < this.heldMods.length; i++)
          this.heldMods[i].channelIndex == channelIndex &&
            this.heldMods[i].instrumentIndex == instrumentIndex &&
            this.heldMods[i].setting == setting &&
            ((this.heldMods[i].volume = volumeStart),
            (this.heldMods[i].holdFor = 24),
            (found = !0));
        found ||
          this.heldMods.push({
            volume: volumeStart,
            channelIndex: channelIndex,
            instrumentIndex: instrumentIndex,
            setting: setting,
            holdFor: 24,
          });
      }
      snapToStart() {
        (this.bar = 0), this.resetEffects(), this.snapToBar();
      }
      goToBar(bar) {
        (this.bar = bar),
          this.resetEffects(),
          (this.playheadInternal = this.bar);
      }
      snapToBar() {
        (this.playheadInternal = this.bar),
          (this.beat = 0),
          (this.part = 0),
          (this.tick = 0),
          (this.tickSampleCountdown = 0);
      }
      jumpIntoLoop() {
        if (
          this.song &&
          (this.bar < this.song.loopStart ||
            this.bar >= this.song.loopStart + this.song.loopLength)
        ) {
          const oldBar = this.bar;
          (this.bar = this.song.loopStart),
            (this.playheadInternal += this.bar - oldBar),
            this.playing && this.computeLatestModValues();
        }
      }
      goToNextBar() {
        if (!this.song) return;
        this.prevBar = this.bar;
        const oldBar = this.bar;
        this.bar++,
          this.bar >= this.song.barCount && (this.bar = 0),
          (this.playheadInternal += this.bar - oldBar),
          this.playing && this.computeLatestModValues();
      }
      goToPrevBar() {
        if (!this.song) return;
        this.prevBar = null;
        const oldBar = this.bar;
        this.bar--,
          (this.bar < 0 || this.bar >= this.song.barCount) &&
            (this.bar = this.song.barCount - 1),
          (this.playheadInternal += this.bar - oldBar),
          this.playing && this.computeLatestModValues();
      }
      getNextBar() {
        let nextBar = this.bar + 1;
        return (
          this.isRecording
            ? nextBar >= this.song.barCount &&
              (nextBar = this.song.barCount - 1)
            : this.bar != this.loopBarEnd || this.renderingSong
              ? 0 != this.loopRepeatCount &&
                nextBar ==
                  Math.max(
                    this.loopBarEnd + 1,
                    this.song.loopStart + this.song.loopLength
                  ) &&
                (nextBar = this.song.loopStart)
              : (nextBar = this.loopBarStart),
          nextBar
        );
      }
      skipBar() {
        if (!this.song) return;
        const samplesPerTick = this.getSamplesPerTick();
        (this.prevBar = this.bar),
          this.loopBarEnd != this.bar
            ? this.bar++
            : (this.bar = this.loopBarStart),
          (this.beat = 0),
          (this.part = 0),
          (this.tick = 0),
          (this.tickSampleCountdown = samplesPerTick),
          (this.isAtStartOfTick = !0),
          0 != this.loopRepeatCount &&
            this.bar ==
              Math.max(
                this.song.loopStart + this.song.loopLength,
                this.loopBarEnd
              ) &&
            ((this.bar = this.song.loopStart),
            -1 != this.loopBarStart && (this.bar = this.loopBarStart),
            this.loopRepeatCount > 0 && this.loopRepeatCount--);
      }
      synthesize(outputDataL, outputDataR, outputBufferLength, playSong = !0) {
        if (null == this.song) {
          for (let i = 0; i < outputBufferLength; i++)
            (outputDataL[i] = 0), (outputDataR[i] = 0);
          return void this.deactivateAudio();
        }
        const song = this.song;
        (this.song.inVolumeCap = 0), (this.song.outVolumeCap = 0);
        let samplesPerTick = this.getSamplesPerTick(),
          ended = !1;
        (this.tickSampleCountdown <= 0 ||
          this.tickSampleCountdown > samplesPerTick) &&
          ((this.tickSampleCountdown = samplesPerTick),
          (this.isAtStartOfTick = !0)),
          playSong &&
            (this.beat >= song.beatsPerBar &&
              ((this.beat = 0),
              (this.part = 0),
              (this.tick = 0),
              (this.tickSampleCountdown = samplesPerTick),
              (this.isAtStartOfTick = !0),
              (this.prevBar = this.bar),
              (this.bar = this.getNextBar()),
              this.bar <= this.prevBar &&
                this.loopRepeatCount > 0 &&
                this.loopRepeatCount--),
            this.bar >= song.barCount &&
              ((this.bar = 0),
              -1 != this.loopRepeatCount && ((ended = !0), this.pause()))),
          this.syncSongState(),
          (null == this.tempMonoInstrumentSampleBuffer ||
            this.tempMonoInstrumentSampleBuffer.length < outputBufferLength) &&
            (this.tempMonoInstrumentSampleBuffer = new Float32Array(
              outputBufferLength
            ));
        const volume = +this.volume,
          limitDecay =
            1 - Math.pow(0.5, this.song.limitDecay / this.samplesPerSecond),
          limitRise =
            1 - Math.pow(0.5, this.song.limitRise / this.samplesPerSecond);
        let limit = +this.limit,
          skippedBars = [],
          firstSkippedBufferIndex = -1,
          bufferIndex = 0;
        for (; bufferIndex < outputBufferLength && !ended; ) {
          (this.nextBar = this.getNextBar()),
            this.nextBar >= song.barCount && (this.nextBar = null);
          const samplesLeftInBuffer = outputBufferLength - bufferIndex,
            samplesLeftInTick = Math.ceil(this.tickSampleCountdown),
            runLength = Math.min(samplesLeftInTick, samplesLeftInBuffer),
            runEnd = bufferIndex + runLength;
          if (this.isPlayingSong || this.renderingSong) {
            for (
              let channelIndex =
                song.pitchChannelCount + song.noiseChannelCount;
              channelIndex < song.getChannelCount();
              channelIndex++
            ) {
              const channel = song.channels[channelIndex],
                channelState = this.channels[channelIndex];
              this.determineCurrentActiveTones(
                song,
                channelIndex,
                samplesPerTick,
                playSong
              );
              for (
                let instrumentIndex = 0;
                instrumentIndex < channel.instruments.length;
                instrumentIndex++
              ) {
                const instrumentState =
                  channelState.instruments[instrumentIndex];
                for (
                  let i = 0;
                  i < instrumentState.activeModTones.count();
                  i++
                ) {
                  const tone = instrumentState.activeModTones.get(i),
                    channel = song.channels[channelIndex],
                    instrument = channel.instruments[tone.instrumentIndex];
                  let mod = Config.modCount - 1 - tone.pitches[0];
                  ((instrument.modulators[mod] ==
                    Config.modulators.dictionary["note filter"].index ||
                    instrument.modulators[mod] ==
                      Config.modulators.dictionary["eq filter"].index) &&
                    null != instrument.modFilterTypes[mod] &&
                    instrument.modFilterTypes[mod] > 0) ||
                    this.playModTone(
                      song,
                      channelIndex,
                      samplesPerTick,
                      bufferIndex,
                      runLength,
                      tone,
                      !1,
                      !1
                    );
                }
              }
            }
            for (
              let channelIndex =
                song.pitchChannelCount + song.noiseChannelCount;
              channelIndex < song.getChannelCount();
              channelIndex++
            ) {
              const channel = song.channels[channelIndex],
                channelState = this.channels[channelIndex];
              for (
                let instrumentIndex = 0;
                instrumentIndex < channel.instruments.length;
                instrumentIndex++
              ) {
                const instrumentState =
                  channelState.instruments[instrumentIndex];
                for (
                  let i = 0;
                  i < instrumentState.activeModTones.count();
                  i++
                ) {
                  const tone = instrumentState.activeModTones.get(i),
                    channel = song.channels[channelIndex],
                    instrument = channel.instruments[tone.instrumentIndex];
                  let mod = Config.modCount - 1 - tone.pitches[0];
                  (instrument.modulators[mod] ==
                    Config.modulators.dictionary["note filter"].index ||
                    instrument.modulators[mod] ==
                      Config.modulators.dictionary["eq filter"].index) &&
                    null != instrument.modFilterTypes[mod] &&
                    instrument.modFilterTypes[mod] > 0 &&
                    this.playModTone(
                      song,
                      channelIndex,
                      samplesPerTick,
                      bufferIndex,
                      runLength,
                      tone,
                      !1,
                      !1
                    );
                }
              }
            }
          }
          if (this.wantToSkip) {
            let barVisited = skippedBars.includes(this.bar);
            if (barVisited && bufferIndex == firstSkippedBufferIndex)
              return void this.pause();
            -1 == firstSkippedBufferIndex &&
              (firstSkippedBufferIndex = bufferIndex),
              barVisited || skippedBars.push(this.bar),
              (this.wantToSkip = !1),
              this.skipBar();
          } else {
            for (
              let channelIndex = 0;
              channelIndex < song.pitchChannelCount + song.noiseChannelCount;
              channelIndex++
            ) {
              const channel = song.channels[channelIndex],
                channelState = this.channels[channelIndex];
              this.isAtStartOfTick &&
                (this.determineCurrentActiveTones(
                  song,
                  channelIndex,
                  samplesPerTick,
                  playSong && !this.countInMetronome
                ),
                this.determineLiveInputTones(
                  song,
                  channelIndex,
                  samplesPerTick
                ));
              for (
                let instrumentIndex = 0;
                instrumentIndex < channel.instruments.length;
                instrumentIndex++
              ) {
                const instrument = channel.instruments[instrumentIndex],
                  instrumentState = channelState.instruments[instrumentIndex];
                if (this.isAtStartOfTick) {
                  let tonesPlayedInThisInstrument =
                    instrumentState.activeTones.count() +
                    instrumentState.liveInputTones.count();
                  for (
                    let i = 0;
                    i < instrumentState.releasedTones.count();
                    i++
                  ) {
                    const tone = instrumentState.releasedTones.get(i);
                    if (
                      tone.ticksSinceReleased >=
                      Math.abs(instrument.getFadeOutTicks())
                    ) {
                      this.freeReleasedTone(instrumentState, i), i--;
                      continue;
                    }
                    const shouldFadeOutFast =
                      tonesPlayedInThisInstrument >=
                      Config.maximumTonesPerChannel;
                    this.computeTone(
                      song,
                      channelIndex,
                      samplesPerTick,
                      tone,
                      !0,
                      shouldFadeOutFast
                    ),
                      tonesPlayedInThisInstrument++;
                  }
                  instrumentState.awake &&
                    (instrumentState.computed ||
                      instrumentState.compute(
                        this,
                        instrument,
                        samplesPerTick,
                        Math.ceil(samplesPerTick),
                        null,
                        channelIndex,
                        instrumentIndex
                      ),
                    (instrumentState.computed = !1));
                }
                for (let i = 0; i < instrumentState.activeTones.count(); i++) {
                  const tone = instrumentState.activeTones.get(i);
                  this.playTone(channelIndex, bufferIndex, runLength, tone);
                }
                for (
                  let i = 0;
                  i < instrumentState.liveInputTones.count();
                  i++
                ) {
                  const tone = instrumentState.liveInputTones.get(i);
                  this.playTone(channelIndex, bufferIndex, runLength, tone);
                }
                for (
                  let i = 0;
                  i < instrumentState.releasedTones.count();
                  i++
                ) {
                  const tone = instrumentState.releasedTones.get(i);
                  this.playTone(channelIndex, bufferIndex, runLength, tone);
                }
                instrumentState.awake &&
                  Synth.effectsSynth(
                    this,
                    outputDataL,
                    outputDataR,
                    bufferIndex,
                    runLength,
                    instrumentState
                  );
                const tickSampleCountdown = this.tickSampleCountdown,
                  startRatio = 1 - tickSampleCountdown / samplesPerTick,
                  endRatio =
                    1 - (tickSampleCountdown - runLength) / samplesPerTick,
                  ticksIntoBar =
                    (this.beat * Config.partsPerBeat + this.part) *
                      Config.ticksPerPart +
                    this.tick,
                  partTimeTickStart = ticksIntoBar / Config.ticksPerPart,
                  partTimeTickEnd = (ticksIntoBar + 1) / Config.ticksPerPart,
                  partTimeStart =
                    partTimeTickStart +
                    (partTimeTickEnd - partTimeTickStart) * startRatio,
                  partTimeEnd =
                    partTimeTickStart +
                    (partTimeTickEnd - partTimeTickStart) * endRatio;
                let useVibratoSpeed = instrument.vibratoSpeed;
                (instrumentState.vibratoTime = instrumentState.nextVibratoTime),
                  this.isModActive(
                    Config.modulators.dictionary["vibrato speed"].index,
                    channelIndex,
                    instrumentIndex
                  ) &&
                    (useVibratoSpeed = this.getModValue(
                      Config.modulators.dictionary["vibrato speed"].index,
                      channelIndex,
                      instrumentIndex
                    )),
                  0 == useVibratoSpeed
                    ? ((instrumentState.vibratoTime = 0),
                      (instrumentState.nextVibratoTime = 0))
                    : (instrumentState.nextVibratoTime +=
                        0.1 * useVibratoSpeed * (partTimeEnd - partTimeStart));
              }
            }
            if (this.enableMetronome || this.countInMetronome)
              if (0 == this.part) {
                if (!this.startedMetronome) {
                  const midBeat =
                      song.beatsPerBar > 4 &&
                      song.beatsPerBar % 2 == 0 &&
                      this.beat == song.beatsPerBar / 2,
                    periods = 0 == this.beat ? 8 : midBeat ? 6 : 4,
                    hz = 0 == this.beat ? 1600 : midBeat ? 1200 : 800,
                    amplitude = 0 == this.beat ? 0.06 : midBeat ? 0.05 : 0.04,
                    samplesPerPeriod = this.samplesPerSecond / hz,
                    radiansPerSample = (2 * Math.PI) / samplesPerPeriod;
                  (this.metronomeSamplesRemaining = Math.floor(
                    samplesPerPeriod * periods
                  )),
                    (this.metronomeFilter = 2 * Math.cos(radiansPerSample)),
                    (this.metronomeAmplitude =
                      amplitude * Math.sin(radiansPerSample)),
                    (this.metronomePrevAmplitude = 0),
                    (this.startedMetronome = !0);
                }
                if (this.metronomeSamplesRemaining > 0) {
                  const stopIndex = Math.min(
                    runEnd,
                    bufferIndex + this.metronomeSamplesRemaining
                  );
                  this.metronomeSamplesRemaining -= stopIndex - bufferIndex;
                  for (let i = bufferIndex; i < stopIndex; i++) {
                    (outputDataL[i] += this.metronomeAmplitude),
                      (outputDataR[i] += this.metronomeAmplitude);
                    const tempAmplitude =
                      this.metronomeFilter * this.metronomeAmplitude -
                      this.metronomePrevAmplitude;
                    (this.metronomePrevAmplitude = this.metronomeAmplitude),
                      (this.metronomeAmplitude = tempAmplitude);
                  }
                }
              } else this.startedMetronome = !1;
            for (let i = bufferIndex; i < runEnd; i++) {
              const sampleL =
                  outputDataL[i] * song.masterGain * song.masterGain,
                sampleR = outputDataR[i] * song.masterGain * song.masterGain,
                absL = sampleL < 0 ? -sampleL : sampleL,
                absR = sampleR < 0 ? -sampleR : sampleR,
                abs = absL > absR ? absL : absR;
              this.song.inVolumeCap =
                this.song.inVolumeCap > abs ? this.song.inVolumeCap : abs;
              const limitRange =
                  +(abs > song.compressionThreshold) +
                  +(abs > song.limitThreshold),
                limitTarget =
                  +(0 == limitRange) *
                    ((0.8 * (abs + 1 - song.compressionThreshold) + 0.25) *
                      song.compressionRatio +
                      1.05 * (1 - song.compressionRatio)) +
                  1.05 * +(1 == limitRange) +
                  +(2 == limitRange) *
                    (1.05 *
                      ((abs + 1 - song.limitThreshold) * song.limitRatio +
                        (1 - song.limitThreshold)));
              limit +=
                (limitTarget - limit) *
                (limit < limitTarget ? limitRise : limitDecay);
              const limitedVolume =
                volume / (limit >= 1 ? 1.05 * limit : 0.8 * limit + 0.25);
              (outputDataL[i] = sampleL * limitedVolume),
                (outputDataR[i] = sampleR * limitedVolume),
                (this.song.outVolumeCap =
                  this.song.outVolumeCap > abs * limitedVolume
                    ? this.song.outVolumeCap
                    : abs * limitedVolume);
            }
            if (
              ((bufferIndex += runLength),
              (this.isAtStartOfTick = !1),
              (this.tickSampleCountdown -= runLength),
              this.tickSampleCountdown <= 0)
            ) {
              this.isAtStartOfTick = !0;
              for (const channelState of this.channels)
                for (const instrumentState of channelState.instruments) {
                  for (
                    let i = 0;
                    i < instrumentState.releasedTones.count();
                    i++
                  ) {
                    const tone = instrumentState.releasedTones.get(i);
                    tone.isOnLastTick
                      ? (this.freeReleasedTone(instrumentState, i), i--)
                      : tone.ticksSinceReleased++;
                  }
                  instrumentState.deactivateAfterThisTick &&
                    instrumentState.deactivate(),
                    (instrumentState.tonesAddedInThisTick = !1);
                }
              for (
                let channel = 0;
                channel <
                this.song.pitchChannelCount + this.song.noiseChannelCount;
                channel++
              )
                for (
                  let instrumentIdx = 0;
                  instrumentIdx <
                  this.song.channels[channel].instruments.length;
                  instrumentIdx++
                ) {
                  let instrument =
                      this.song.channels[channel].instruments[instrumentIdx],
                    instrumentState =
                      this.channels[channel].instruments[instrumentIdx],
                    useArpeggioSpeed = instrument.arpeggioSpeed;
                  this.isModActive(
                    Config.modulators.dictionary["arp speed"].index,
                    channel,
                    instrumentIdx
                  )
                    ? ((useArpeggioSpeed = Math.max(
                        0,
                        Math.min(
                          Config.arpSpeedScale.length - 1,
                          this.getModValue(
                            Config.modulators.dictionary["arp speed"].index,
                            channel,
                            instrumentIdx,
                            !1
                          )
                        )
                      )),
                      Number.isInteger(useArpeggioSpeed)
                        ? (instrumentState.arpTime +=
                            Config.arpSpeedScale[useArpeggioSpeed])
                        : (instrumentState.arpTime +=
                            (1 - (useArpeggioSpeed % 1)) *
                              Config.arpSpeedScale[
                                Math.floor(useArpeggioSpeed)
                              ] +
                            (useArpeggioSpeed % 1) *
                              Config.arpSpeedScale[
                                Math.ceil(useArpeggioSpeed)
                              ]))
                    : (instrumentState.arpTime +=
                        Config.arpSpeedScale[useArpeggioSpeed]);
                  let useEnvelopeSpeed = instrument.envelopeSpeed;
                  this.isModActive(
                    Config.modulators.dictionary["envelope speed"].index,
                    channel,
                    instrumentIdx
                  )
                    ? ((useEnvelopeSpeed = Math.max(
                        0,
                        Math.min(
                          Config.arpSpeedScale.length - 1,
                          this.getModValue(
                            Config.modulators.dictionary["envelope speed"]
                              .index,
                            channel,
                            instrumentIdx,
                            !1
                          )
                        )
                      )),
                      Number.isInteger(useEnvelopeSpeed)
                        ? (instrumentState.envelopeTime +=
                            Config.arpSpeedScale[useEnvelopeSpeed])
                        : (instrumentState.envelopeTime +=
                            (1 - (useEnvelopeSpeed % 1)) *
                              Config.arpSpeedScale[
                                Math.floor(useEnvelopeSpeed)
                              ] +
                            (useEnvelopeSpeed % 1) *
                              Config.arpSpeedScale[
                                Math.ceil(useEnvelopeSpeed)
                              ]))
                    : (instrumentState.envelopeTime +=
                        Config.arpSpeedScale[useEnvelopeSpeed]);
                }
              for (
                let channel = 0;
                channel <
                this.song.pitchChannelCount + this.song.noiseChannelCount;
                channel++
              )
                for (
                  let instrumentIdx = 0;
                  instrumentIdx <
                  this.song.channels[channel].instruments.length;
                  instrumentIdx++
                ) {
                  let instrument =
                    this.song.channels[channel].instruments[instrumentIdx];
                  null != instrument.tmpEqFilterEnd
                    ? (instrument.tmpEqFilterStart = instrument.tmpEqFilterEnd)
                    : (instrument.tmpEqFilterStart = instrument.eqFilter),
                    null != instrument.tmpNoteFilterEnd
                      ? (instrument.tmpNoteFilterStart =
                          instrument.tmpNoteFilterEnd)
                      : (instrument.tmpNoteFilterStart = instrument.noteFilter);
                }
              if (
                (this.tick++,
                (this.tickSampleCountdown += samplesPerTick),
                this.tick == Config.ticksPerPart)
              ) {
                (this.tick = 0),
                  this.part++,
                  this.liveInputDuration--,
                  this.liveBassInputDuration--;
                for (let i = 0; i < this.heldMods.length; i++)
                  this.heldMods[i].holdFor--,
                    this.heldMods[i].holdFor <= 0 && this.heldMods.splice(i, 1);
                this.part == Config.partsPerBeat &&
                  ((this.part = 0),
                  playSong &&
                    (this.beat++,
                    this.beat == song.beatsPerBar &&
                      ((this.beat = 0),
                      this.countInMetronome
                        ? (this.countInMetronome = !1)
                        : ((this.prevBar = this.bar),
                          (this.bar = this.getNextBar()),
                          this.bar <= this.prevBar &&
                            this.loopRepeatCount > 0 &&
                            this.loopRepeatCount--,
                          this.bar >= song.barCount &&
                            ((this.bar = 0),
                            -1 != this.loopRepeatCount &&
                              ((ended = !0),
                              this.resetEffects(),
                              this.pause()))))));
              }
            }
            for (let setting = 0; setting < Config.modulators.length; setting++)
              null != this.nextModValues &&
                null != this.nextModValues[setting] &&
                (this.modValues[setting] = this.nextModValues[setting]);
            this.isModActive(Config.modulators.dictionary.tempo.index) &&
              ((samplesPerTick = this.getSamplesPerTick()),
              (this.tickSampleCountdown = Math.min(
                this.tickSampleCountdown,
                samplesPerTick
              )));
            for (
              let channelIndex = 0;
              channelIndex <
              this.song.pitchChannelCount + this.song.noiseChannelCount;
              channelIndex++
            )
              for (
                let instrumentIndex = 0;
                instrumentIndex <
                this.channels[channelIndex].instruments.length;
                instrumentIndex++
              ) {
                const instrumentState =
                    this.channels[channelIndex].instruments[instrumentIndex],
                  instrument =
                    this.song.channels[channelIndex].instruments[
                      instrumentIndex
                    ];
                (instrumentState.nextVibratoTime =
                  instrumentState.nextVibratoTime %
                  (Config.vibratoTypes[instrument.vibratoType].period /
                    ((Config.ticksPerPart * samplesPerTick) /
                      this.samplesPerSecond))),
                  (instrumentState.arpTime =
                    instrumentState.arpTime % (2520 * Config.ticksPerArpeggio)),
                  (instrumentState.envelopeTime =
                    instrumentState.envelopeTime %
                    (Config.partsPerBeat *
                      Config.ticksPerPart *
                      this.song.beatsPerBar));
              }
            for (let setting = 0; setting < Config.modulators.length; setting++)
              for (
                let channel = 0;
                channel <
                this.song.pitchChannelCount + this.song.noiseChannelCount;
                channel++
              )
                for (
                  let instrument = 0;
                  instrument < this.song.getMaxInstrumentsPerChannel();
                  instrument++
                )
                  null != this.nextModInsValues &&
                    null != this.nextModInsValues[channel] &&
                    null != this.nextModInsValues[channel][instrument] &&
                    null !=
                      this.nextModInsValues[channel][instrument][setting] &&
                    (this.modInsValues[channel][instrument][setting] =
                      this.nextModInsValues[channel][instrument][setting]);
          }
        }
        (!Number.isFinite(limit) || Math.abs(limit) < 1e-24) && (limit = 0),
          (this.limit = limit),
          playSong &&
            !this.countInMetronome &&
            (this.playheadInternal =
              (((this.tick + 1 - this.tickSampleCountdown / samplesPerTick) /
                2 +
                this.part) /
                Config.partsPerBeat +
                this.beat) /
                song.beatsPerBar +
              this.bar);
      }
      freeTone(tone) {
        this.tonePool.pushBack(tone);
      }
      newTone() {
        if (this.tonePool.count() > 0) {
          const tone = this.tonePool.popBack();
          return (tone.freshlyAllocated = !0), tone;
        }
        return new Tone();
      }
      releaseTone(instrumentState, tone) {
        instrumentState.releasedTones.pushFront(tone),
          (tone.atNoteStart = !1),
          (tone.passedEndOfNote = !0);
      }
      freeReleasedTone(instrumentState, toneIndex) {
        this.freeTone(instrumentState.releasedTones.get(toneIndex)),
          instrumentState.releasedTones.remove(toneIndex);
      }
      freeAllTones() {
        for (const channelState of this.channels)
          for (const instrumentState of channelState.instruments) {
            for (; instrumentState.activeTones.count() > 0; )
              this.freeTone(instrumentState.activeTones.popBack());
            for (; instrumentState.activeModTones.count() > 0; )
              this.freeTone(instrumentState.activeModTones.popBack());
            for (; instrumentState.releasedTones.count() > 0; )
              this.freeTone(instrumentState.releasedTones.popBack());
            for (; instrumentState.liveInputTones.count() > 0; )
              this.freeTone(instrumentState.liveInputTones.popBack());
          }
      }
      determineLiveInputTones(song, channelIndex, samplesPerTick) {
        const channel = song.channels[channelIndex],
          channelState = this.channels[channelIndex],
          pitches = this.liveInputPitches,
          bassPitches = this.liveBassInputPitches;
        for (
          let instrumentIndex = 0;
          instrumentIndex < channel.instruments.length;
          instrumentIndex++
        ) {
          const instrumentState = channelState.instruments[instrumentIndex],
            toneList = instrumentState.liveInputTones;
          let toneCount = 0;
          if (
            this.liveInputDuration > 0 &&
            channelIndex == this.liveInputChannel &&
            pitches.length > 0 &&
            -1 != this.liveInputInstruments.indexOf(instrumentIndex)
          ) {
            const instrument = channel.instruments[instrumentIndex];
            if (instrument.getChord().singleTone) {
              let tone;
              toneList.count() <= toneCount
                ? ((tone = this.newTone()), toneList.pushBack(tone))
                : !instrument.getTransition().isSeamless &&
                    this.liveInputStarted
                  ? (this.releaseTone(instrumentState, toneList.get(toneCount)),
                    (tone = this.newTone()),
                    toneList.set(toneCount, tone))
                  : (tone = toneList.get(toneCount)),
                toneCount++;
              for (let i = 0; i < pitches.length; i++)
                tone.pitches[i] = pitches[i];
              (tone.pitchCount = pitches.length),
                (tone.chordSize = 1),
                (tone.instrumentIndex = instrumentIndex),
                (tone.note = tone.prevNote = tone.nextNote = null),
                (tone.atNoteStart = this.liveInputStarted),
                (tone.forceContinueAtStart = !1),
                (tone.forceContinueAtEnd = !1),
                this.computeTone(
                  song,
                  channelIndex,
                  samplesPerTick,
                  tone,
                  !1,
                  !1
                );
            } else {
              this.moveTonesIntoOrderedTempMatchedList(toneList, pitches);
              for (let i = 0; i < pitches.length; i++) {
                let tone;
                null != this.tempMatchedPitchTones[toneCount]
                  ? ((tone = this.tempMatchedPitchTones[toneCount]),
                    (this.tempMatchedPitchTones[toneCount] = null),
                    (1 == tone.pitchCount && tone.pitches[0] == pitches[i]) ||
                      (this.releaseTone(instrumentState, tone),
                      (tone = this.newTone())),
                    toneList.pushBack(tone))
                  : ((tone = this.newTone()), toneList.pushBack(tone)),
                  toneCount++,
                  (tone.pitches[0] = pitches[i]),
                  (tone.pitchCount = 1),
                  (tone.chordSize = pitches.length),
                  (tone.instrumentIndex = instrumentIndex),
                  (tone.note = tone.prevNote = tone.nextNote = null),
                  (tone.atNoteStart = this.liveInputStarted),
                  (tone.forceContinueAtStart = !1),
                  (tone.forceContinueAtEnd = !1),
                  this.computeTone(
                    song,
                    channelIndex,
                    samplesPerTick,
                    tone,
                    !1,
                    !1
                  );
              }
            }
          }
          if (
            this.liveBassInputDuration > 0 &&
            channelIndex == this.liveBassInputChannel &&
            bassPitches.length > 0 &&
            -1 != this.liveBassInputInstruments.indexOf(instrumentIndex)
          ) {
            const instrument = channel.instruments[instrumentIndex];
            if (instrument.getChord().singleTone) {
              let tone;
              toneList.count() <= toneCount
                ? ((tone = this.newTone()), toneList.pushBack(tone))
                : !instrument.getTransition().isSeamless &&
                    this.liveInputStarted
                  ? (this.releaseTone(instrumentState, toneList.get(toneCount)),
                    (tone = this.newTone()),
                    toneList.set(toneCount, tone))
                  : (tone = toneList.get(toneCount)),
                toneCount++;
              for (let i = 0; i < bassPitches.length; i++)
                tone.pitches[i] = bassPitches[i];
              (tone.pitchCount = bassPitches.length),
                (tone.chordSize = 1),
                (tone.instrumentIndex = instrumentIndex),
                (tone.note = tone.prevNote = tone.nextNote = null),
                (tone.atNoteStart = this.liveBassInputStarted),
                (tone.forceContinueAtStart = !1),
                (tone.forceContinueAtEnd = !1),
                this.computeTone(
                  song,
                  channelIndex,
                  samplesPerTick,
                  tone,
                  !1,
                  !1
                );
            } else {
              this.moveTonesIntoOrderedTempMatchedList(toneList, bassPitches);
              for (let i = 0; i < bassPitches.length; i++) {
                let tone;
                null != this.tempMatchedPitchTones[toneCount]
                  ? ((tone = this.tempMatchedPitchTones[toneCount]),
                    (this.tempMatchedPitchTones[toneCount] = null),
                    (1 == tone.pitchCount &&
                      tone.pitches[0] == bassPitches[i]) ||
                      (this.releaseTone(instrumentState, tone),
                      (tone = this.newTone())),
                    toneList.pushBack(tone))
                  : ((tone = this.newTone()), toneList.pushBack(tone)),
                  toneCount++,
                  (tone.pitches[0] = bassPitches[i]),
                  (tone.pitchCount = 1),
                  (tone.chordSize = bassPitches.length),
                  (tone.instrumentIndex = instrumentIndex),
                  (tone.note = tone.prevNote = tone.nextNote = null),
                  (tone.atNoteStart = this.liveBassInputStarted),
                  (tone.forceContinueAtStart = !1),
                  (tone.forceContinueAtEnd = !1),
                  this.computeTone(
                    song,
                    channelIndex,
                    samplesPerTick,
                    tone,
                    !1,
                    !1
                  );
              }
            }
          }
          for (; toneList.count() > toneCount; )
            this.releaseTone(instrumentState, toneList.popBack());
          this.clearTempMatchedPitchTones(toneCount, instrumentState);
        }
        (this.liveInputStarted = !1), (this.liveBassInputStarted = !1);
      }
      adjacentPatternHasCompatibleInstrumentTransition(
        song,
        channel,
        pattern,
        otherPattern,
        instrumentIndex,
        transition,
        chord,
        note,
        otherNote,
        forceContinue
      ) {
        if (
          song.patternInstruments &&
          -1 == otherPattern.instruments.indexOf(instrumentIndex)
        ) {
          if (
            pattern.instruments.length > 1 ||
            otherPattern.instruments.length > 1
          )
            return null;
          const otherInstrument =
            channel.instruments[otherPattern.instruments[0]];
          if (forceContinue) return otherInstrument.getChord();
          const otherTransition = otherInstrument.getTransition();
          return transition.includeAdjacentPatterns &&
            otherTransition.includeAdjacentPatterns &&
            otherTransition.slides == transition.slides
            ? otherInstrument.getChord()
            : null;
        }
        return forceContinue || transition.includeAdjacentPatterns
          ? chord
          : null;
      }
      static adjacentNotesHaveMatchingPitches(firstNote, secondNote) {
        if (firstNote.pitches.length != secondNote.pitches.length) return !1;
        const firstNoteInterval =
          firstNote.pins[firstNote.pins.length - 1].interval;
        for (const pitch of firstNote.pitches)
          if (-1 == secondNote.pitches.indexOf(pitch + firstNoteInterval))
            return !1;
        return !0;
      }
      moveTonesIntoOrderedTempMatchedList(toneList, notePitches) {
        for (let i = 0; i < toneList.count(); i++) {
          const tone = toneList.get(i),
            pitch = tone.pitches[0] + tone.lastInterval;
          for (let j = 0; j < notePitches.length; j++)
            if (notePitches[j] == pitch) {
              (this.tempMatchedPitchTones[j] = tone), toneList.remove(i), i--;
              break;
            }
        }
        for (; toneList.count() > 0; ) {
          const tone = toneList.popFront();
          for (let j = 0; j < this.tempMatchedPitchTones.length; j++)
            if (null == this.tempMatchedPitchTones[j]) {
              this.tempMatchedPitchTones[j] = tone;
              break;
            }
        }
      }
      determineCurrentActiveTones(
        song,
        channelIndex,
        samplesPerTick,
        playSong
      ) {
        const channel = song.channels[channelIndex],
          channelState = this.channels[channelIndex],
          pattern = song.getPattern(channelIndex, this.bar),
          currentPart = this.getCurrentPart(),
          currentTick = this.tick + Config.ticksPerPart * currentPart;
        if (playSong && song.getChannelIsMod(channelIndex)) {
          let notes = [],
            prevNotes = [],
            nextNotes = [],
            fillCount = Config.modCount;
          for (; fillCount--; )
            notes.push(null), prevNotes.push(null), nextNotes.push(null);
          if (null != pattern && !channel.muted)
            for (let i = 0; i < pattern.notes.length; i++)
              pattern.notes[i].end <= currentPart
                ? (null == prevNotes[pattern.notes[i].pitches[0]] ||
                    pattern.notes[i].end >
                      prevNotes[pattern.notes[i].pitches[0]].start) &&
                  (prevNotes[pattern.notes[i].pitches[0]] = pattern.notes[i])
                : pattern.notes[i].start <= currentPart &&
                    pattern.notes[i].end > currentPart
                  ? (notes[pattern.notes[i].pitches[0]] = pattern.notes[i])
                  : pattern.notes[i].start > currentPart &&
                    (null == nextNotes[pattern.notes[i].pitches[0]] ||
                      pattern.notes[i].start <
                        nextNotes[pattern.notes[i].pitches[0]].start) &&
                    (nextNotes[pattern.notes[i].pitches[0]] = pattern.notes[i]);
          let modToneCount = 0;
          const newInstrumentIndex =
              song.patternInstruments && null != pattern
                ? pattern.instruments[0]
                : 0,
            instrumentState = channelState.instruments[newInstrumentIndex],
            toneList = instrumentState.activeModTones;
          for (let mod = 0; mod < Config.modCount; mod++) {
            if (
              (null != notes[mod] &&
                (null != prevNotes[mod] &&
                  prevNotes[mod].end != notes[mod].start &&
                  (prevNotes[mod] = null),
                null != nextNotes[mod] &&
                  nextNotes[mod].start != notes[mod].end &&
                  (nextNotes[mod] = null)),
              null != channelState.singleSeamlessInstrument &&
                channelState.singleSeamlessInstrument != newInstrumentIndex &&
                channelState.singleSeamlessInstrument <
                  channelState.instruments.length)
            ) {
              const sourceInstrumentState =
                  channelState.instruments[
                    channelState.singleSeamlessInstrument
                  ],
                destInstrumentState =
                  channelState.instruments[newInstrumentIndex];
              for (; sourceInstrumentState.activeModTones.count() > 0; )
                destInstrumentState.activeModTones.pushFront(
                  sourceInstrumentState.activeModTones.popBack()
                );
            }
            if (
              ((channelState.singleSeamlessInstrument = newInstrumentIndex),
              null != notes[mod])
            ) {
              let prevNoteForThisInstrument = prevNotes[mod],
                nextNoteForThisInstrument = nextNotes[mod],
                forceContinueAtStart = !1,
                forceContinueAtEnd = !1;
              const atNoteStart =
                Config.ticksPerPart * notes[mod].start == currentTick &&
                this.isAtStartOfTick;
              let tone;
              if (toneList.count() <= modToneCount)
                (tone = this.newTone()), toneList.pushBack(tone);
              else if (atNoteStart && null == prevNoteForThisInstrument) {
                const oldTone = toneList.get(modToneCount);
                oldTone.isOnLastTick
                  ? this.freeTone(oldTone)
                  : this.releaseTone(instrumentState, oldTone),
                  (tone = this.newTone()),
                  toneList.set(modToneCount, tone);
              } else tone = toneList.get(modToneCount);
              modToneCount++;
              for (let i = 0; i < notes[mod].pitches.length; i++)
                tone.pitches[i] = notes[mod].pitches[i];
              (tone.pitchCount = notes[mod].pitches.length),
                (tone.chordSize = 1),
                (tone.instrumentIndex = newInstrumentIndex),
                (tone.note = notes[mod]),
                (tone.noteStartPart = notes[mod].start),
                (tone.noteEndPart = notes[mod].end),
                (tone.prevNote = prevNoteForThisInstrument),
                (tone.nextNote = nextNoteForThisInstrument),
                (tone.prevNotePitchIndex = 0),
                (tone.nextNotePitchIndex = 0),
                (tone.atNoteStart = atNoteStart),
                (tone.passedEndOfNote = !1),
                (tone.forceContinueAtStart = forceContinueAtStart),
                (tone.forceContinueAtEnd = forceContinueAtEnd);
            }
          }
          for (; toneList.count() > modToneCount; ) {
            const tone = toneList.popBack(),
              channel = song.channels[channelIndex];
            if (
              tone.instrumentIndex < channel.instruments.length &&
              !tone.isOnLastTick
            ) {
              const instrumentState =
                this.channels[channelIndex].instruments[tone.instrumentIndex];
              this.releaseTone(instrumentState, tone);
            } else this.freeTone(tone);
          }
        } else if (!song.getChannelIsMod(channelIndex)) {
          let note = null,
            prevNote = null,
            nextNote = null;
          if (
            playSong &&
            null != pattern &&
            !channel.muted &&
            (!this.isRecording || this.liveInputChannel != channelIndex)
          ) {
            for (let i = 0; i < pattern.notes.length; i++)
              if (pattern.notes[i].end <= currentPart)
                prevNote = pattern.notes[i];
              else if (
                pattern.notes[i].start <= currentPart &&
                pattern.notes[i].end > currentPart
              )
                note = pattern.notes[i];
              else if (pattern.notes[i].start > currentPart) {
                nextNote = pattern.notes[i];
                break;
              }
            null != note &&
              (null != prevNote &&
                prevNote.end != note.start &&
                (prevNote = null),
              null != nextNote &&
                nextNote.start != note.end &&
                (nextNote = null));
          }
          if (
            null != pattern &&
            (!song.layeredInstruments ||
              1 == channel.instruments.length ||
              (song.patternInstruments && 1 == pattern.instruments.length))
          ) {
            const newInstrumentIndex = song.patternInstruments
              ? pattern.instruments[0]
              : 0;
            if (
              null != channelState.singleSeamlessInstrument &&
              channelState.singleSeamlessInstrument != newInstrumentIndex &&
              channelState.singleSeamlessInstrument <
                channelState.instruments.length
            ) {
              const sourceInstrumentState =
                  channelState.instruments[
                    channelState.singleSeamlessInstrument
                  ],
                destInstrumentState =
                  channelState.instruments[newInstrumentIndex];
              for (; sourceInstrumentState.activeTones.count() > 0; )
                destInstrumentState.activeTones.pushFront(
                  sourceInstrumentState.activeTones.popBack()
                );
            }
            channelState.singleSeamlessInstrument = newInstrumentIndex;
          } else channelState.singleSeamlessInstrument = null;
          for (
            let instrumentIndex = 0;
            instrumentIndex < channel.instruments.length;
            instrumentIndex++
          ) {
            const instrumentState = channelState.instruments[instrumentIndex],
              toneList = instrumentState.activeTones;
            let toneCount = 0;
            if (
              null != note &&
              (!song.patternInstruments ||
                -1 != pattern.instruments.indexOf(instrumentIndex))
            ) {
              const instrument = channel.instruments[instrumentIndex];
              let prevNoteForThisInstrument = prevNote,
                nextNoteForThisInstrument = nextNote;
              const partsPerBar = Config.partsPerBeat * song.beatsPerBar,
                transition = instrument.getTransition(),
                chord = instrument.getChord();
              let forceContinueAtStart = !1,
                forceContinueAtEnd = !1,
                tonesInPrevNote = 0,
                tonesInNextNote = 0;
              if (0 == note.start) {
                let prevPattern =
                  null == this.prevBar
                    ? null
                    : song.getPattern(channelIndex, this.prevBar);
                if (null != prevPattern) {
                  const lastNote =
                    prevPattern.notes.length <= 0
                      ? null
                      : prevPattern.notes[prevPattern.notes.length - 1];
                  if (null != lastNote && lastNote.end == partsPerBar) {
                    const patternForcesContinueAtStart =
                        note.continuesLastPattern &&
                        Synth.adjacentNotesHaveMatchingPitches(lastNote, note),
                      chordOfCompatibleInstrument =
                        this.adjacentPatternHasCompatibleInstrumentTransition(
                          song,
                          channel,
                          pattern,
                          prevPattern,
                          instrumentIndex,
                          transition,
                          chord,
                          note,
                          lastNote,
                          patternForcesContinueAtStart
                        );
                    null != chordOfCompatibleInstrument &&
                      ((prevNoteForThisInstrument = lastNote),
                      (tonesInPrevNote = chordOfCompatibleInstrument.singleTone
                        ? 1
                        : prevNoteForThisInstrument.pitches.length),
                      (forceContinueAtStart = patternForcesContinueAtStart));
                  }
                }
              } else
                null != prevNoteForThisInstrument &&
                  (tonesInPrevNote = chord.singleTone
                    ? 1
                    : prevNoteForThisInstrument.pitches.length);
              if (note.end == partsPerBar) {
                let nextPattern =
                  null == this.nextBar
                    ? null
                    : song.getPattern(channelIndex, this.nextBar);
                if (null != nextPattern) {
                  const firstNote =
                    nextPattern.notes.length <= 0 ? null : nextPattern.notes[0];
                  if (null != firstNote && 0 == firstNote.start) {
                    const nextPatternForcesContinueAtStart =
                        firstNote.continuesLastPattern &&
                        Synth.adjacentNotesHaveMatchingPitches(note, firstNote),
                      chordOfCompatibleInstrument =
                        this.adjacentPatternHasCompatibleInstrumentTransition(
                          song,
                          channel,
                          pattern,
                          nextPattern,
                          instrumentIndex,
                          transition,
                          chord,
                          note,
                          firstNote,
                          nextPatternForcesContinueAtStart
                        );
                    null != chordOfCompatibleInstrument &&
                      ((nextNoteForThisInstrument = firstNote),
                      (tonesInNextNote = chordOfCompatibleInstrument.singleTone
                        ? 1
                        : nextNoteForThisInstrument.pitches.length),
                      (forceContinueAtEnd = nextPatternForcesContinueAtStart));
                  }
                }
              } else
                null != nextNoteForThisInstrument &&
                  (tonesInNextNote = chord.singleTone
                    ? 1
                    : nextNoteForThisInstrument.pitches.length);
              if (chord.singleTone) {
                const atNoteStart =
                  Config.ticksPerPart * note.start == currentTick;
                let tone;
                if (toneList.count() <= toneCount)
                  (tone = this.newTone()), toneList.pushBack(tone);
                else if (
                  !atNoteStart ||
                  ((transition.isSeamless ||
                    instrument.clicklessTransition ||
                    forceContinueAtStart) &&
                    null != prevNoteForThisInstrument)
                )
                  tone = toneList.get(toneCount);
                else {
                  const oldTone = toneList.get(toneCount);
                  oldTone.isOnLastTick
                    ? this.freeTone(oldTone)
                    : this.releaseTone(instrumentState, oldTone),
                    (tone = this.newTone()),
                    toneList.set(toneCount, tone);
                }
                toneCount++;
                for (let i = 0; i < note.pitches.length; i++)
                  tone.pitches[i] = note.pitches[i];
                (tone.pitchCount = note.pitches.length),
                  (tone.chordSize = 1),
                  (tone.instrumentIndex = instrumentIndex),
                  (tone.note = note),
                  (tone.noteStartPart = note.start),
                  (tone.noteEndPart = note.end),
                  (tone.prevNote = prevNoteForThisInstrument),
                  (tone.nextNote = nextNoteForThisInstrument),
                  (tone.prevNotePitchIndex = 0),
                  (tone.nextNotePitchIndex = 0),
                  (tone.atNoteStart = atNoteStart),
                  (tone.passedEndOfNote = !1),
                  (tone.forceContinueAtStart = forceContinueAtStart),
                  (tone.forceContinueAtEnd = forceContinueAtEnd),
                  this.computeTone(
                    song,
                    channelIndex,
                    samplesPerTick,
                    tone,
                    !1,
                    !1
                  );
              } else {
                const transition = instrument.getTransition();
                ((transition.isSeamless &&
                  !transition.slides &&
                  0 == chord.strumParts) ||
                  forceContinueAtStart) &&
                  Config.ticksPerPart * note.start == currentTick &&
                  null != prevNoteForThisInstrument &&
                  this.moveTonesIntoOrderedTempMatchedList(
                    toneList,
                    note.pitches
                  );
                let strumOffsetParts = 0;
                for (let i = 0; i < note.pitches.length; i++) {
                  let prevNoteForThisTone =
                      tonesInPrevNote > i ? prevNoteForThisInstrument : null,
                    noteForThisTone = note,
                    nextNoteForThisTone =
                      tonesInNextNote > i ? nextNoteForThisInstrument : null,
                    noteStartPart = noteForThisTone.start + strumOffsetParts,
                    passedEndOfNote = !1;
                  if (noteStartPart > currentPart) {
                    if (
                      !(
                        toneList.count() > i &&
                        (transition.isSeamless || forceContinueAtStart) &&
                        null != prevNoteForThisTone
                      )
                    )
                      break;
                    (nextNoteForThisTone = noteForThisTone),
                      (noteForThisTone = prevNoteForThisTone),
                      (prevNoteForThisTone = null),
                      (noteStartPart =
                        noteForThisTone.start + strumOffsetParts),
                      (passedEndOfNote = !0);
                  }
                  let noteEndPart = noteForThisTone.end;
                  (transition.isSeamless || forceContinueAtStart) &&
                    null != nextNoteForThisTone &&
                    (noteEndPart = Math.min(
                      Config.partsPerBeat * this.song.beatsPerBar,
                      noteEndPart + strumOffsetParts
                    )),
                    ((transition.continues || forceContinueAtStart) &&
                      null != prevNoteForThisTone) ||
                      (strumOffsetParts += chord.strumParts);
                  const atNoteStart =
                    Config.ticksPerPart * noteStartPart == currentTick;
                  let tone;
                  if (null != this.tempMatchedPitchTones[toneCount])
                    (tone = this.tempMatchedPitchTones[toneCount]),
                      (this.tempMatchedPitchTones[toneCount] = null),
                      toneList.pushBack(tone);
                  else if (toneList.count() <= toneCount)
                    (tone = this.newTone()), toneList.pushBack(tone);
                  else if (
                    !atNoteStart ||
                    ((transition.isSeamless || forceContinueAtStart) &&
                      null != prevNoteForThisTone)
                  )
                    tone = toneList.get(toneCount);
                  else {
                    const oldTone = toneList.get(toneCount);
                    oldTone.isOnLastTick
                      ? this.freeTone(oldTone)
                      : this.releaseTone(instrumentState, oldTone),
                      (tone = this.newTone()),
                      toneList.set(toneCount, tone);
                  }
                  toneCount++,
                    (tone.pitches[0] = noteForThisTone.pitches[i]),
                    (tone.pitchCount = 1),
                    (tone.chordSize = noteForThisTone.pitches.length),
                    (tone.instrumentIndex = instrumentIndex),
                    (tone.note = noteForThisTone),
                    (tone.noteStartPart = noteStartPart),
                    (tone.noteEndPart = noteEndPart),
                    (tone.prevNote = prevNoteForThisTone),
                    (tone.nextNote = nextNoteForThisTone),
                    (tone.prevNotePitchIndex = i),
                    (tone.nextNotePitchIndex = i),
                    (tone.atNoteStart = atNoteStart),
                    (tone.passedEndOfNote = passedEndOfNote),
                    (tone.forceContinueAtStart =
                      forceContinueAtStart && null != prevNoteForThisTone),
                    (tone.forceContinueAtEnd =
                      forceContinueAtEnd && null != nextNoteForThisTone),
                    this.computeTone(
                      song,
                      channelIndex,
                      samplesPerTick,
                      tone,
                      !1,
                      !1
                    );
                }
              }
            }
            for (; toneList.count() > toneCount; ) {
              const tone = toneList.popBack(),
                channel = song.channels[channelIndex];
              if (
                tone.instrumentIndex < channel.instruments.length &&
                !tone.isOnLastTick
              ) {
                const instrumentState =
                  channelState.instruments[tone.instrumentIndex];
                this.releaseTone(instrumentState, tone);
              } else this.freeTone(tone);
            }
            this.clearTempMatchedPitchTones(toneCount, instrumentState);
          }
        }
      }
      clearTempMatchedPitchTones(toneCount, instrumentState) {
        for (let i = toneCount; i < this.tempMatchedPitchTones.length; i++) {
          const oldTone = this.tempMatchedPitchTones[i];
          null != oldTone &&
            (oldTone.isOnLastTick
              ? this.freeTone(oldTone)
              : this.releaseTone(instrumentState, oldTone),
            (this.tempMatchedPitchTones[i] = null));
        }
      }
      playTone(channelIndex, bufferIndex, runLength, tone) {
        const channelState = this.channels[channelIndex],
          instrumentState = channelState.instruments[tone.instrumentIndex];
        null != instrumentState.synthesizer &&
          instrumentState.synthesizer(
            this,
            bufferIndex,
            runLength,
            tone,
            instrumentState
          ),
          tone.envelopeComputer.clearEnvelopes();
      }
      playModTone(
        song,
        channelIndex,
        samplesPerTick,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        released,
        shouldFadeOutFast
      ) {
        const channel = song.channels[channelIndex],
          instrument = channel.instruments[tone.instrumentIndex];
        if (null != tone.note) {
          const ticksIntoBar = this.getTicksIntoBar(),
            partTimeTickStart = ticksIntoBar / Config.ticksPerPart,
            partTimeTickEnd = (ticksIntoBar + 1) / Config.ticksPerPart,
            tickSampleCountdown = this.tickSampleCountdown,
            startRatio = 1 - tickSampleCountdown / samplesPerTick,
            endRatio =
              1 -
              (tickSampleCountdown - roundedSamplesPerTick) / samplesPerTick,
            partTimeStart =
              partTimeTickStart +
              (partTimeTickEnd - partTimeTickStart) * startRatio,
            partTimeEnd =
              partTimeTickStart +
              (partTimeTickEnd - partTimeTickStart) * endRatio,
            tickTimeStart = Config.ticksPerPart * partTimeStart,
            tickTimeEnd = Config.ticksPerPart * partTimeEnd,
            endPinIndex = tone.note.getEndPinIndex(this.getCurrentPart()),
            startPin = tone.note.pins[endPinIndex - 1],
            endPin = tone.note.pins[endPinIndex],
            startPinTick =
              (tone.note.start + startPin.time) * Config.ticksPerPart,
            endPinTick = (tone.note.start + endPin.time) * Config.ticksPerPart,
            ratioStart =
              (tickTimeStart - startPinTick) / (endPinTick - startPinTick),
            ratioEnd =
              (tickTimeEnd - startPinTick) / (endPinTick - startPinTick);
          (tone.expression =
            startPin.size + (endPin.size - startPin.size) * ratioStart),
            (tone.expressionDelta =
              startPin.size +
              (endPin.size - startPin.size) * ratioEnd -
              tone.expression),
            Synth.modSynth(
              this,
              bufferIndex,
              roundedSamplesPerTick,
              tone,
              instrument
            );
        }
      }
      static computeChordExpression(chordSize) {
        return 1 / (0.25 * (chordSize - 1) + 1);
      }
      computeTone(
        song,
        channelIndex,
        samplesPerTick,
        tone,
        released,
        shouldFadeOutFast
      ) {
        const roundedSamplesPerTick = Math.ceil(samplesPerTick),
          channel = song.channels[channelIndex],
          channelState = this.channels[channelIndex],
          instrument = channel.instruments[tone.instrumentIndex],
          instrumentState = channelState.instruments[tone.instrumentIndex];
        (instrumentState.awake = !0),
          (instrumentState.tonesAddedInThisTick = !0),
          instrumentState.computed ||
            instrumentState.compute(
              this,
              instrument,
              samplesPerTick,
              roundedSamplesPerTick,
              tone,
              channelIndex,
              tone.instrumentIndex
            );
        const transition = instrument.getTransition(),
          chord = instrument.getChord(),
          chordExpression = chord.singleTone
            ? 1
            : Synth.computeChordExpression(tone.chordSize),
          isNoiseChannel = song.getChannelIsNoise(channelIndex),
          intervalScale = isNoiseChannel ? Config.noiseInterval : 1,
          secondsPerPart =
            (Config.ticksPerPart * samplesPerTick) / this.samplesPerSecond,
          sampleTime = 1 / this.samplesPerSecond,
          beatsPerPart = 1 / Config.partsPerBeat,
          ticksIntoBar = this.getTicksIntoBar(),
          partTimeStart = ticksIntoBar / Config.ticksPerPart,
          partTimeEnd = (ticksIntoBar + 1) / Config.ticksPerPart,
          currentPart = this.getCurrentPart();
        let specialIntervalMult = 1;
        tone.specialIntervalExpressionMult = 1;
        let toneIsOnLastTick = shouldFadeOutFast,
          intervalStart = 0,
          intervalEnd = 0,
          fadeExpressionStart = 1,
          fadeExpressionEnd = 1,
          chordExpressionStart = chordExpression,
          chordExpressionEnd = chordExpression,
          expressionReferencePitch = 16,
          basePitch =
            Config.keys[song.key].basePitch +
            Config.pitchesPerOctave * song.octave,
          baseExpression = 1,
          pitchDamping = 48;
        if (3 == instrument.type)
          (baseExpression = Config.spectrumBaseExpression),
            isNoiseChannel &&
              ((basePitch = Config.spectrumBasePitch), (baseExpression *= 2)),
            (expressionReferencePitch = Config.spectrumBasePitch),
            (pitchDamping = 28);
        else if (4 == instrument.type)
          (basePitch = Config.spectrumBasePitch),
            (baseExpression = Config.drumsetBaseExpression),
            (expressionReferencePitch = basePitch);
        else if (2 == instrument.type)
          (basePitch = isNoiseChannel
            ? Config.chipNoises[instrument.chipNoise].basePitch
            : basePitch +
              Config.chipNoises[instrument.chipNoise].basePitch -
              12),
            (baseExpression = Config.noiseBaseExpression),
            (expressionReferencePitch = basePitch),
            (pitchDamping = Config.chipNoises[instrument.chipNoise].isSoft
              ? 24
              : 60);
        else if (1 == instrument.type || 11 == instrument.type)
          baseExpression = Config.fmBaseExpression;
        else if (0 == instrument.type)
          (baseExpression = Config.chipBaseExpression),
            Config.chipWaves[instrument.chipWave].isCustomSampled
              ? Config.chipWaves[instrument.chipWave].isPercussion
                ? (basePitch =
                    -12 *
                      Math.log2(
                        Config.chipWaves[instrument.chipWave].samples.length /
                          Config.chipWaves[instrument.chipWave].sampleRate
                      ) -
                    84.37 -
                    (-60 + Config.chipWaves[instrument.chipWave].rootKey))
                : (basePitch +=
                    -12 *
                      Math.log2(
                        Config.chipWaves[instrument.chipWave].samples.length /
                          Config.chipWaves[instrument.chipWave].sampleRate
                      ) -
                    96.37 -
                    (-60 + Config.chipWaves[instrument.chipWave].rootKey))
              : Config.chipWaves[instrument.chipWave].isSampled &&
                  !Config.chipWaves[instrument.chipWave].isPercussion
                ? (basePitch =
                    basePitch -
                    63 +
                    Config.chipWaves[instrument.chipWave].extraSampleDetune)
                : Config.chipWaves[instrument.chipWave].isSampled &&
                  Config.chipWaves[instrument.chipWave].isPercussion &&
                  (basePitch =
                    -51 +
                    Config.chipWaves[instrument.chipWave].extraSampleDetune);
        else if (9 == instrument.type)
          baseExpression = Config.chipBaseExpression;
        else if (5 == instrument.type)
          baseExpression = Config.harmonicsBaseExpression;
        else if (6 == instrument.type)
          baseExpression = Config.pwmBaseExpression;
        else if (8 == instrument.type)
          baseExpression = Config.supersawBaseExpression;
        else if (7 == instrument.type)
          baseExpression = Config.pickedStringBaseExpression;
        else {
          if (10 != instrument.type)
            throw new Error("Unknown instrument type in computeTone.");
          (baseExpression = 1),
            (expressionReferencePitch = 0),
            (pitchDamping = 1),
            (basePitch = 0);
        }
        if (
          ((tone.atNoteStart &&
            !transition.isSeamless &&
            !tone.forceContinueAtStart) ||
            tone.freshlyAllocated) &&
          (tone.reset(),
          0 == instrument.type && instrument.isUsingAdvancedLoopControls)
        ) {
          const chipWaveLength =
              Config.rawRawChipWaves[instrument.chipWave].samples.length - 1,
            firstOffset = instrument.chipWaveStartOffset / chipWaveLength,
            lastOffset = 0.999999999999999;
          for (let i = 0; i < Config.maxPitchOrOperatorCount; i++)
            (tone.phases[i] = instrument.chipWavePlayBackwards
              ? Math.max(0, Math.min(lastOffset, firstOffset))
              : Math.max(0, firstOffset)),
              (tone.directions[i] = instrument.chipWavePlayBackwards ? -1 : 1),
              (tone.chipWaveCompletions[i] = 0),
              (tone.chipWavePrevWaves[i] = 0),
              (tone.chipWaveCompletionsLastWave[i] = 0);
        }
        tone.freshlyAllocated = !1;
        for (let i = 0; i < Config.maxPitchOrOperatorCount; i++)
          (tone.phaseDeltas[i] = 0),
            (tone.phaseDeltaScales[i] = 0),
            (tone.operatorExpressions[i] = 0),
            (tone.operatorExpressionDeltas[i] = 0);
        (tone.expression = 0), (tone.expressionDelta = 0);
        for (
          let i = 0;
          i < (11 == instrument.type ? 6 : Config.operatorCount);
          i++
        )
          tone.operatorWaves[i] = Synth.getOperatorWave(
            instrument.operators[i].waveform,
            instrument.operators[i].pulseWidth
          );
        if (released) {
          const startTicksSinceReleased = tone.ticksSinceReleased,
            endTicksSinceReleased = tone.ticksSinceReleased + 1;
          intervalStart = intervalEnd = tone.lastInterval;
          const fadeOutTicks = Math.abs(instrument.getFadeOutTicks());
          (fadeExpressionStart = Synth.noteSizeToVolumeMult(
            (1 - startTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax
          )),
            (fadeExpressionEnd = Synth.noteSizeToVolumeMult(
              (1 - endTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax
            )),
            shouldFadeOutFast && (fadeExpressionEnd = 0),
            tone.ticksSinceReleased + 1 >= fadeOutTicks &&
              (toneIsOnLastTick = !0);
        } else if (null == tone.note)
          (fadeExpressionStart = fadeExpressionEnd = 1),
            (tone.lastInterval = 0),
            (tone.ticksSinceReleased = 0),
            (tone.liveInputSamplesHeld += roundedSamplesPerTick);
        else {
          const note = tone.note,
            nextNote = tone.nextNote,
            noteStartPart = tone.noteStartPart,
            noteEndPart = tone.noteEndPart,
            endPinIndex = note.getEndPinIndex(currentPart),
            startPin = note.pins[endPinIndex - 1],
            endPin = note.pins[endPinIndex],
            noteStartTick = noteStartPart * Config.ticksPerPart,
            noteEndTick = noteEndPart * Config.ticksPerPart,
            pinStart = (note.start + startPin.time) * Config.ticksPerPart,
            pinEnd = (note.start + endPin.time) * Config.ticksPerPart;
          tone.ticksSinceReleased = 0;
          const tickTimeStart = currentPart * Config.ticksPerPart + this.tick,
            tickTimeEnd = tickTimeStart + 1,
            noteTicksPassedTickStart = tickTimeStart - noteStartTick,
            noteTicksPassedTickEnd = tickTimeEnd - noteStartTick,
            pinRatioStart = Math.min(
              1,
              (tickTimeStart - pinStart) / (pinEnd - pinStart)
            ),
            pinRatioEnd = Math.min(
              1,
              (tickTimeEnd - pinStart) / (pinEnd - pinStart)
            );
          if (
            ((fadeExpressionStart = 1),
            (fadeExpressionEnd = 1),
            (intervalStart =
              startPin.interval +
              (endPin.interval - startPin.interval) * pinRatioStart),
            (intervalEnd =
              startPin.interval +
              (endPin.interval - startPin.interval) * pinRatioEnd),
            (tone.lastInterval = intervalEnd),
            (!transition.isSeamless && !tone.forceContinueAtEnd) ||
              null == nextNote)
          ) {
            const fadeOutTicks = -instrument.getFadeOutTicks();
            if (fadeOutTicks > 0) {
              const noteLengthTicks = noteEndTick - noteStartTick;
              (fadeExpressionStart *= Math.min(
                1,
                (noteLengthTicks - noteTicksPassedTickStart) / fadeOutTicks
              )),
                (fadeExpressionEnd *= Math.min(
                  1,
                  (noteLengthTicks - noteTicksPassedTickEnd) / fadeOutTicks
                )),
                tickTimeEnd >= noteStartTick + noteLengthTicks &&
                  (toneIsOnLastTick = !0);
            }
          }
        }
        tone.isOnLastTick = toneIsOnLastTick;
        let tmpNoteFilter = instrument.noteFilter,
          startPoint,
          endPoint;
        if (instrument.noteFilterType) {
          const noteFilterSettingsStart = instrument.noteFilter;
          null == instrument.noteSubFilters[1] &&
            (instrument.noteSubFilters[1] = new FilterSettings());
          const noteFilterSettingsEnd = instrument.noteSubFilters[1];
          let startSimpleFreq = instrument.noteFilterSimpleCut,
            startSimpleGain = instrument.noteFilterSimplePeak,
            endSimpleFreq = instrument.noteFilterSimpleCut,
            endSimpleGain = instrument.noteFilterSimplePeak,
            filterChanges = !1;
          this.isModActive(
            Config.modulators.dictionary["note filt cut"].index,
            channelIndex,
            tone.instrumentIndex
          ) &&
            ((startSimpleFreq = this.getModValue(
              Config.modulators.dictionary["note filt cut"].index,
              channelIndex,
              tone.instrumentIndex,
              !1
            )),
            (endSimpleFreq = this.getModValue(
              Config.modulators.dictionary["note filt cut"].index,
              channelIndex,
              tone.instrumentIndex,
              !0
            )),
            (filterChanges = !0)),
            this.isModActive(
              Config.modulators.dictionary["note filt peak"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((startSimpleGain = this.getModValue(
                Config.modulators.dictionary["note filt peak"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              )),
              (endSimpleGain = this.getModValue(
                Config.modulators.dictionary["note filt peak"].index,
                channelIndex,
                tone.instrumentIndex,
                !0
              )),
              (filterChanges = !0)),
            noteFilterSettingsStart.convertLegacySettingsForSynth(
              startSimpleFreq,
              startSimpleGain,
              !filterChanges
            ),
            noteFilterSettingsEnd.convertLegacySettingsForSynth(
              endSimpleFreq,
              endSimpleGain,
              !filterChanges
            ),
            (startPoint = noteFilterSettingsStart.controlPoints[0]),
            (endPoint = noteFilterSettingsEnd.controlPoints[0]),
            (instrument.noteFilter = noteFilterSettingsStart),
            (instrument.tmpNoteFilterStart = noteFilterSettingsStart);
        }
        const envelopeComputer = tone.envelopeComputer;
        let useEnvelopeSpeed = Config.arpSpeedScale[instrument.envelopeSpeed];
        this.isModActive(
          Config.modulators.dictionary["envelope speed"].index,
          channelIndex,
          tone.instrumentIndex
        ) &&
          ((useEnvelopeSpeed = Math.max(
            0,
            Math.min(
              Config.arpSpeedScale.length - 1,
              this.getModValue(
                Config.modulators.dictionary["envelope speed"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              )
            )
          )),
          (useEnvelopeSpeed = Number.isInteger(useEnvelopeSpeed)
            ? Config.arpSpeedScale[useEnvelopeSpeed]
            : (1 - (useEnvelopeSpeed % 1)) *
                Config.arpSpeedScale[Math.floor(useEnvelopeSpeed)] +
              (useEnvelopeSpeed % 1) *
                Config.arpSpeedScale[Math.ceil(useEnvelopeSpeed)])),
          envelopeComputer.computeEnvelopes(
            instrument,
            currentPart,
            instrumentState.envelopeTime,
            Config.ticksPerPart * partTimeStart,
            samplesPerTick / this.samplesPerSecond,
            tone,
            useEnvelopeSpeed
          );
        const envelopeStarts = tone.envelopeComputer.envelopeStarts,
          envelopeEnds = tone.envelopeComputer.envelopeEnds;
        if (
          ((instrument.noteFilter = tmpNoteFilter),
          null != tone.note && transition.slides)
        ) {
          const prevNote = tone.prevNote,
            nextNote = tone.nextNote;
          if (null != prevNote) {
            const intervalDiff =
              prevNote.pitches[tone.prevNotePitchIndex] +
              prevNote.pins[prevNote.pins.length - 1].interval -
              tone.pitches[0];
            if (
              (envelopeComputer.prevSlideStart &&
                (intervalStart +=
                  intervalDiff * envelopeComputer.prevSlideRatioStart),
              envelopeComputer.prevSlideEnd &&
                (intervalEnd +=
                  intervalDiff * envelopeComputer.prevSlideRatioEnd),
              !chord.singleTone)
            ) {
              const chordSizeDiff = prevNote.pitches.length - tone.chordSize;
              envelopeComputer.prevSlideStart &&
                (chordExpressionStart = Synth.computeChordExpression(
                  tone.chordSize +
                    chordSizeDiff * envelopeComputer.prevSlideRatioStart
                )),
                envelopeComputer.prevSlideEnd &&
                  (chordExpressionEnd = Synth.computeChordExpression(
                    tone.chordSize +
                      chordSizeDiff * envelopeComputer.prevSlideRatioEnd
                  ));
            }
          }
          if (null != nextNote) {
            const intervalDiff =
              nextNote.pitches[tone.nextNotePitchIndex] -
              (tone.pitches[0] +
                tone.note.pins[tone.note.pins.length - 1].interval);
            if (
              (envelopeComputer.nextSlideStart &&
                (intervalStart +=
                  intervalDiff * envelopeComputer.nextSlideRatioStart),
              envelopeComputer.nextSlideEnd &&
                (intervalEnd +=
                  intervalDiff * envelopeComputer.nextSlideRatioEnd),
              !chord.singleTone)
            ) {
              const chordSizeDiff = nextNote.pitches.length - tone.chordSize;
              envelopeComputer.nextSlideStart &&
                (chordExpressionStart = Synth.computeChordExpression(
                  tone.chordSize +
                    chordSizeDiff * envelopeComputer.nextSlideRatioStart
                )),
                envelopeComputer.nextSlideEnd &&
                  (chordExpressionEnd = Synth.computeChordExpression(
                    tone.chordSize +
                      chordSizeDiff * envelopeComputer.nextSlideRatioEnd
                  ));
            }
          }
        }
        if (effectsIncludePitchShift(instrument.effects)) {
          let pitchShift =
              Config.justIntonationSemitones[instrument.pitchShift] /
              intervalScale,
            pitchShiftScalarStart = 1,
            pitchShiftScalarEnd = 1;
          this.isModActive(
            Config.modulators.dictionary["pitch shift"].index,
            channelIndex,
            tone.instrumentIndex
          ) &&
            ((pitchShift =
              Config.justIntonationSemitones[
                Config.justIntonationSemitones.length - 1
              ]),
            (pitchShiftScalarStart =
              this.getModValue(
                Config.modulators.dictionary["pitch shift"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ) / Config.pitchShiftCenter),
            (pitchShiftScalarEnd =
              this.getModValue(
                Config.modulators.dictionary["pitch shift"].index,
                channelIndex,
                tone.instrumentIndex,
                !0
              ) / Config.pitchShiftCenter));
          const envelopeStart = envelopeStarts[18],
            envelopeEnd = envelopeEnds[18];
          (intervalStart += pitchShift * envelopeStart * pitchShiftScalarStart),
            (intervalEnd += pitchShift * envelopeEnd * pitchShiftScalarEnd);
        }
        if (
          effectsIncludeDetune(instrument.effects) ||
          this.isModActive(
            Config.modulators.dictionary["song detune"].index,
            channelIndex,
            tone.instrumentIndex
          )
        ) {
          const envelopeStart = envelopeStarts[19],
            envelopeEnd = envelopeEnds[19];
          let modDetuneStart = instrument.detune,
            modDetuneEnd = instrument.detune;
          this.isModActive(
            Config.modulators.dictionary.detune.index,
            channelIndex,
            tone.instrumentIndex
          ) &&
            ((modDetuneStart =
              this.getModValue(
                Config.modulators.dictionary.detune.index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ) + Config.detuneCenter),
            (modDetuneEnd =
              this.getModValue(
                Config.modulators.dictionary.detune.index,
                channelIndex,
                tone.instrumentIndex,
                !0
              ) + Config.detuneCenter)),
            this.isModActive(
              Config.modulators.dictionary["song detune"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((modDetuneStart +=
                4 *
                this.getModValue(
                  Config.modulators.dictionary["song detune"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                )),
              (modDetuneEnd +=
                4 *
                this.getModValue(
                  Config.modulators.dictionary["song detune"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ))),
            (intervalStart +=
              (Synth.detuneToCents(modDetuneStart) *
                envelopeStart *
                Config.pitchesPerOctave) /
              1200),
            (intervalEnd +=
              (Synth.detuneToCents(modDetuneEnd) *
                envelopeEnd *
                Config.pitchesPerOctave) /
              1200);
        }
        if (effectsIncludeVibrato(instrument.effects)) {
          let delayTicks,
            vibratoAmplitudeStart,
            vibratoAmplitudeEnd,
            vibratoStart;
          if (
            (instrument.vibrato == Config.vibratos.length
              ? ((delayTicks = 2 * instrument.vibratoDelay),
                instrument.vibratoDelay ==
                  Config.modulators.dictionary["vibrato delay"].maxRawVol &&
                  (delayTicks = Number.POSITIVE_INFINITY),
                (vibratoAmplitudeStart = instrument.vibratoDepth),
                (vibratoAmplitudeEnd = vibratoAmplitudeStart))
              : ((delayTicks = Config.vibratos[instrument.vibrato].delayTicks),
                (vibratoAmplitudeStart =
                  Config.vibratos[instrument.vibrato].amplitude),
                (vibratoAmplitudeEnd = vibratoAmplitudeStart)),
            this.isModActive(
              Config.modulators.dictionary["vibrato delay"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((delayTicks =
                2 *
                this.getModValue(
                  Config.modulators.dictionary["vibrato delay"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                )),
              delayTicks ==
                2 * Config.modulators.dictionary["vibrato delay"].maxRawVol &&
                (delayTicks = Number.POSITIVE_INFINITY)),
            this.isModActive(
              Config.modulators.dictionary["vibrato depth"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((vibratoAmplitudeStart =
                this.getModValue(
                  Config.modulators.dictionary["vibrato depth"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) / 25),
              (vibratoAmplitudeEnd =
                this.getModValue(
                  Config.modulators.dictionary["vibrato depth"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) / 25)),
            null != tone.prevVibrato)
          )
            vibratoStart = tone.prevVibrato;
          else {
            let vibratoLfoStart = Synth.getLFOAmplitude(
              instrument,
              secondsPerPart * instrumentState.vibratoTime
            );
            const vibratoDepthEnvelopeStart = envelopeStarts[20];
            if (
              ((vibratoStart =
                vibratoAmplitudeStart *
                vibratoLfoStart *
                vibratoDepthEnvelopeStart),
              delayTicks > 0)
            ) {
              const ticksUntilVibratoStart =
                delayTicks - envelopeComputer.noteTicksStart;
              vibratoStart *= Math.max(
                0,
                Math.min(1, 1 - ticksUntilVibratoStart / 2)
              );
            }
          }
          let vibratoLfoEnd = Synth.getLFOAmplitude(
            instrument,
            secondsPerPart * instrumentState.nextVibratoTime
          );
          const vibratoDepthEnvelopeEnd = envelopeEnds[20];
          if (10 != instrument.type) {
            let vibratoEnd =
              vibratoAmplitudeEnd * vibratoLfoEnd * vibratoDepthEnvelopeEnd;
            if (delayTicks > 0) {
              const ticksUntilVibratoEnd =
                delayTicks - envelopeComputer.noteTicksEnd;
              vibratoEnd *= Math.max(
                0,
                Math.min(1, 1 - ticksUntilVibratoEnd / 2)
              );
            }
            (tone.prevVibrato = vibratoEnd),
              (intervalStart += vibratoStart),
              (intervalEnd += vibratoEnd);
          }
        }
        if (
          (!transition.isSeamless && !tone.forceContinueAtStart) ||
          null == tone.prevNote
        ) {
          const fadeInSeconds = instrument.getFadeInSeconds();
          fadeInSeconds > 0 &&
            ((fadeExpressionStart *= Math.min(
              1,
              envelopeComputer.noteSecondsStartUnscaled / fadeInSeconds
            )),
            (fadeExpressionEnd *= Math.min(
              1,
              envelopeComputer.noteSecondsEndUnscaled / fadeInSeconds
            )));
        }
        4 == instrument.type &&
          null == tone.drumsetPitch &&
          ((tone.drumsetPitch = tone.pitches[0]),
          null != tone.note &&
            (tone.drumsetPitch += tone.note.pickMainInterval()),
          (tone.drumsetPitch = Math.max(
            0,
            Math.min(Config.drumCount - 1, tone.drumsetPitch)
          )));
        let noteFilterExpression =
          envelopeComputer.lowpassCutoffDecayVolumeCompensation;
        if (effectsIncludeNoteFilter(instrument.effects)) {
          const noteAllFreqsEnvelopeStart = envelopeStarts[1],
            noteAllFreqsEnvelopeEnd = envelopeEnds[1];
          if (instrument.noteFilterType) {
            const noteFreqEnvelopeStart = envelopeStarts[21],
              noteFreqEnvelopeEnd = envelopeEnds[21],
              notePeakEnvelopeStart = envelopeStarts[29],
              notePeakEnvelopeEnd = envelopeEnds[29];
            startPoint.toCoefficients(
              Synth.tempFilterStartCoefficients,
              this.samplesPerSecond,
              noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart,
              notePeakEnvelopeStart
            ),
              endPoint.toCoefficients(
                Synth.tempFilterEndCoefficients,
                this.samplesPerSecond,
                noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd,
                notePeakEnvelopeEnd
              ),
              tone.noteFilters.length < 1 &&
                (tone.noteFilters[0] = new DynamicBiquadFilter()),
              tone.noteFilters[0].loadCoefficientsWithGradient(
                Synth.tempFilterStartCoefficients,
                Synth.tempFilterEndCoefficients,
                1 / roundedSamplesPerTick,
                0 == startPoint.type
              ),
              (noteFilterExpression *= startPoint.getVolumeCompensationMult()),
              (tone.noteFilterCount = 1);
          } else {
            const noteFilterSettings =
              null != instrument.tmpNoteFilterStart
                ? instrument.tmpNoteFilterStart
                : instrument.noteFilter;
            for (let i = 0; i < noteFilterSettings.controlPointCount; i++) {
              const noteFreqEnvelopeStart = envelopeStarts[21 + i],
                noteFreqEnvelopeEnd = envelopeEnds[21 + i],
                notePeakEnvelopeStart = envelopeStarts[29 + i],
                notePeakEnvelopeEnd = envelopeEnds[29 + i];
              let startPoint = noteFilterSettings.controlPoints[i];
              const endPoint =
                null != instrument.tmpNoteFilterEnd &&
                null != instrument.tmpNoteFilterEnd.controlPoints[i]
                  ? instrument.tmpNoteFilterEnd.controlPoints[i]
                  : noteFilterSettings.controlPoints[i];
              startPoint.type != endPoint.type && (startPoint = endPoint),
                startPoint.toCoefficients(
                  Synth.tempFilterStartCoefficients,
                  this.samplesPerSecond,
                  noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart,
                  notePeakEnvelopeStart
                ),
                endPoint.toCoefficients(
                  Synth.tempFilterEndCoefficients,
                  this.samplesPerSecond,
                  noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd,
                  notePeakEnvelopeEnd
                ),
                tone.noteFilters.length <= i &&
                  (tone.noteFilters[i] = new DynamicBiquadFilter()),
                tone.noteFilters[i].loadCoefficientsWithGradient(
                  Synth.tempFilterStartCoefficients,
                  Synth.tempFilterEndCoefficients,
                  1 / roundedSamplesPerTick,
                  0 == startPoint.type
                ),
                (noteFilterExpression *=
                  startPoint.getVolumeCompensationMult());
            }
            tone.noteFilterCount = noteFilterSettings.controlPointCount;
          }
        } else tone.noteFilterCount = 0;
        if (4 == instrument.type) {
          const drumsetFilterEnvelope = instrument.getDrumsetEnvelope(
            tone.drumsetPitch
          );
          noteFilterExpression *=
            EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(
              drumsetFilterEnvelope
            );
          let drumsetFilterEnvelopeStart = EnvelopeComputer.computeEnvelope(
            drumsetFilterEnvelope,
            envelopeComputer.noteSecondsStart,
            beatsPerPart * partTimeStart,
            envelopeComputer.noteSizeStart
          );
          if (envelopeComputer.prevSlideStart) {
            const other = EnvelopeComputer.computeEnvelope(
              drumsetFilterEnvelope,
              envelopeComputer.prevNoteSecondsStart,
              beatsPerPart * partTimeStart,
              envelopeComputer.prevNoteSize
            );
            drumsetFilterEnvelopeStart +=
              (other - drumsetFilterEnvelopeStart) *
              envelopeComputer.prevSlideRatioStart;
          }
          if (envelopeComputer.nextSlideStart) {
            const other = EnvelopeComputer.computeEnvelope(
              drumsetFilterEnvelope,
              0,
              beatsPerPart * partTimeStart,
              envelopeComputer.nextNoteSize
            );
            drumsetFilterEnvelopeStart +=
              (other - drumsetFilterEnvelopeStart) *
              envelopeComputer.nextSlideRatioStart;
          }
          let drumsetFilterEnvelopeEnd = drumsetFilterEnvelopeStart;
          if (0 == instrument.discreteEnvelope) {
            if (
              ((drumsetFilterEnvelopeEnd = EnvelopeComputer.computeEnvelope(
                drumsetFilterEnvelope,
                envelopeComputer.noteSecondsEnd,
                beatsPerPart * partTimeEnd,
                envelopeComputer.noteSizeEnd
              )),
              envelopeComputer.prevSlideEnd)
            ) {
              const other = EnvelopeComputer.computeEnvelope(
                drumsetFilterEnvelope,
                envelopeComputer.prevNoteSecondsEnd,
                beatsPerPart * partTimeEnd,
                envelopeComputer.prevNoteSize
              );
              drumsetFilterEnvelopeEnd +=
                (other - drumsetFilterEnvelopeEnd) *
                envelopeComputer.prevSlideRatioEnd;
            }
            if (envelopeComputer.nextSlideEnd) {
              const other = EnvelopeComputer.computeEnvelope(
                drumsetFilterEnvelope,
                0,
                beatsPerPart * partTimeEnd,
                envelopeComputer.nextNoteSize
              );
              drumsetFilterEnvelopeEnd +=
                (other - drumsetFilterEnvelopeEnd) *
                envelopeComputer.nextSlideRatioEnd;
            }
          }
          const point = this.tempDrumSetControlPoint;
          (point.type = 0),
            (point.gain =
              FilterControlPoint.getRoundedSettingValueFromLinearGain(0.5)),
            (point.freq = FilterControlPoint.getRoundedSettingValueFromHz(8e3)),
            point.toCoefficients(
              Synth.tempFilterStartCoefficients,
              this.samplesPerSecond,
              drumsetFilterEnvelopeStart * (1 + drumsetFilterEnvelopeStart),
              1
            ),
            point.toCoefficients(
              Synth.tempFilterEndCoefficients,
              this.samplesPerSecond,
              drumsetFilterEnvelopeEnd * (1 + drumsetFilterEnvelopeEnd),
              1
            ),
            tone.noteFilters.length == tone.noteFilterCount &&
              (tone.noteFilters[tone.noteFilterCount] =
                new DynamicBiquadFilter()),
            tone.noteFilters[tone.noteFilterCount].loadCoefficientsWithGradient(
              Synth.tempFilterStartCoefficients,
              Synth.tempFilterEndCoefficients,
              1 / roundedSamplesPerTick,
              !0
            ),
            tone.noteFilterCount++;
        }
        if (
          ((noteFilterExpression = Math.min(3, noteFilterExpression)),
          1 == instrument.type || 11 == instrument.type)
        ) {
          let sineExpressionBoost = 1,
            totalCarrierExpression = 0,
            arpeggioInterval = 0;
          const arpeggiates = chord.arpeggiates;
          if (tone.pitchCount > 1 && arpeggiates) {
            const arpeggio = Math.floor(
              instrumentState.arpTime / Config.ticksPerArpeggio
            );
            arpeggioInterval =
              tone.pitches[
                getArpeggioPitchIndex(
                  tone.pitchCount,
                  instrument.fastTwoNoteArp,
                  arpeggio
                )
              ] - tone.pitches[0];
          }
          const carrierCount =
            11 == instrument.type
              ? instrument.customAlgorithm.carrierCount
              : Config.algorithms[instrument.algorithm].carrierCount;
          for (
            let i = 0;
            i < (11 == instrument.type ? 6 : Config.operatorCount);
            i++
          ) {
            const associatedCarrierIndex =
                11 == instrument.type
                  ? instrument.customAlgorithm.associatedCarrier[i] - 1
                  : Config.algorithms[instrument.algorithm].associatedCarrier[
                      i
                    ] - 1,
              pitch =
                tone.pitches[
                  arpeggiates
                    ? 0
                    : i < tone.pitchCount
                      ? i
                      : associatedCarrierIndex < tone.pitchCount
                        ? associatedCarrierIndex
                        : 0
                ],
              freqMult =
                Config.operatorFrequencies[instrument.operators[i].frequency]
                  .mult,
              interval =
                Config.operatorCarrierInterval[associatedCarrierIndex] +
                arpeggioInterval,
              pitchStart =
                basePitch + (pitch + intervalStart) * intervalScale + interval,
              pitchEnd =
                basePitch + (pitch + intervalEnd) * intervalScale + interval,
              baseFreqStart = Instrument.frequencyFromPitch(pitchStart),
              baseFreqEnd = Instrument.frequencyFromPitch(pitchEnd),
              hzOffset =
                Config.operatorFrequencies[instrument.operators[i].frequency]
                  .hzOffset,
              targetFreqStart = freqMult * baseFreqStart + hzOffset,
              targetFreqEnd = freqMult * baseFreqEnd + hzOffset,
              freqEnvelopeStart = envelopeStarts[5 + i],
              freqEnvelopeEnd = envelopeEnds[5 + i];
            let freqStart, freqEnd;
            1 != freqEnvelopeStart || 1 != freqEnvelopeEnd
              ? ((freqStart =
                  Math.pow(
                    2,
                    Math.log2(targetFreqStart / baseFreqStart) *
                      freqEnvelopeStart
                  ) * baseFreqStart),
                (freqEnd =
                  Math.pow(
                    2,
                    Math.log2(targetFreqEnd / baseFreqEnd) * freqEnvelopeEnd
                  ) * baseFreqEnd))
              : ((freqStart = targetFreqStart), (freqEnd = targetFreqEnd)),
              (tone.phaseDeltas[i] = freqStart * sampleTime),
              (tone.phaseDeltaScales[i] = Math.pow(
                freqEnd / freqStart,
                1 / roundedSamplesPerTick
              ));
            let amplitudeStart = instrument.operators[i].amplitude,
              amplitudeEnd = instrument.operators[i].amplitude;
            i < 4
              ? this.isModActive(
                  Config.modulators.dictionary["fm slider 1"].index + i,
                  channelIndex,
                  tone.instrumentIndex
                ) &&
                ((amplitudeStart *=
                  this.getModValue(
                    Config.modulators.dictionary["fm slider 1"].index + i,
                    channelIndex,
                    tone.instrumentIndex,
                    !1
                  ) / 15),
                (amplitudeEnd *=
                  this.getModValue(
                    Config.modulators.dictionary["fm slider 1"].index + i,
                    channelIndex,
                    tone.instrumentIndex,
                    !0
                  ) / 15))
              : this.isModActive(
                  Config.modulators.dictionary["fm slider 5"].index + i - 4,
                  channelIndex,
                  tone.instrumentIndex
                ) &&
                ((amplitudeStart *=
                  this.getModValue(
                    Config.modulators.dictionary["fm slider 5"].index + i - 4,
                    channelIndex,
                    tone.instrumentIndex,
                    !1
                  ) / 15),
                (amplitudeEnd *=
                  this.getModValue(
                    Config.modulators.dictionary["fm slider 5"].index + i - 4,
                    channelIndex,
                    tone.instrumentIndex,
                    !0
                  ) / 15));
            const amplitudeCurveStart =
                Synth.operatorAmplitudeCurve(amplitudeStart),
              amplitudeCurveEnd = Synth.operatorAmplitudeCurve(amplitudeEnd),
              amplitudeMultStart =
                amplitudeCurveStart *
                Config.operatorFrequencies[instrument.operators[i].frequency]
                  .amplitudeSign,
              amplitudeMultEnd =
                amplitudeCurveEnd *
                Config.operatorFrequencies[instrument.operators[i].frequency]
                  .amplitudeSign;
            let expressionStart = amplitudeMultStart,
              expressionEnd = amplitudeMultEnd;
            if (i < carrierCount) {
              let pitchExpressionStart;
              pitchExpressionStart =
                null != tone.prevPitchExpressions[i]
                  ? tone.prevPitchExpressions[i]
                  : Math.pow(
                      2,
                      -(pitchStart - expressionReferencePitch) / pitchDamping
                    );
              const pitchExpressionEnd = Math.pow(
                2,
                -(pitchEnd - expressionReferencePitch) / pitchDamping
              );
              (tone.prevPitchExpressions[i] = pitchExpressionEnd),
                (expressionStart *= pitchExpressionStart),
                (expressionEnd *= pitchExpressionEnd),
                (totalCarrierExpression += amplitudeCurveEnd);
            } else
              (expressionStart *= 1.5 * Config.sineWaveLength),
                (expressionEnd *= 1.5 * Config.sineWaveLength),
                (sineExpressionBoost *=
                  1 - Math.min(1, instrument.operators[i].amplitude / 15));
            if (
              ((expressionStart *= envelopeStarts[11 + i]),
              (expressionEnd *= envelopeEnds[11 + i]),
              this.isModActive(
                Config.modulators.dictionary["note volume"].index,
                channelIndex,
                tone.instrumentIndex
              ))
            ) {
              const startVal = this.getModValue(
                  Config.modulators.dictionary["note volume"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ),
                endVal = this.getModValue(
                  Config.modulators.dictionary["note volume"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                );
              (expressionStart *=
                startVal <= 0
                  ? (startVal + Config.volumeRange / 2) /
                    (Config.volumeRange / 2)
                  : Synth.instrumentVolumeToVolumeMult(startVal)),
                (expressionEnd *=
                  endVal <= 0
                    ? (endVal + Config.volumeRange / 2) /
                      (Config.volumeRange / 2)
                    : Synth.instrumentVolumeToVolumeMult(endVal));
            }
            (tone.operatorExpressions[i] = expressionStart),
              (tone.operatorExpressionDeltas[i] =
                (expressionEnd - expressionStart) / roundedSamplesPerTick);
          }
          (sineExpressionBoost *=
            (Math.pow(2, 2 - (1.4 * instrument.feedbackAmplitude) / 15) - 1) /
            3),
            (sineExpressionBoost *=
              1 - Math.min(1, Math.max(0, totalCarrierExpression - 1) / 2)),
            (sineExpressionBoost = 1 + 3 * sineExpressionBoost);
          const expressionStart =
              baseExpression *
              sineExpressionBoost *
              noteFilterExpression *
              fadeExpressionStart *
              chordExpressionStart *
              envelopeStarts[0],
            expressionEnd =
              baseExpression *
              sineExpressionBoost *
              noteFilterExpression *
              fadeExpressionEnd *
              chordExpressionEnd *
              envelopeEnds[0];
          (tone.expression = expressionStart),
            (tone.expressionDelta =
              (expressionEnd - expressionStart) / roundedSamplesPerTick);
          let useFeedbackAmplitudeStart = instrument.feedbackAmplitude,
            useFeedbackAmplitudeEnd = instrument.feedbackAmplitude;
          this.isModActive(
            Config.modulators.dictionary["fm feedback"].index,
            channelIndex,
            tone.instrumentIndex
          ) &&
            ((useFeedbackAmplitudeStart *=
              this.getModValue(
                Config.modulators.dictionary["fm feedback"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ) / 15),
            (useFeedbackAmplitudeEnd *=
              this.getModValue(
                Config.modulators.dictionary["fm feedback"].index,
                channelIndex,
                tone.instrumentIndex,
                !0
              ) / 15));
          let feedbackAmplitudeStart =
            (0.3 * Config.sineWaveLength * useFeedbackAmplitudeStart) / 15;
          const feedbackAmplitudeEnd =
            (0.3 * Config.sineWaveLength * useFeedbackAmplitudeEnd) / 15;
          let feedbackStart = feedbackAmplitudeStart * envelopeStarts[17],
            feedbackEnd = feedbackAmplitudeEnd * envelopeEnds[17];
          (tone.feedbackMult = feedbackStart),
            (tone.feedbackDelta =
              (feedbackEnd - feedbackStart) / roundedSamplesPerTick);
        } else {
          const freqEndRatio = Math.pow(
              2,
              ((intervalEnd - intervalStart) * intervalScale) / 12
            ),
            basePhaseDeltaScale = Math.pow(
              freqEndRatio,
              1 / roundedSamplesPerTick
            );
          let pitch = tone.pitches[0];
          if (
            tone.pitchCount > 1 &&
            (chord.arpeggiates || chord.customInterval)
          ) {
            const arpeggio = Math.floor(
              instrumentState.arpTime / Config.ticksPerArpeggio
            );
            if (chord.customInterval) {
              const intervalOffset =
                tone.pitches[
                  1 +
                    getArpeggioPitchIndex(
                      tone.pitchCount - 1,
                      instrument.fastTwoNoteArp,
                      arpeggio
                    )
                ] - tone.pitches[0];
              (specialIntervalMult = Math.pow(2, intervalOffset / 12)),
                (tone.specialIntervalExpressionMult = Math.pow(
                  2,
                  -intervalOffset / pitchDamping
                ));
            } else
              pitch =
                tone.pitches[
                  getArpeggioPitchIndex(
                    tone.pitchCount,
                    instrument.fastTwoNoteArp,
                    arpeggio
                  )
                ];
          }
          const startPitch =
              basePitch + (pitch + intervalStart) * intervalScale,
            endPitch = basePitch + (pitch + intervalEnd) * intervalScale;
          let pitchExpressionStart;
          pitchExpressionStart =
            null != tone.prevPitchExpressions[0]
              ? tone.prevPitchExpressions[0]
              : Math.pow(
                  2,
                  -(startPitch - expressionReferencePitch) / pitchDamping
                );
          const pitchExpressionEnd = Math.pow(
            2,
            -(endPitch - expressionReferencePitch) / pitchDamping
          );
          tone.prevPitchExpressions[0] = pitchExpressionEnd;
          let settingsExpressionMult = baseExpression * noteFilterExpression;
          if (
            (2 == instrument.type &&
              (settingsExpressionMult *=
                Config.chipNoises[instrument.chipNoise].expression),
            0 == instrument.type &&
              (settingsExpressionMult *=
                Config.chipWaves[instrument.chipWave].expression),
            6 == instrument.type)
          ) {
            const basePulseWidth = getPulseWidthRatio(instrument.pulseWidth);
            let pulseWidthModStart = basePulseWidth,
              pulseWidthModEnd = basePulseWidth;
            this.isModActive(
              Config.modulators.dictionary["pulse width"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((pulseWidthModStart =
                this.getModValue(
                  Config.modulators.dictionary["pulse width"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) /
                (2 * Config.pulseWidthRange)),
              (pulseWidthModEnd =
                this.getModValue(
                  Config.modulators.dictionary["pulse width"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) /
                (2 * Config.pulseWidthRange)));
            const pulseWidthStart = pulseWidthModStart * envelopeStarts[2],
              pulseWidthEnd = pulseWidthModEnd * envelopeEnds[2];
            (tone.pulseWidth = pulseWidthStart),
              (tone.pulseWidthDelta =
                (pulseWidthEnd - pulseWidthStart) / roundedSamplesPerTick);
            let decimalOffsetModStart = instrument.decimalOffset;
            this.isModActive(
              Config.modulators.dictionary["decimal offset"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              (decimalOffsetModStart = this.getModValue(
                Config.modulators.dictionary["decimal offset"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ));
            const decimalOffsetStart =
              decimalOffsetModStart * envelopeStarts[37];
            (tone.decimalOffset = decimalOffsetStart),
              (tone.pulseWidth -= tone.decimalOffset / 1e4);
          }
          if (7 == instrument.type) {
            let useSustainStart = instrument.stringSustain,
              useSustainEnd = instrument.stringSustain;
            this.isModActive(
              Config.modulators.dictionary.sustain.index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((useSustainStart = this.getModValue(
                Config.modulators.dictionary.sustain.index,
                channelIndex,
                tone.instrumentIndex,
                !1
              )),
              (useSustainEnd = this.getModValue(
                Config.modulators.dictionary.sustain.index,
                channelIndex,
                tone.instrumentIndex,
                !0
              ))),
              (tone.stringSustainStart = useSustainStart),
              (tone.stringSustainEnd = useSustainEnd),
              (settingsExpressionMult *= Math.pow(
                2,
                0.7 * (1 - useSustainStart / (Config.stringSustainRange - 1))
              ));
          }
          const startFreq = Instrument.frequencyFromPitch(startPitch);
          if (
            0 == instrument.type ||
            9 == instrument.type ||
            5 == instrument.type ||
            7 == instrument.type ||
            3 == instrument.type ||
            6 == instrument.type ||
            2 == instrument.type
          ) {
            const unisonVoices = instrument.unisonVoices,
              unisonSpread = instrument.unisonSpread,
              unisonOffset = instrument.unisonOffset,
              unisonExpression = instrument.unisonExpression,
              voiceCountExpression =
                7 == instrument.type ? 1 : unisonVoices / 2;
            settingsExpressionMult *= unisonExpression * voiceCountExpression;
            const unisonEnvelopeStart = envelopeStarts[4],
              unisonEnvelopeEnd = envelopeEnds[4],
              unisonAStart = Math.pow(
                2,
                ((unisonOffset + unisonSpread) * unisonEnvelopeStart) / 12
              ),
              unisonAEnd = Math.pow(
                2,
                ((unisonOffset + unisonSpread) * unisonEnvelopeEnd) / 12
              ),
              unisonBStart =
                Math.pow(
                  2,
                  ((unisonOffset - unisonSpread) * unisonEnvelopeStart) / 12
                ) * specialIntervalMult,
              unisonBEnd =
                Math.pow(
                  2,
                  ((unisonOffset - unisonSpread) * unisonEnvelopeEnd) / 12
                ) * specialIntervalMult;
            (tone.phaseDeltas[0] = startFreq * sampleTime * unisonAStart),
              (tone.phaseDeltas[1] = startFreq * sampleTime * unisonBStart),
              (tone.phaseDeltaScales[0] =
                basePhaseDeltaScale *
                Math.pow(unisonAEnd / unisonAStart, 1 / roundedSamplesPerTick)),
              (tone.phaseDeltaScales[1] =
                basePhaseDeltaScale *
                Math.pow(unisonBEnd / unisonBStart, 1 / roundedSamplesPerTick));
          } else
            (tone.phaseDeltas[0] = startFreq * sampleTime),
              (tone.phaseDeltaScales[0] = basePhaseDeltaScale);
          let supersawExpressionStart = 1,
            supersawExpressionEnd = 1;
          if (8 == instrument.type) {
            const minFirstVoiceAmplitude =
              1 / Math.sqrt(Config.supersawVoiceCount);
            let useDynamismStart =
                instrument.supersawDynamism / Config.supersawDynamismMax,
              useDynamismEnd =
                instrument.supersawDynamism / Config.supersawDynamismMax;
            this.isModActive(
              Config.modulators.dictionary.dynamism.index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((useDynamismStart =
                this.getModValue(
                  Config.modulators.dictionary.dynamism.index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) / Config.supersawDynamismMax),
              (useDynamismEnd =
                this.getModValue(
                  Config.modulators.dictionary.dynamism.index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) / Config.supersawDynamismMax));
            const curvedDynamismStart =
                1 -
                Math.pow(
                  Math.max(0, 1 - useDynamismStart * envelopeStarts[38]),
                  0.2
                ),
              curvedDynamismEnd =
                1 -
                Math.pow(
                  Math.max(0, 1 - useDynamismEnd * envelopeEnds[38]),
                  0.2
                ),
              firstVoiceAmplitudeStart = Math.pow(
                2,
                Math.log2(minFirstVoiceAmplitude) * curvedDynamismStart
              ),
              firstVoiceAmplitudeEnd = Math.pow(
                2,
                Math.log2(minFirstVoiceAmplitude) * curvedDynamismEnd
              ),
              dynamismStart = Math.sqrt(
                (1 / Math.pow(firstVoiceAmplitudeStart, 2) - 1) /
                  (Config.supersawVoiceCount - 1)
              ),
              dynamismEnd = Math.sqrt(
                (1 / Math.pow(firstVoiceAmplitudeEnd, 2) - 1) /
                  (Config.supersawVoiceCount - 1)
              );
            (tone.supersawDynamism = dynamismStart),
              (tone.supersawDynamismDelta =
                (dynamismEnd - dynamismStart) / roundedSamplesPerTick);
            const initializeSupersaw = -1 == tone.supersawDelayIndex;
            if (initializeSupersaw) {
              let accumulator = 0;
              for (let i = 0; i < Config.supersawVoiceCount; i++)
                (tone.phases[i] = accumulator),
                  (accumulator += -Math.log(Math.random()));
              const amplitudeSum =
                  1 + (Config.supersawVoiceCount - 1) * dynamismStart,
                slope = amplitudeSum;
              let sample = 0;
              for (let i = 0; i < Config.supersawVoiceCount; i++) {
                const amplitude = 0 == i ? 1 : dynamismStart,
                  normalizedPhase = tone.phases[i] / accumulator;
                (tone.phases[i] = normalizedPhase),
                  (sample += (normalizedPhase - 0.5) * amplitude);
              }
              let zeroCrossingPhase = 1,
                prevDrop = 0;
              for (let i = Config.supersawVoiceCount - 1; i >= 0; i--) {
                const nextDrop = 1 - tone.phases[i],
                  phaseDelta = nextDrop - prevDrop;
                if (sample < 0) {
                  const distanceToZeroCrossing = -sample / slope;
                  if (distanceToZeroCrossing < phaseDelta) {
                    zeroCrossingPhase = prevDrop + distanceToZeroCrossing;
                    break;
                  }
                }
                const amplitude = 0 == i ? 1 : dynamismStart;
                (sample += phaseDelta * slope - amplitude),
                  (prevDrop = nextDrop);
              }
              for (let i = 0; i < Config.supersawVoiceCount; i++)
                tone.phases[i] += zeroCrossingPhase;
              for (let i = 1; i < Config.supersawVoiceCount - 1; i++) {
                const swappedIndex =
                    i +
                    Math.floor(Math.random() * (Config.supersawVoiceCount - i)),
                  temp = tone.phases[i];
                (tone.phases[i] = tone.phases[swappedIndex]),
                  (tone.phases[swappedIndex] = temp);
              }
            }
            const baseSpreadSlider =
              instrument.supersawSpread / Config.supersawSpreadMax;
            let useSpreadStart = baseSpreadSlider,
              useSpreadEnd = baseSpreadSlider;
            this.isModActive(
              Config.modulators.dictionary.spread.index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((useSpreadStart =
                this.getModValue(
                  Config.modulators.dictionary.spread.index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) / Config.supersawSpreadMax),
              (useSpreadEnd =
                this.getModValue(
                  Config.modulators.dictionary.spread.index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) / Config.supersawSpreadMax));
            const spreadSliderStart = useSpreadStart * envelopeStarts[39],
              spreadSliderEnd = useSpreadEnd * envelopeEnds[39],
              averageSpreadSlider = 0.5 * (spreadSliderStart + spreadSliderEnd),
              curvedSpread = Math.pow(
                1 - Math.sqrt(Math.max(0, 1 - averageSpreadSlider)),
                1.75
              );
            for (let i = 0; i < Config.supersawVoiceCount; i++) {
              const offset =
                0 == i
                  ? 0
                  : Math.pow(
                      (((i + 1) >> 1) - 0.5 + 0.025 * ((2 & i) - 1)) /
                        (Config.supersawVoiceCount >> 1),
                      1.1
                    ) *
                    (2 * (1 & i) - 1);
              tone.supersawUnisonDetunes[i] = Math.pow(
                2,
                (curvedSpread * offset) / 12
              );
            }
            const baseShape =
              instrument.supersawShape / Config.supersawShapeMax;
            let useShapeStart = baseShape * envelopeStarts[40],
              useShapeEnd = baseShape * envelopeEnds[40];
            this.isModActive(
              Config.modulators.dictionary["saw shape"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((useShapeStart =
                this.getModValue(
                  Config.modulators.dictionary["saw shape"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) / Config.supersawShapeMax),
              (useShapeEnd =
                this.getModValue(
                  Config.modulators.dictionary["saw shape"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) / Config.supersawShapeMax));
            const shapeStart = useShapeStart * envelopeStarts[40],
              shapeEnd = useShapeEnd * envelopeEnds[40];
            (tone.supersawShape = shapeStart),
              (tone.supersawShapeDelta =
                (shapeEnd - shapeStart) / roundedSamplesPerTick);
            let decimalOffsetModStart = instrument.decimalOffset;
            this.isModActive(
              Config.modulators.dictionary["decimal offset"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              (decimalOffsetModStart = this.getModValue(
                Config.modulators.dictionary["decimal offset"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ));
            const decimalOffsetStart =
              decimalOffsetModStart * envelopeStarts[37];
            tone.decimalOffset = decimalOffsetStart;
            const basePulseWidth = getPulseWidthRatio(instrument.pulseWidth);
            let pulseWidthModStart = basePulseWidth,
              pulseWidthModEnd = basePulseWidth;
            this.isModActive(
              Config.modulators.dictionary["pulse width"].index,
              channelIndex,
              tone.instrumentIndex
            ) &&
              ((pulseWidthModStart =
                this.getModValue(
                  Config.modulators.dictionary["pulse width"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !1
                ) /
                (2 * Config.pulseWidthRange)),
              (pulseWidthModEnd =
                this.getModValue(
                  Config.modulators.dictionary["pulse width"].index,
                  channelIndex,
                  tone.instrumentIndex,
                  !0
                ) /
                (2 * Config.pulseWidthRange)));
            let pulseWidthStart = pulseWidthModStart * envelopeStarts[2],
              pulseWidthEnd = pulseWidthModEnd * envelopeEnds[2];
            (pulseWidthStart -= decimalOffsetStart / 1e4),
              (pulseWidthEnd -= decimalOffsetStart / 1e4);
            const phaseDeltaStart =
                null != tone.supersawPrevPhaseDelta
                  ? tone.supersawPrevPhaseDelta
                  : startFreq * sampleTime,
              phaseDeltaEnd = startFreq * sampleTime * freqEndRatio;
            tone.supersawPrevPhaseDelta = phaseDeltaEnd;
            const delayLengthStart = pulseWidthStart / phaseDeltaStart,
              delayLengthEnd = pulseWidthEnd / phaseDeltaEnd;
            (tone.supersawDelayLength = delayLengthStart),
              (tone.supersawDelayLengthDelta =
                (delayLengthEnd - delayLengthStart) / roundedSamplesPerTick);
            const minBufferLength =
              Math.ceil(Math.max(delayLengthStart, delayLengthEnd)) + 2;
            if (
              null == tone.supersawDelayLine ||
              tone.supersawDelayLine.length <= minBufferLength
            ) {
              const likelyMaximumLength = Math.ceil(
                  (0.5 * this.samplesPerSecond) /
                    Instrument.frequencyFromPitch(24)
                ),
                newDelayLine = new Float32Array(
                  Synth.fittingPowerOfTwo(
                    Math.max(likelyMaximumLength, minBufferLength)
                  )
                );
              if (!initializeSupersaw && null != tone.supersawDelayLine) {
                const oldDelayBufferMask =
                    (tone.supersawDelayLine.length - 1) >> 0,
                  startCopyingFromIndex = tone.supersawDelayIndex;
                for (let i = 0; i < tone.supersawDelayLine.length; i++)
                  newDelayLine[i] =
                    tone.supersawDelayLine[
                      (startCopyingFromIndex + i) & oldDelayBufferMask
                    ];
              }
              (tone.supersawDelayLine = newDelayLine),
                (tone.supersawDelayIndex = tone.supersawDelayLine.length);
            } else
              initializeSupersaw &&
                (tone.supersawDelayLine.fill(0),
                (tone.supersawDelayIndex = tone.supersawDelayLine.length));
            const pulseExpressionRatio =
              Config.pwmBaseExpression / Config.supersawBaseExpression;
            (supersawExpressionStart *=
              (1 + (pulseExpressionRatio - 1) * shapeStart) /
              Math.sqrt(
                1 +
                  (Config.supersawVoiceCount - 1) *
                    dynamismStart *
                    dynamismStart
              )),
              (supersawExpressionEnd *=
                (1 + (pulseExpressionRatio - 1) * shapeEnd) /
                Math.sqrt(
                  1 +
                    (Config.supersawVoiceCount - 1) * dynamismEnd * dynamismEnd
                ));
          }
          let expressionStart =
              settingsExpressionMult *
              fadeExpressionStart *
              chordExpressionStart *
              pitchExpressionStart *
              envelopeStarts[0] *
              supersawExpressionStart,
            expressionEnd =
              settingsExpressionMult *
              fadeExpressionEnd *
              chordExpressionEnd *
              pitchExpressionEnd *
              envelopeEnds[0] *
              supersawExpressionEnd;
          if (
            this.isModActive(
              Config.modulators.dictionary["note volume"].index,
              channelIndex,
              tone.instrumentIndex
            )
          ) {
            const startVal = this.getModValue(
                Config.modulators.dictionary["note volume"].index,
                channelIndex,
                tone.instrumentIndex,
                !1
              ),
              endVal = this.getModValue(
                Config.modulators.dictionary["note volume"].index,
                channelIndex,
                tone.instrumentIndex,
                !0
              );
            (expressionStart *=
              startVal <= 0
                ? (startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)
                : Synth.instrumentVolumeToVolumeMult(startVal)),
              (expressionEnd *=
                endVal <= 0
                  ? (endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)
                  : Synth.instrumentVolumeToVolumeMult(endVal));
          }
          if (
            ((tone.expression = expressionStart),
            (tone.expressionDelta =
              (expressionEnd - expressionStart) / roundedSamplesPerTick),
            7 == instrument.type)
          ) {
            let stringDecayStart;
            if (null != tone.prevStringDecay)
              stringDecayStart = tone.prevStringDecay;
            else {
              const sustainEnvelopeStart =
                tone.envelopeComputer.envelopeStarts[3];
              stringDecayStart =
                1 -
                Math.min(
                  1,
                  (sustainEnvelopeStart * tone.stringSustainStart) /
                    (Config.stringSustainRange - 1)
                );
            }
            const sustainEnvelopeEnd = tone.envelopeComputer.envelopeEnds[3];
            let stringDecayEnd =
              1 -
              Math.min(
                1,
                (sustainEnvelopeEnd * tone.stringSustainEnd) /
                  (Config.stringSustainRange - 1)
              );
            tone.prevStringDecay = stringDecayEnd;
            const unisonVoices = instrument.unisonVoices;
            for (let i = tone.pickedStrings.length; i < unisonVoices; i++)
              tone.pickedStrings[i] = new PickedString();
            if (
              tone.atNoteStart &&
              !transition.continues &&
              !tone.forceContinueAtStart
            )
              for (const pickedString of tone.pickedStrings)
                pickedString.delayIndex = -1;
            for (let i = 0; i < unisonVoices; i++)
              tone.pickedStrings[i].update(
                this,
                instrumentState,
                tone,
                i,
                roundedSamplesPerTick,
                stringDecayStart,
                stringDecayEnd,
                instrument.stringSustainType
              );
          }
        }
      }
      static getLFOAmplitude(instrument, secondsIntoBar) {
        let effect = 0;
        for (const vibratoPeriodSeconds of Config.vibratoTypes[
          instrument.vibratoType
        ].periodsSeconds)
          effect += Math.sin(
            (2 * Math.PI * secondsIntoBar) / vibratoPeriodSeconds
          );
        return effect;
      }
      static getInstrumentSynthFunction(instrument) {
        if (1 == instrument.type) {
          const fingerprint =
            instrument.algorithm + "_" + instrument.feedbackType;
          if (null == Synth.fmSynthFunctionCache[fingerprint]) {
            const synthSource = [];
            for (const line of Synth.fmSourceTemplate)
              if (-1 != line.indexOf("// CARRIER OUTPUTS")) {
                const outputs = [];
                for (
                  let j = 0;
                  j < Config.algorithms[instrument.algorithm].carrierCount;
                  j++
                )
                  outputs.push("operator" + j + "Scaled");
                synthSource.push(
                  line.replace("/*operator#Scaled*/", outputs.join(" + "))
                );
              } else if (
                -1 != line.indexOf("// INSERT OPERATOR COMPUTATION HERE")
              )
                for (let j = Config.operatorCount - 1; j >= 0; j--)
                  for (const operatorLine of Synth.operatorSourceTemplate)
                    if (-1 != operatorLine.indexOf("/* + operator@Scaled*/")) {
                      let modulators = "";
                      for (const modulatorNumber of Config.algorithms[
                        instrument.algorithm
                      ].modulatedBy[j])
                        modulators +=
                          " + operator" + (modulatorNumber - 1) + "Scaled";
                      const feedbackIndices =
                        Config.feedbacks[instrument.feedbackType].indices[j];
                      if (feedbackIndices.length > 0) {
                        modulators += " + feedbackMult * (";
                        const feedbacks = [];
                        for (const modulatorNumber of feedbackIndices)
                          feedbacks.push(
                            "operator" + (modulatorNumber - 1) + "Output"
                          );
                        modulators += feedbacks.join(" + ") + ")";
                      }
                      synthSource.push(
                        operatorLine
                          .replace(/\#/g, j + "")
                          .replace("/* + operator@Scaled*/", modulators)
                      );
                    } else
                      synthSource.push(operatorLine.replace(/\#/g, j + ""));
              else if (-1 != line.indexOf("#"))
                for (let j = 0; j < Config.operatorCount; j++)
                  synthSource.push(line.replace(/\#/g, j + ""));
              else synthSource.push(line);
            const wrappedFmSynth =
              "return (synth, bufferIndex, roundedSamplesPerTick, tone, instrument) => {" +
              synthSource.join("\n") +
              "}";
            Synth.fmSynthFunctionCache[fingerprint] = new Function(
              "Config",
              "Synth",
              wrappedFmSynth
            )(Config, Synth);
          }
          return Synth.fmSynthFunctionCache[fingerprint];
        }
        if (0 == instrument.type)
          return instrument.isUsingAdvancedLoopControls
            ? Synth.loopableChipSynth
            : Synth.chipSynth;
        if (9 == instrument.type) return Synth.chipSynth;
        if (5 == instrument.type) return Synth.harmonicsSynth;
        if (6 == instrument.type) return Synth.pulseWidthSynth;
        if (8 == instrument.type) return Synth.supersawSynth;
        if (7 == instrument.type) return Synth.pickedStringSynth;
        if (2 == instrument.type) return Synth.noiseSynth;
        if (3 == instrument.type) return Synth.spectrumSynth;
        if (4 == instrument.type) return Synth.drumsetSynth;
        if (10 == instrument.type) return Synth.modSynth;
        if (11 == instrument.type) {
          const fingerprint =
            instrument.customAlgorithm.name +
            "_" +
            instrument.customFeedbackType.name;
          if (null == Synth.fm6SynthFunctionCache[fingerprint]) {
            const synthSource = [];
            for (const line of Synth.fmSourceTemplate)
              if (-1 != line.indexOf("// CARRIER OUTPUTS")) {
                const outputs = [];
                for (
                  let j = 0;
                  j < instrument.customAlgorithm.carrierCount;
                  j++
                )
                  outputs.push("operator" + j + "Scaled");
                synthSource.push(
                  line.replace("/*operator#Scaled*/", outputs.join(" + "))
                );
              } else if (
                -1 != line.indexOf("// INSERT OPERATOR COMPUTATION HERE")
              )
                for (let j = Config.operatorCount + 2 - 1; j >= 0; j--)
                  for (const operatorLine of Synth.operatorSourceTemplate)
                    if (-1 != operatorLine.indexOf("/* + operator@Scaled*/")) {
                      let modulators = "";
                      for (const modulatorNumber of instrument.customAlgorithm
                        .modulatedBy[j])
                        modulators +=
                          " + operator" + (modulatorNumber - 1) + "Scaled";
                      const feedbackIndices =
                        instrument.customFeedbackType.indices[j];
                      if (feedbackIndices.length > 0) {
                        modulators += " + feedbackMult * (";
                        const feedbacks = [];
                        for (const modulatorNumber of feedbackIndices)
                          feedbacks.push(
                            "operator" + (modulatorNumber - 1) + "Output"
                          );
                        modulators += feedbacks.join(" + ") + ")";
                      }
                      synthSource.push(
                        operatorLine
                          .replace(/\#/g, j + "")
                          .replace("/* + operator@Scaled*/", modulators)
                      );
                    } else
                      synthSource.push(operatorLine.replace(/\#/g, j + ""));
              else if (-1 != line.indexOf("#"))
                for (let j = 0; j < Config.operatorCount + 2; j++)
                  synthSource.push(line.replace(/\#/g, j + ""));
              else synthSource.push(line);
            const wrappedFm6Synth =
              "return (synth, bufferIndex, roundedSamplesPerTick, tone, instrument) => {" +
              synthSource.join("\n") +
              "}";
            Synth.fm6SynthFunctionCache[fingerprint] = new Function(
              "Config",
              "Synth",
              wrappedFm6Synth
            )(Config, Synth);
          }
          return Synth.fm6SynthFunctionCache[fingerprint];
        }
        throw new Error("Unrecognized instrument type: " + instrument.type);
      }
      static wrap(x, b) {
        return ((x % b) + b) % b;
      }
      static loopableChipSynth(
        synth,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        instrumentState
      ) {
        const aliases =
            effectsIncludeDistortion(instrumentState.effects) &&
            instrumentState.aliases,
          data = synth.tempMonoInstrumentSampleBuffer,
          wave = instrumentState.wave,
          volumeScale = instrumentState.volumeScale,
          waveLength =
            aliases && 8 == instrumentState.type
              ? wave.length
              : wave.length - 1;
        let chipWaveLoopEnd = Math.max(
            0,
            Math.min(waveLength, instrumentState.chipWaveLoopEnd)
          ),
          chipWaveLoopStart = Math.max(
            0,
            Math.min(chipWaveLoopEnd - 1, instrumentState.chipWaveLoopStart)
          ),
          chipWaveLoopLength = chipWaveLoopEnd - chipWaveLoopStart;
        chipWaveLoopLength < 2 &&
          ((chipWaveLoopStart = 0),
          (chipWaveLoopEnd = waveLength),
          (chipWaveLoopLength = waveLength));
        const chipWaveLoopMode = instrumentState.chipWaveLoopMode,
          chipWavePlayBackwards = instrumentState.chipWavePlayBackwards,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = tone.phaseDeltas[0] * waveLength,
          phaseDeltaB = tone.phaseDeltas[1] * waveLength,
          directionA = tone.directions[0],
          directionB = tone.directions[1],
          chipWaveCompletionA = tone.chipWaveCompletions[0],
          chipWaveCompletionB = tone.chipWaveCompletions[1];
        (3 !== chipWaveLoopMode &&
          2 !== chipWaveLoopMode &&
          0 !== chipWaveLoopMode) ||
          (chipWavePlayBackwards
            ? ((directionA = -1), (directionB = -1))
            : ((directionA = 1), (directionB = 1))),
          (0 !== chipWaveLoopMode && 1 !== chipWaveLoopMode) ||
            ((chipWaveCompletionA = 0), (chipWaveCompletionB = 0));
        let lastWaveA = tone.chipWaveCompletionsLastWave[0],
          lastWaveB = tone.chipWaveCompletionsLastWave[1];
        const chipWaveCompletionFadeLength = 1e3,
          phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phaseA = Synth.wrap(tone.phases[0], 1) * waveLength,
          phaseB = Synth.wrap(tone.phases[1], 1) * waveLength,
          prevWaveIntegralA = 0,
          prevWaveIntegralB = 0;
        if (!aliases) {
          const phaseAInt = Math.floor(phaseA),
            phaseBInt = Math.floor(phaseB),
            indexA = Synth.wrap(phaseAInt, waveLength),
            indexB = Synth.wrap(phaseBInt, waveLength),
            phaseRatioA = phaseA - phaseAInt,
            phaseRatioB = phaseB - phaseBInt;
          (prevWaveIntegralA = +wave[indexA]),
            (prevWaveIntegralB = +wave[indexB]),
            (prevWaveIntegralA +=
              (wave[Synth.wrap(indexA + 1, waveLength)] - prevWaveIntegralA) *
              phaseRatioA),
            (prevWaveIntegralB +=
              (wave[Synth.wrap(indexB + 1, waveLength)] - prevWaveIntegralB) *
              phaseRatioB);
        }
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters,
          stopIndex = bufferIndex + roundedSamplesPerTick;
        let prevWaveA = tone.chipWavePrevWaves[0],
          prevWaveB = tone.chipWavePrevWaves[1];
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          chipWaveCompletionA > 0 &&
            chipWaveCompletionA < 1e3 &&
            chipWaveCompletionA++,
            chipWaveCompletionB > 0 &&
              chipWaveCompletionB < 1e3 &&
              chipWaveCompletionB++;
          let wrapped = 0;
          (phaseA += phaseDeltaA * directionA),
            (phaseB += phaseDeltaB * directionB),
            2 === chipWaveLoopMode
              ? (1 === directionA
                  ? phaseA > waveLength &&
                    (chipWaveCompletionA <= 0 &&
                      ((lastWaveA = prevWaveA), chipWaveCompletionA++),
                    (wrapped = 1))
                  : -1 === directionA &&
                    phaseA < 0 &&
                    (chipWaveCompletionA <= 0 &&
                      ((lastWaveA = prevWaveA), chipWaveCompletionA++),
                    (wrapped = 1)),
                1 === directionB
                  ? phaseB > waveLength &&
                    (chipWaveCompletionB <= 0 &&
                      ((lastWaveB = prevWaveB), chipWaveCompletionB++),
                    (wrapped = 1))
                  : -1 === directionA &&
                    phaseB < 0 &&
                    (chipWaveCompletionB <= 0 &&
                      ((lastWaveB = prevWaveB), chipWaveCompletionB++),
                    (wrapped = 1)))
              : 3 === chipWaveLoopMode
                ? (1 === directionA
                    ? phaseA > chipWaveLoopEnd &&
                      (chipWaveCompletionA <= 0 &&
                        ((lastWaveA = prevWaveA), chipWaveCompletionA++),
                      (wrapped = 1))
                    : -1 === directionA &&
                      phaseA < chipWaveLoopStart &&
                      (chipWaveCompletionA <= 0 &&
                        ((lastWaveA = prevWaveA), chipWaveCompletionA++),
                      (wrapped = 1)),
                  1 === directionB
                    ? phaseB > chipWaveLoopEnd &&
                      (chipWaveCompletionB <= 0 &&
                        ((lastWaveB = prevWaveB), chipWaveCompletionB++),
                      (wrapped = 1))
                    : -1 === directionA &&
                      phaseB < chipWaveLoopStart &&
                      (chipWaveCompletionB <= 0 &&
                        ((lastWaveB = prevWaveB), chipWaveCompletionB++),
                      (wrapped = 1)))
                : 0 === chipWaveLoopMode
                  ? (1 === directionA
                      ? phaseA > chipWaveLoopEnd &&
                        ((phaseA =
                          chipWaveLoopStart +
                          Synth.wrap(
                            phaseA - chipWaveLoopEnd,
                            chipWaveLoopLength
                          )),
                        (wrapped = 1))
                      : -1 === directionA &&
                        phaseA < chipWaveLoopStart &&
                        ((phaseA =
                          chipWaveLoopEnd -
                          Synth.wrap(
                            chipWaveLoopStart - phaseA,
                            chipWaveLoopLength
                          )),
                        (wrapped = 1)),
                    1 === directionB
                      ? phaseB > chipWaveLoopEnd &&
                        ((phaseB =
                          chipWaveLoopStart +
                          Synth.wrap(
                            phaseB - chipWaveLoopEnd,
                            chipWaveLoopLength
                          )),
                        (wrapped = 1))
                      : -1 === directionB &&
                        phaseB < chipWaveLoopStart &&
                        ((phaseB =
                          chipWaveLoopEnd -
                          Synth.wrap(
                            chipWaveLoopStart - phaseB,
                            chipWaveLoopLength
                          )),
                        (wrapped = 1)))
                  : 1 === chipWaveLoopMode &&
                    (1 === directionA
                      ? phaseA > chipWaveLoopEnd &&
                        ((phaseA =
                          chipWaveLoopEnd -
                          Synth.wrap(
                            phaseA - chipWaveLoopEnd,
                            chipWaveLoopLength
                          )),
                        (directionA = -1),
                        (wrapped = 1))
                      : -1 === directionA &&
                        phaseA < chipWaveLoopStart &&
                        ((phaseA =
                          chipWaveLoopStart +
                          Synth.wrap(
                            chipWaveLoopStart - phaseA,
                            chipWaveLoopLength
                          )),
                        (directionA = 1),
                        (wrapped = 1)),
                    1 === directionB
                      ? phaseB > chipWaveLoopEnd &&
                        ((phaseB =
                          chipWaveLoopEnd -
                          Synth.wrap(
                            phaseB - chipWaveLoopEnd,
                            chipWaveLoopLength
                          )),
                        (directionB = -1),
                        (wrapped = 1))
                      : -1 === directionB &&
                        phaseB < chipWaveLoopStart &&
                        ((phaseB =
                          chipWaveLoopStart +
                          Synth.wrap(
                            chipWaveLoopStart - phaseB,
                            chipWaveLoopLength
                          )),
                        (directionB = 1),
                        (wrapped = 1)));
          let waveA = 0,
            waveB = 0,
            inputSample = 0;
          if (aliases) {
            (waveA = wave[Synth.wrap(Math.floor(phaseA), waveLength)]),
              (waveB = wave[Synth.wrap(Math.floor(phaseB), waveLength)]),
              (prevWaveA = waveA),
              (prevWaveB = waveB);
            const completionFadeA =
                chipWaveCompletionA > 0
                  ? (1e3 - Math.min(chipWaveCompletionA, 1e3)) / 1e3
                  : 1,
              completionFadeB =
                chipWaveCompletionB > 0
                  ? (1e3 - Math.min(chipWaveCompletionB, 1e3)) / 1e3
                  : 1;
            (inputSample = 0),
              (inputSample +=
                chipWaveCompletionA > 0 ? lastWaveA * completionFadeA : waveA),
              (inputSample +=
                chipWaveCompletionB > 0 ? lastWaveB * completionFadeB : waveB);
          } else {
            const phaseAInt = Math.floor(phaseA),
              phaseBInt = Math.floor(phaseB),
              indexA = Synth.wrap(phaseAInt, waveLength),
              indexB = Synth.wrap(phaseBInt, waveLength);
            let nextWaveIntegralA = wave[indexA],
              nextWaveIntegralB = wave[indexB];
            const phaseRatioA = phaseA - phaseAInt,
              phaseRatioB = phaseB - phaseBInt;
            if (
              ((nextWaveIntegralA +=
                (wave[Synth.wrap(indexA + 1, waveLength)] - nextWaveIntegralA) *
                phaseRatioA),
              (nextWaveIntegralB +=
                (wave[Synth.wrap(indexB + 1, waveLength)] - nextWaveIntegralB) *
                phaseRatioB),
              (0 !== chipWaveLoopMode ||
                0 !== chipWaveLoopStart ||
                chipWaveLoopEnd !== waveLength) &&
                0 !== wrapped)
            ) {
              let pwia = 0,
                pwib = 0;
              const phaseA_ = Math.max(0, phaseA - phaseDeltaA * directionA),
                phaseB_ = Math.max(0, phaseB - phaseDeltaB * directionB),
                phaseAInt = Math.floor(phaseA_),
                phaseBInt = Math.floor(phaseB_),
                indexA = Synth.wrap(phaseAInt, waveLength),
                indexB = Synth.wrap(phaseBInt, waveLength);
              (pwia = wave[indexA]),
                (pwib = wave[indexB]),
                (pwia +=
                  (wave[Synth.wrap(indexA + 1, waveLength)] - pwia) *
                  (phaseA_ - phaseAInt) *
                  directionA),
                (pwib +=
                  (wave[Synth.wrap(indexB + 1, waveLength)] - pwib) *
                  (phaseB_ - phaseBInt) *
                  directionB),
                (prevWaveIntegralA = pwia),
                (prevWaveIntegralB = pwib);
            }
            1 === chipWaveLoopMode && 0 !== wrapped
              ? ((waveA = prevWaveA), (waveB = prevWaveB))
              : ((waveA =
                  (nextWaveIntegralA - prevWaveIntegralA) /
                  (phaseDeltaA * directionA)),
                (waveB =
                  (nextWaveIntegralB - prevWaveIntegralB) /
                  (phaseDeltaB * directionB))),
              (prevWaveA = waveA),
              (prevWaveB = waveB),
              (prevWaveIntegralA = nextWaveIntegralA),
              (prevWaveIntegralB = nextWaveIntegralB);
            const completionFadeA =
                chipWaveCompletionA > 0
                  ? (1e3 - Math.min(chipWaveCompletionA, 1e3)) / 1e3
                  : 1,
              completionFadeB =
                chipWaveCompletionB > 0
                  ? (1e3 - Math.min(chipWaveCompletionB, 1e3)) / 1e3
                  : 1;
            (inputSample +=
              chipWaveCompletionA > 0 ? lastWaveA * completionFadeA : waveA),
              (inputSample +=
                chipWaveCompletionB > 0
                  ? lastWaveB * completionFadeB
                  : waveB * unisonSign);
          }
          const sample = applyFilters(
            inputSample * volumeScale,
            initialFilterInput1,
            initialFilterInput2,
            filterCount,
            filters
          );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample * volumeScale),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA / waveLength),
          (tone.phases[1] = phaseB / waveLength),
          (tone.phaseDeltas[0] = phaseDeltaA / waveLength),
          (tone.phaseDeltas[1] = phaseDeltaB / waveLength),
          (tone.directions[0] = directionA),
          (tone.directions[1] = directionB),
          (tone.chipWaveCompletions[0] = chipWaveCompletionA),
          (tone.chipWaveCompletions[1] = chipWaveCompletionB),
          (tone.chipWavePrevWaves[0] = prevWaveA),
          (tone.chipWavePrevWaves[1] = prevWaveB),
          (tone.chipWaveCompletionsLastWave[0] = lastWaveA),
          (tone.chipWaveCompletionsLastWave[1] = lastWaveB),
          (tone.expression = expression),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static chipSynth(
        synth,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        instrumentState
      ) {
        const aliases =
            effectsIncludeDistortion(instrumentState.effects) &&
            instrumentState.aliases,
          data = synth.tempMonoInstrumentSampleBuffer,
          wave = instrumentState.wave,
          volumeScale = instrumentState.volumeScale,
          waveLength =
            aliases && 8 == instrumentState.type
              ? wave.length
              : wave.length - 1,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = tone.phaseDeltas[0] * waveLength,
          phaseDeltaB = tone.phaseDeltas[1] * waveLength;
        const phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phaseA = (tone.phases[0] % 1) * waveLength,
          phaseB = (tone.phases[1] % 1) * waveLength;
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters;
        let prevWaveIntegralA = 0,
          prevWaveIntegralB = 0;
        if (!aliases) {
          const phaseAInt = 0 | phaseA,
            phaseBInt = 0 | phaseB,
            indexA = phaseAInt % waveLength,
            indexB = phaseBInt % waveLength,
            phaseRatioA = phaseA - phaseAInt,
            phaseRatioB = phaseB - phaseBInt;
          (prevWaveIntegralA = +wave[indexA]),
            (prevWaveIntegralB = +wave[indexB]),
            (prevWaveIntegralA +=
              (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA),
            (prevWaveIntegralB +=
              (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB);
        }
        const stopIndex = bufferIndex + roundedSamplesPerTick;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          let waveA, waveB, inputSample;
          if (((phaseA += phaseDeltaA), (phaseB += phaseDeltaB), aliases))
            (waveA = wave[(0 | phaseA) % waveLength]),
              (waveB = wave[(0 | phaseB) % waveLength]),
              (inputSample = waveA + waveB);
          else {
            const phaseAInt = 0 | phaseA,
              phaseBInt = 0 | phaseB,
              indexA = phaseAInt % waveLength,
              indexB = phaseBInt % waveLength;
            let nextWaveIntegralA = wave[indexA],
              nextWaveIntegralB = wave[indexB];
            const phaseRatioA = phaseA - phaseAInt,
              phaseRatioB = phaseB - phaseBInt;
            (nextWaveIntegralA +=
              (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA),
              (nextWaveIntegralB +=
                (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB),
              (waveA = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA),
              (waveB = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB),
              (prevWaveIntegralA = nextWaveIntegralA),
              (prevWaveIntegralB = nextWaveIntegralB),
              (inputSample = waveA + waveB * unisonSign);
          }
          const sample = applyFilters(
            inputSample * volumeScale,
            initialFilterInput1,
            initialFilterInput2,
            filterCount,
            filters
          );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample * volumeScale),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA / waveLength),
          (tone.phases[1] = phaseB / waveLength),
          (tone.phaseDeltas[0] = phaseDeltaA / waveLength),
          (tone.phaseDeltas[1] = phaseDeltaB / waveLength),
          (tone.expression = expression),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static harmonicsSynth(
        synth,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        instrumentState
      ) {
        const data = synth.tempMonoInstrumentSampleBuffer,
          wave = instrumentState.wave,
          waveLength = wave.length - 1,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = tone.phaseDeltas[0] * waveLength,
          phaseDeltaB = tone.phaseDeltas[1] * waveLength;
        const phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phaseA = (tone.phases[0] % 1) * waveLength,
          phaseB = (tone.phases[1] % 1) * waveLength;
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters,
          phaseAInt = 0 | phaseA,
          phaseBInt = 0 | phaseB,
          indexA = phaseAInt % waveLength,
          indexB = phaseBInt % waveLength,
          phaseRatioA = phaseA - phaseAInt,
          phaseRatioB = phaseB - phaseBInt;
        let prevWaveIntegralA = +wave[indexA],
          prevWaveIntegralB = +wave[indexB];
        (prevWaveIntegralA +=
          (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA),
          (prevWaveIntegralB +=
            (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB);
        const stopIndex = bufferIndex + roundedSamplesPerTick;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          (phaseA += phaseDeltaA), (phaseB += phaseDeltaB);
          const phaseAInt = 0 | phaseA,
            phaseBInt = 0 | phaseB,
            indexA = phaseAInt % waveLength,
            indexB = phaseBInt % waveLength;
          let nextWaveIntegralA = wave[indexA],
            nextWaveIntegralB = wave[indexB];
          const phaseRatioA = phaseA - phaseAInt,
            phaseRatioB = phaseB - phaseBInt;
          (nextWaveIntegralA +=
            (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA),
            (nextWaveIntegralB +=
              (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB);
          const waveA = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA,
            waveB = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;
          (prevWaveIntegralA = nextWaveIntegralA),
            (prevWaveIntegralB = nextWaveIntegralB);
          const inputSample = waveA + waveB * unisonSign,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA / waveLength),
          (tone.phases[1] = phaseB / waveLength),
          (tone.phaseDeltas[0] = phaseDeltaA / waveLength),
          (tone.phaseDeltas[1] = phaseDeltaB / waveLength),
          (tone.expression = expression),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static pickedStringSynth(
        synth,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        instrumentState
      ) {
        const voiceCount = instrumentState.unisonVoices;
        let pickedStringFunction = Synth.pickedStringFunctionCache[voiceCount];
        if (null == pickedStringFunction) {
          let pickedStringSource =
            "return (synth, bufferIndex, runLength, tone, instrumentState) => {";
          pickedStringSource +=
            "\n\t\t\t\tconst Config = beepbox.Config;\n\t\t\t\tconst Synth = beepbox.Synth;\n\t\t\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tlet pickedString# = tone.pickedStrings[#];\n\t\t\t\tlet allPassSample# = +pickedString#.allPassSample;\n\t\t\t\tlet allPassPrevInput# = +pickedString#.allPassPrevInput;\n\t\t\t\tlet sustainFilterSample# = +pickedString#.sustainFilterSample;\n\t\t\t\tlet sustainFilterPrevOutput2# = +pickedString#.sustainFilterPrevOutput2;\n\t\t\t\tlet sustainFilterPrevInput1# = +pickedString#.sustainFilterPrevInput1;\n\t\t\t\tlet sustainFilterPrevInput2# = +pickedString#.sustainFilterPrevInput2;\n\t\t\t\tlet fractionalDelaySample# = +pickedString#.fractionalDelaySample;\n\t\t\t\tconst delayLine# = pickedString#.delayLine;\n\t\t\t\tconst delayBufferMask# = (delayLine#.length - 1) >> 0;\n\t\t\t\tlet delayIndex# = pickedString#.delayIndex|0;\n\t\t\t\tdelayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;\n\t\t\t\tlet delayLength# = +pickedString#.prevDelayLength;\n\t\t\t\tconst delayLengthDelta# = +pickedString#.delayLengthDelta;\n\t\t\t\tlet allPassG# = +pickedString#.allPassG;\n\t\t\t\tlet sustainFilterA1# = +pickedString#.sustainFilterA1;\n\t\t\t\tlet sustainFilterA2# = +pickedString#.sustainFilterA2;\n\t\t\t\tlet sustainFilterB0# = +pickedString#.sustainFilterB0;\n\t\t\t\tlet sustainFilterB1# = +pickedString#.sustainFilterB1;\n\t\t\t\tlet sustainFilterB2# = +pickedString#.sustainFilterB2;\n\t\t\t\tconst allPassGDelta# = +pickedString#.allPassGDelta;\n\t\t\t\tconst sustainFilterA1Delta# = +pickedString#.sustainFilterA1Delta;\n\t\t\t\tconst sustainFilterA2Delta# = +pickedString#.sustainFilterA2Delta;\n\t\t\t\tconst sustainFilterB0Delta# = +pickedString#.sustainFilterB0Delta;\n\t\t\t\tconst sustainFilterB1Delta# = +pickedString#.sustainFilterB1Delta;\n\t\t\t\tconst sustainFilterB2Delta# = +pickedString#.sustainFilterB2Delta;\n\t\t\t\t\n\t\t\t\tlet expression = +tone.expression;\n\t\t\t\tconst expressionDelta = +tone.expressionDelta;\n\t\t\t\t\n\t\t\t\tconst unisonSign = tone.specialIntervalExpressionMult * instrumentState.unisonSign;\n\t\t\t\tconst delayResetOffset# = pickedString#.delayResetOffset|0;\n\t\t\t\t\n\t\t\t\tconst filters = tone.noteFilters;\n\t\t\t\tconst filterCount = tone.noteFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\t\t\tconst applyFilters = Synth.applyFilters;\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tconst targetSampleTime# = delayIndex# - delayLength#;\n\t\t\t\t\tconst lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.\n\t\t\t\t\tconst upperIndex# = lowerIndex# + 1;\n\t\t\t\t\tconst fractionalDelay# = upperIndex# - targetSampleTime#;\n\t\t\t\t\tconst fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\t\tconst prevInput# = delayLine#[lowerIndex# & delayBufferMask#];\n\t\t\t\t\tconst input# = delayLine#[upperIndex# & delayBufferMask#];\n\t\t\t\t\tfractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tallPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;\n\t\t\t\t\tallPassPrevInput# = fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tconst sustainFilterPrevOutput1# = sustainFilterSample#;\n\t\t\t\t\tsustainFilterSample# = sustainFilterB0# * allPassSample# + sustainFilterB1# * sustainFilterPrevInput1# + sustainFilterB2# * sustainFilterPrevInput2# - sustainFilterA1# * sustainFilterSample# - sustainFilterA2# * sustainFilterPrevOutput2#;\n\t\t\t\t\tsustainFilterPrevOutput2# = sustainFilterPrevOutput1#;\n\t\t\t\t\tsustainFilterPrevInput2# = sustainFilterPrevInput1#;\n\t\t\t\t\tsustainFilterPrevInput1# = allPassSample#;\n\t\t\t\t\t\n\t\t\t\t\tdelayLine#[delayIndex# & delayBufferMask#] += sustainFilterSample#;\n\t\t\t\t\tdelayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;\n\t\t\t\t\tdelayIndex#++;\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = (";
          const sampleList = [];
          for (let voice = 0; voice < voiceCount; voice++)
            sampleList.push(
              "fractionalDelaySample" +
                voice +
                (1 == voice ? " * unisonSign" : "")
            );
          (pickedStringSource += sampleList.join(" + ")),
            (pickedStringSource +=
              ") * expression;\n\t\t\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\t\tdata[sampleIndex] += sample;\n\t\t\t\t\t\n\t\t\t\t\texpression += expressionDelta;\n\t\t\t\t\tdelayLength# += delayLengthDelta#;\n\t\t\t\t\tallPassG# += allPassGDelta#;\n\t\t\t\t\tsustainFilterA1# += sustainFilterA1Delta#;\n\t\t\t\t\tsustainFilterA2# += sustainFilterA2Delta#;\n\t\t\t\t\tsustainFilterB0# += sustainFilterB0Delta#;\n\t\t\t\t\tsustainFilterB1# += sustainFilterB1Delta#;\n\t\t\t\t\tsustainFilterB2# += sustainFilterB2Delta#;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);\n\t\t\t\tif (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterSample#) || Math.abs(sustainFilterSample#) < epsilon) sustainFilterSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevOutput2#) || Math.abs(sustainFilterPrevOutput2#) < epsilon) sustainFilterPrevOutput2# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput1#) || Math.abs(sustainFilterPrevInput1#) < epsilon) sustainFilterPrevInput1# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput2#) || Math.abs(sustainFilterPrevInput2#) < epsilon) sustainFilterPrevInput2# = 0.0;\n\t\t\t\tif (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;\n\t\t\t\tpickedString#.allPassSample = allPassSample#;\n\t\t\t\tpickedString#.allPassPrevInput = allPassPrevInput#;\n\t\t\t\tpickedString#.sustainFilterSample = sustainFilterSample#;\n\t\t\t\tpickedString#.sustainFilterPrevOutput2 = sustainFilterPrevOutput2#;\n\t\t\t\tpickedString#.sustainFilterPrevInput1 = sustainFilterPrevInput1#;\n\t\t\t\tpickedString#.sustainFilterPrevInput2 = sustainFilterPrevInput2#;\n\t\t\t\tpickedString#.fractionalDelaySample = fractionalDelaySample#;\n\t\t\t\tpickedString#.delayIndex = delayIndex#;\n\t\t\t\tpickedString#.prevDelayLength = delayLength#;\n\t\t\t\tpickedString#.allPassG = allPassG#;\n\t\t\t\tpickedString#.sustainFilterA1 = sustainFilterA1#;\n\t\t\t\tpickedString#.sustainFilterA2 = sustainFilterA2#;\n\t\t\t\tpickedString#.sustainFilterB0 = sustainFilterB0#;\n\t\t\t\tpickedString#.sustainFilterB1 = sustainFilterB1#;\n\t\t\t\tpickedString#.sustainFilterB2 = sustainFilterB2#;\n\t\t\t\t\n\t\t\t\ttone.expression = expression;\n\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\t\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\n\t\t\t}"),
            (pickedStringSource = pickedStringSource.replace(
              /^.*\#.*$/gm,
              (line) => {
                const lines = [];
                for (let voice = 0; voice < voiceCount; voice++)
                  lines.push(line.replace(/\#/g, String(voice)));
                return lines.join("\n");
              }
            )),
            (pickedStringFunction = new Function(
              "Config",
              "Synth",
              pickedStringSource
            )(Config, Synth)),
            (Synth.pickedStringFunctionCache[voiceCount] =
              pickedStringFunction);
        }
        pickedStringFunction(
          synth,
          bufferIndex,
          roundedSamplesPerTick,
          tone,
          instrumentState
        );
      }
      static effectsSynth(
        synth,
        outputDataL,
        outputDataR,
        bufferIndex,
        runLength,
        instrumentState
      ) {
        const usesDistortion = effectsIncludeDistortion(
            instrumentState.effects
          ),
          usesBitcrusher = effectsIncludeBitcrusher(instrumentState.effects),
          usesEqFilter = instrumentState.eqFilterCount > 0,
          usesPanning = effectsIncludePanning(instrumentState.effects),
          usesChorus = effectsIncludeChorus(instrumentState.effects),
          usesEcho = effectsIncludeEcho(instrumentState.effects),
          usesReverb = effectsIncludeReverb(instrumentState.effects);
        let signature = 0;
        usesDistortion && (signature |= 1),
          (signature <<= 1),
          usesBitcrusher && (signature |= 1),
          (signature <<= 1),
          usesEqFilter && (signature |= 1),
          (signature <<= 1),
          usesPanning && (signature |= 1),
          (signature <<= 1),
          usesChorus && (signature |= 1),
          (signature <<= 1),
          usesEcho && (signature |= 1),
          (signature <<= 1),
          usesReverb && (signature |= 1);
        let effectsFunction = Synth.effectsFunctionCache[signature];
        if (null == effectsFunction) {
          let effectsSource =
            "return (synth, outputDataL, outputDataR, bufferIndex, runLength, instrumentState) => {";
          const usesDelays = usesChorus || usesReverb || usesEcho;
          (effectsSource +=
            "\n\t\t\t\tconst tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tlet mixVolume = +instrumentState.mixVolume;\n\t\t\t\tconst mixVolumeDelta = +instrumentState.mixVolumeDelta;"),
            usesDelays &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tlet delayInputMult = +instrumentState.delayInputMult;\n\t\t\t\tconst delayInputMultDelta = +instrumentState.delayInputMultDelta;"),
            usesDistortion &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tconst distortionBaseVolume = +Config.distortionBaseVolume;\n\t\t\t\tlet distortion = instrumentState.distortion;\n\t\t\t\tconst distortionDelta = instrumentState.distortionDelta;\n\t\t\t\tlet distortionDrive = instrumentState.distortionDrive;\n\t\t\t\tconst distortionDriveDelta = instrumentState.distortionDriveDelta;\n\t\t\t\tconst distortionFractionalResolution = 4.0;\n\t\t\t\tconst distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;\n\t\t\t\tconst distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;\n\t\t\t\tconst distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;\n\t\t\t\tconst distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;\n\t\t\t\t\n\t\t\t\tlet distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;\n\t\t\t\tlet distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;\n\t\t\t\tlet distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;\n\t\t\t\tlet distortionPrevInput = +instrumentState.distortionPrevInput;\n\t\t\t\tlet distortionNextOutput = +instrumentState.distortionNextOutput;"),
            usesBitcrusher &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tlet bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;\n\t\t\t\tlet bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;\n\t\t\t\tlet bitcrusherPhase = +instrumentState.bitcrusherPhase;\n\t\t\t\tlet bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;\n\t\t\t\tconst bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;\n\t\t\t\tlet bitcrusherScale = +instrumentState.bitcrusherScale;\n\t\t\t\tconst bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;\n\t\t\t\tlet bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;\n\t\t\t\tconst bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;"),
            usesEqFilter &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tlet filters = instrumentState.eqFilters;\n\t\t\t\tconst filterCount = instrumentState.eqFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +instrumentState.initialEqFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +instrumentState.initialEqFilterInput2;\n\t\t\t\tconst applyFilters = Synth.applyFilters;"),
            (effectsSource +=
              "\n\t\t\t\t\n\t\t\t\tlet eqFilterVolume = +instrumentState.eqFilterVolume;\n\t\t\t\tconst eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;"),
            usesPanning &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tconst panningMask = synth.panningDelayBufferMask >>> 0;\n\t\t\t\tconst panningDelayLine = instrumentState.panningDelayLine;\n\t\t\t\tlet panningDelayPos = instrumentState.panningDelayPos & panningMask;\n\t\t\t\tlet   panningVolumeL      = +instrumentState.panningVolumeL;\n\t\t\t\tlet   panningVolumeR      = +instrumentState.panningVolumeR;\n\t\t\t\tconst panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;\n\t\t\t\tconst panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;\n\t\t\t\tlet   panningOffsetL      = +instrumentState.panningOffsetL;\n\t\t\t\tlet   panningOffsetR      = +instrumentState.panningOffsetR;\n\t\t\t\tconst panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;\n\t\t\t\tconst panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;"),
            usesChorus &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tconst chorusMask = synth.chorusDelayBufferMask >>> 0;\n\t\t\t\tconst chorusDelayLineL = instrumentState.chorusDelayLineL;\n\t\t\t\tconst chorusDelayLineR = instrumentState.chorusDelayLineR;\n\t\t\t\tinstrumentState.chorusDelayLineDirty = true;\n\t\t\t\tlet chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;\n\t\t\t\t\n\t\t\t\tlet chorusVoiceMult = +instrumentState.chorusVoiceMult;\n\t\t\t\tconst chorusVoiceMultDelta = +instrumentState.chorusVoiceMultDelta;\n\t\t\t\tlet chorusCombinedMult = +instrumentState.chorusCombinedMult;\n\t\t\t\tconst chorusCombinedMultDelta = +instrumentState.chorusCombinedMultDelta;\n\t\t\t\t\n\t\t\t\tconst chorusDuration = +beepbox.Config.chorusPeriodSeconds;\n\t\t\t\tconst chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);\n\t\t\t\tconst chorusRange = synth.samplesPerSecond * beepbox.Config.chorusDelayRange;\n\t\t\t\tconst chorusOffset0 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][0] * chorusRange;\n\t\t\t\tconst chorusOffset1 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][1] * chorusRange;\n\t\t\t\tconst chorusOffset2 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][2] * chorusRange;\n\t\t\t\tconst chorusOffset3 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][0] * chorusRange;\n\t\t\t\tconst chorusOffset4 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][1] * chorusRange;\n\t\t\t\tconst chorusOffset5 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][2] * chorusRange;\n\t\t\t\tlet chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);\n\t\t\t\tlet chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]);\n\t\t\t\tlet chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]);\n\t\t\t\tlet chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]);\n\t\t\t\tlet chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]);\n\t\t\t\tlet chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]);\n\t\t\t\tlet chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]);\n\t\t\t\tchorusPhase += chorusAngle * runLength;\n\t\t\t\tconst chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]) + runLength;\n\t\t\t\tconst chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]) + runLength;\n\t\t\t\tconst chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]) + runLength;\n\t\t\t\tconst chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]) + runLength;\n\t\t\t\tconst chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]) + runLength;\n\t\t\t\tconst chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]) + runLength;\n\t\t\t\tconst chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;\n\t\t\t\tconst chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;\n\t\t\t\tconst chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;\n\t\t\t\tconst chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;\n\t\t\t\tconst chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;\n\t\t\t\tconst chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;"),
            usesEcho &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tlet echoMult = +instrumentState.echoMult;\n\t\t\t\tconst echoMultDelta = +instrumentState.echoMultDelta;\n\t\t\t\t\n\t\t\t\tconst echoDelayLineL = instrumentState.echoDelayLineL;\n\t\t\t\tconst echoDelayLineR = instrumentState.echoDelayLineR;\n\t\t\t\tconst echoMask = (echoDelayLineL.length - 1) >>> 0;\n\t\t\t\tinstrumentState.echoDelayLineDirty = true;\n\t\t\t\t\n\t\t\t\tlet echoDelayPos = instrumentState.echoDelayPos & echoMask;\n\t\t\t\tconst echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;\n\t\t\t\tconst echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;\n\t\t\t\tlet echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;\n\t\t\t\tconst echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;\n\t\t\t\t\n\t\t\t\tconst echoShelfA1 = +instrumentState.echoShelfA1;\n\t\t\t\tconst echoShelfB0 = +instrumentState.echoShelfB0;\n\t\t\t\tconst echoShelfB1 = +instrumentState.echoShelfB1;\n\t\t\t\tlet echoShelfSampleL = +instrumentState.echoShelfSampleL;\n\t\t\t\tlet echoShelfSampleR = +instrumentState.echoShelfSampleR;\n\t\t\t\tlet echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;\n\t\t\t\tlet echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;"),
            usesReverb &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tconst reverbMask = Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.\n\t\t\t\tconst reverbDelayLine = instrumentState.reverbDelayLine;\n\t\t\t\tinstrumentState.reverbDelayLineDirty = true;\n\t\t\t\tlet reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;\n\t\t\t\t\n\t\t\t\tlet reverb = +instrumentState.reverbMult;\n\t\t\t\tconst reverbDelta = +instrumentState.reverbMultDelta;\n\t\t\t\t\n\t\t\t\tconst reverbShelfA1 = +instrumentState.reverbShelfA1;\n\t\t\t\tconst reverbShelfB0 = +instrumentState.reverbShelfB0;\n\t\t\t\tconst reverbShelfB1 = +instrumentState.reverbShelfB1;\n\t\t\t\tlet reverbShelfSample0 = +instrumentState.reverbShelfSample0;\n\t\t\t\tlet reverbShelfSample1 = +instrumentState.reverbShelfSample1;\n\t\t\t\tlet reverbShelfSample2 = +instrumentState.reverbShelfSample2;\n\t\t\t\tlet reverbShelfSample3 = +instrumentState.reverbShelfSample3;\n\t\t\t\tlet reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;\n\t\t\t\tlet reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;\n\t\t\t\tlet reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;\n\t\t\t\tlet reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;"),
            (effectsSource +=
              "\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tlet sample = tempMonoInstrumentSampleBuffer[sampleIndex];\n\t\t\t\t\ttempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;"),
            usesDistortion &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tconst distortionReverse = 1.0 - distortion;\n\t\t\t\t\tconst distortionNextInput = sample * distortionDrive;\n\t\t\t\t\tsample = distortionNextOutput;\n\t\t\t\t\tdistortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);\n\t\t\t\t\tdistortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;\n\t\t\t\t\tdistortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;\n\t\t\t\t\tdistortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;\n\t\t\t\t\tconst distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);\n\t\t\t\t\tconst distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);\n\t\t\t\t\tconst distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);\n\t\t\t\t\tdistortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;\n\t\t\t\t\tsample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;\n\t\t\t\t\tsample *= distortionOversampleCompensation;\n\t\t\t\t\tdistortionPrevInput = distortionNextInput;\n\t\t\t\t\tdistortion += distortionDelta;\n\t\t\t\t\tdistortionDrive += distortionDriveDelta;"),
            usesBitcrusher &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tbitcrusherPhase += bitcrusherPhaseDelta;\n\t\t\t\t\tif (bitcrusherPhase < 1.0) {\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\tsample = bitcrusherCurrentOutput;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbitcrusherPhase = bitcrusherPhase % 1.0;\n\t\t\t\t\t\tconst ratio = bitcrusherPhase / bitcrusherPhaseDelta;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;\n\t\t\t\t\t\tconst wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;\n\t\t\t\t\t\tconst foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);\n\t\t\t\t\t\tconst scaledSample = foldedSample / bitcrusherScale;\n\t\t\t\t\t\tconst oldValue = bitcrusherCurrentOutput;\n\t\t\t\t\t\tconst newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsample = oldValue + (newValue - oldValue) * ratio;\n\t\t\t\t\t\tbitcrusherCurrentOutput = newValue;\n\t\t\t\t\t}\n\t\t\t\t\tbitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;\n\t\t\t\t\tbitcrusherScale *= bitcrusherScaleScale;\n\t\t\t\t\tbitcrusherFoldLevel *= bitcrusherFoldLevelScale;"),
            usesEqFilter &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = sample;\n\t\t\t\t\tsample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;"),
            (effectsSource +=
              "\n\t\t\t\t\t\n\t\t\t\t\tsample *= eqFilterVolume;\n\t\t\t\t\teqFilterVolume += eqFilterVolumeDelta;"),
            (effectsSource += usesPanning
              ? "\n\t\t\t\t\t\n\t\t\t\t\tpanningDelayLine[panningDelayPos] = sample;\n\t\t\t\t\tconst panningRatioL  = panningOffsetL % 1;\n\t\t\t\t\tconst panningRatioR  = panningOffsetR % 1;\n\t\t\t\t\tconst panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];\n\t\t\t\t\tconst panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];\n\t\t\t\t\tconst panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];\n\t\t\t\t\tconst panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];\n\t\t\t\t\tconst panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;\n\t\t\t\t\tconst panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;\n\t\t\t\t\tlet sampleL = panningTapL * panningVolumeL;\n\t\t\t\t\tlet sampleR = panningTapR * panningVolumeR;\n\t\t\t\t\tpanningDelayPos = (panningDelayPos + 1) & panningMask;\n\t\t\t\t\tpanningVolumeL += panningVolumeDeltaL;\n\t\t\t\t\tpanningVolumeR += panningVolumeDeltaR;\n\t\t\t\t\tpanningOffsetL += panningOffsetDeltaL;\n\t\t\t\t\tpanningOffsetR += panningOffsetDeltaR;"
              : "\n\t\t\t\t\t\n\t\t\t\t\tlet sampleL = sample;\n\t\t\t\t\tlet sampleR = sample;"),
            usesChorus &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tconst chorusTap0Ratio = chorusTap0Index % 1;\n\t\t\t\t\tconst chorusTap1Ratio = chorusTap1Index % 1;\n\t\t\t\t\tconst chorusTap2Ratio = chorusTap2Index % 1;\n\t\t\t\t\tconst chorusTap3Ratio = chorusTap3Index % 1;\n\t\t\t\t\tconst chorusTap4Ratio = chorusTap4Index % 1;\n\t\t\t\t\tconst chorusTap5Ratio = chorusTap5Index % 1;\n\t\t\t\t\tconst chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];\n\t\t\t\t\tconst chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];\n\t\t\t\t\tconst chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];\n\t\t\t\t\tconst chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];\n\t\t\t\t\tconst chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];\n\t\t\t\t\tconst chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];\n\t\t\t\t\tconst chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;\n\t\t\t\t\tconst chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;\n\t\t\t\t\tconst chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;\n\t\t\t\t\tconst chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;\n\t\t\t\t\tconst chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;\n\t\t\t\t\tconst chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;\n\t\t\t\t\tchorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\tchorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\tsampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));\n\t\t\t\t\tsampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));\n\t\t\t\t\tchorusDelayPos = (chorusDelayPos + 1) & chorusMask;\n\t\t\t\t\tchorusTap0Index += chorusTap0Delta;\n\t\t\t\t\tchorusTap1Index += chorusTap1Delta;\n\t\t\t\t\tchorusTap2Index += chorusTap2Delta;\n\t\t\t\t\tchorusTap3Index += chorusTap3Delta;\n\t\t\t\t\tchorusTap4Index += chorusTap4Delta;\n\t\t\t\t\tchorusTap5Index += chorusTap5Delta;\n\t\t\t\t\tchorusVoiceMult += chorusVoiceMultDelta;\n\t\t\t\t\tchorusCombinedMult += chorusCombinedMultDelta;"),
            usesEcho &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tconst echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;\n\t\t\t\t\tconst echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;\n\t\t\t\t\tconst echoTapStartL = echoDelayLineL[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndL   = echoDelayLineL[echoTapEndIndex];\n\t\t\t\t\tconst echoTapStartR = echoDelayLineR[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndR   = echoDelayLineR[echoTapEndIndex];\n\t\t\t\t\tconst echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\tconst echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\t\n\t\t\t\t\techoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;\n\t\t\t\t\techoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;\n\t\t\t\t\techoShelfPrevInputL = echoTapL;\n\t\t\t\t\techoShelfPrevInputR = echoTapR;\n\t\t\t\t\tsampleL += echoShelfSampleL;\n\t\t\t\t\tsampleR += echoShelfSampleR;\n\t\t\t\t\t\n\t\t\t\t\techoDelayLineL[echoDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\techoDelayLineR[echoDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\techoDelayPos = (echoDelayPos + 1) & echoMask;\n\t\t\t\t\techoDelayOffsetRatio += echoDelayOffsetRatioDelta;\n\t\t\t\t\techoMult += echoMultDelta;\n                    "),
            usesReverb &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\t// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.\n\t\t\t\t\t// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268\n\t\t\t\t\t// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14\n\t\t\t\t\t// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384\n\t\t\t\t\tconst reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;\n\t\t\t\t\tconst reverbSample0 = (reverbDelayLine[reverbDelayPos]);\n\t\t\t\t\tconst reverbSample1 = reverbDelayLine[reverbDelayPos1];\n\t\t\t\t\tconst reverbSample2 = reverbDelayLine[reverbDelayPos2];\n\t\t\t\t\tconst reverbSample3 = reverbDelayLine[reverbDelayPos3];\n\t\t\t\t\tconst reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;\n\t\t\t\t\tconst reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;\n\t\t\t\t\tconst reverbTemp2 = -reverbSample2 + reverbSample3;\n\t\t\t\t\tconst reverbTemp3 = -reverbSample2 - reverbSample3;\n\t\t\t\t\tconst reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;\n\t\t\t\t\tconst reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;\n\t\t\t\t\treverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;\n\t\t\t\t\treverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;\n\t\t\t\t\treverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;\n\t\t\t\t\treverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;\n\t\t\t\t\treverbShelfPrevInput0 = reverbShelfInput0;\n\t\t\t\t\treverbShelfPrevInput1 = reverbShelfInput1;\n\t\t\t\t\treverbShelfPrevInput2 = reverbShelfInput2;\n\t\t\t\t\treverbShelfPrevInput3 = reverbShelfInput3;\n\t\t\t\t\treverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;\n\t\t\t\t\treverbDelayPos = (reverbDelayPos + 1) & reverbMask;\n\t\t\t\t\tsampleL += reverbSample1 + reverbSample2 + reverbSample3;\n\t\t\t\t\tsampleR += reverbSample0 + reverbSample2 - reverbSample3;\n\t\t\t\t\treverb += reverbDelta;"),
            (effectsSource +=
              "\n\t\t\t\t\t\n\t\t\t\t\toutputDataL[sampleIndex] += sampleL * mixVolume;\n\t\t\t\t\toutputDataR[sampleIndex] += sampleR * mixVolume;\n\t\t\t\t\tmixVolume += mixVolumeDelta;"),
            usesDelays &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\t\tdelayInputMult += delayInputMultDelta;"),
            (effectsSource +=
              "\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinstrumentState.mixVolume = mixVolume;\n\t\t\t\tinstrumentState.eqFilterVolume = eqFilterVolume;\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);"),
            usesDelays &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tinstrumentState.delayInputMult = delayInputMult;"),
            usesDistortion &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tinstrumentState.distortion = distortion;\n\t\t\t\tinstrumentState.distortionDrive = distortionDrive;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;\n\t\t\t\t\n\t\t\t\tinstrumentState.distortionFractionalInput1 = distortionFractionalInput1;\n\t\t\t\tinstrumentState.distortionFractionalInput2 = distortionFractionalInput2;\n\t\t\t\tinstrumentState.distortionFractionalInput3 = distortionFractionalInput3;\n\t\t\t\tinstrumentState.distortionPrevInput = distortionPrevInput;\n\t\t\t\tinstrumentState.distortionNextOutput = distortionNextOutput;"),
            usesBitcrusher &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\tif (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;\n\t\t\t\tif (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;\n\t\t\t\tinstrumentState.bitcrusherPrevInput = bitcrusherPrevInput;\n\t\t\t\tinstrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;\n\t\t\t\tinstrumentState.bitcrusherPhase = bitcrusherPhase;\n\t\t\t\tinstrumentState.bitcrusherPhaseDelta = bitcrusherPhaseDelta;\n\t\t\t\tinstrumentState.bitcrusherScale = bitcrusherScale;\n\t\t\t\tinstrumentState.bitcrusherFoldLevel = bitcrusherFoldLevel;"),
            usesEqFilter &&
              (effectsSource +=
                "\n\t\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\t// The filter input here is downstream from another filter so we\n\t\t\t\t// better make sure it's safe too.\n\t\t\t\tif (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {\n\t\t\t\t\tinitialFilterInput1 = 0.0;\n\t\t\t\t\tinitialFilterInput2 = 0.0;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;\n\t\t\t\tif (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;\n\t\t\t\tinstrumentState.initialEqFilterInput1 = initialFilterInput1;\n\t\t\t\tinstrumentState.initialEqFilterInput2 = initialFilterInput2;"),
            usesPanning &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);\n\t\t\t\tinstrumentState.panningDelayPos = panningDelayPos;\n\t\t\t\tinstrumentState.panningVolumeL = panningVolumeL;\n\t\t\t\tinstrumentState.panningVolumeR = panningVolumeR;\n\t\t\t\tinstrumentState.panningOffsetL = panningOffsetL;\n\t\t\t\tinstrumentState.panningOffsetR = panningOffsetR;"),
            usesChorus &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);\n\t\t\t\tinstrumentState.chorusPhase = chorusPhase;\n\t\t\t\tinstrumentState.chorusDelayPos = chorusDelayPos;\n\t\t\t\tinstrumentState.chorusVoiceMult = chorusVoiceMult;\n\t\t\t\tinstrumentState.chorusCombinedMult = chorusCombinedMult;"),
            usesEcho &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);\n\t\t\t\tinstrumentState.echoDelayPos = echoDelayPos;\n\t\t\t\tinstrumentState.echoMult = echoMult;\n\t\t\t\tinstrumentState.echoDelayOffsetRatio = echoDelayOffsetRatio;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;\n\t\t\t\tinstrumentState.echoShelfSampleL = echoShelfSampleL;\n\t\t\t\tinstrumentState.echoShelfSampleR = echoShelfSampleR;\n\t\t\t\tinstrumentState.echoShelfPrevInputL = echoShelfPrevInputL;\n\t\t\t\tinstrumentState.echoShelfPrevInputR = echoShelfPrevInputR;"),
            usesReverb &&
              (effectsSource +=
                "\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);\n\t\t\t\tinstrumentState.reverbDelayPos = reverbDelayPos;\n\t\t\t\tinstrumentState.reverbMult = reverb;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;\n\t\t\t\tinstrumentState.reverbShelfSample0 = reverbShelfSample0;\n\t\t\t\tinstrumentState.reverbShelfSample1 = reverbShelfSample1;\n\t\t\t\tinstrumentState.reverbShelfSample2 = reverbShelfSample2;\n\t\t\t\tinstrumentState.reverbShelfSample3 = reverbShelfSample3;\n\t\t\t\tinstrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;\n\t\t\t\tinstrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;\n\t\t\t\tinstrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;\n\t\t\t\tinstrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;"),
            (effectsSource += "}"),
            (effectsFunction = new Function("Config", "Synth", effectsSource)(
              Config,
              Synth
            )),
            (Synth.effectsFunctionCache[signature] = effectsFunction);
        }
        effectsFunction(
          synth,
          outputDataL,
          outputDataR,
          bufferIndex,
          runLength,
          instrumentState
        );
      }
      static pulseWidthSynth(
        synth,
        bufferIndex,
        roundedSamplesPerTick,
        tone,
        instrumentState
      ) {
        const data = synth.tempMonoInstrumentSampleBuffer,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = tone.phaseDeltas[0],
          phaseDeltaB = tone.phaseDeltas[1];
        const phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phaseA = tone.phases[0] % 1,
          phaseB = tone.phases[1] % 1,
          pulseWidth = tone.pulseWidth;
        const pulseWidthDelta = tone.pulseWidthDelta,
          filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters,
          stopIndex = bufferIndex + roundedSamplesPerTick;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          const sawPhaseA = phaseA % 1,
            sawPhaseB = (phaseA + pulseWidth) % 1,
            sawPhaseC = phaseB % 1,
            sawPhaseD = (phaseB + pulseWidth) % 1;
          let pulseWaveA = sawPhaseB - sawPhaseA,
            pulseWaveB = sawPhaseD - sawPhaseC;
          if (!instrumentState.aliases) {
            var t, t, t, t;
            if (sawPhaseA < phaseDeltaA)
              pulseWaveA +=
                0.5 * ((t = sawPhaseA / phaseDeltaA) + t - t * t - 1);
            else if (sawPhaseA > 1 - phaseDeltaA) {
              var t;
              pulseWaveA +=
                0.5 * ((t = (sawPhaseA - 1) / phaseDeltaA) + t + t * t + 1);
            }
            if (sawPhaseB < phaseDeltaA)
              pulseWaveA -=
                0.5 * ((t = sawPhaseB / phaseDeltaA) + t - t * t - 1);
            else if (sawPhaseB > 1 - phaseDeltaA) {
              var t;
              pulseWaveA -=
                0.5 * ((t = (sawPhaseB - 1) / phaseDeltaA) + t + t * t + 1);
            }
            if (sawPhaseC < phaseDeltaB)
              pulseWaveB +=
                0.5 * ((t = sawPhaseC / phaseDeltaB) + t - t * t - 1);
            else if (sawPhaseC > 1 - phaseDeltaB) {
              var t;
              pulseWaveB +=
                0.5 * ((t = (sawPhaseC - 1) / phaseDeltaB) + t + t * t + 1);
            }
            if (sawPhaseD < phaseDeltaB)
              pulseWaveB -=
                0.5 * ((t = sawPhaseD / phaseDeltaB) + t - t * t - 1);
            else if (sawPhaseD > 1 - phaseDeltaB) {
              var t;
              pulseWaveB -=
                0.5 * ((t = (sawPhaseD - 1) / phaseDeltaB) + t + t * t + 1);
            }
          }
          const inputSample = pulseWaveA + pulseWaveB * unisonSign,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phaseA += phaseDeltaA),
            (phaseB += phaseDeltaB),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB),
            (pulseWidth += pulseWidthDelta);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA),
          (tone.phases[1] = phaseB),
          (tone.phaseDeltas[0] = phaseDeltaA),
          (tone.phaseDeltas[1] = phaseDeltaB),
          (tone.expression = expression),
          (tone.pulseWidth = pulseWidth),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static supersawSynth(
        synth,
        bufferIndex,
        runLength,
        tone,
        instrumentState
      ) {
        const data = synth.tempMonoInstrumentSampleBuffer,
          voiceCount = 0 | Config.supersawVoiceCount;
        let phaseDelta = tone.phaseDeltas[0];
        const phaseDeltaScale = +tone.phaseDeltaScales[0];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phases = tone.phases,
          dynamism = +tone.supersawDynamism;
        const dynamismDelta = +tone.supersawDynamismDelta,
          unisonDetunes = tone.supersawUnisonDetunes;
        let shape = +tone.supersawShape;
        const shapeDelta = +tone.supersawShapeDelta;
        let delayLength = +tone.supersawDelayLength;
        const delayLengthDelta = +tone.supersawDelayLengthDelta,
          delayLine = tone.supersawDelayLine,
          delayBufferMask = (delayLine.length - 1) >> 0;
        let delayIndex = 0 | tone.supersawDelayIndex;
        delayIndex = (delayIndex & delayBufferMask) + delayLine.length;
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters,
          stopIndex = bufferIndex + runLength;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          let phase = (phases[0] + phaseDelta) % 1,
            supersawSample = phase - 0.5 * (1 + (voiceCount - 1) * dynamism);
          var t;
          if (!instrumentState.aliases)
            if (phase < phaseDelta)
              supersawSample -=
                0.5 * ((t = phase / phaseDelta) + t - t * t - 1);
            else if (phase > 1 - phaseDelta) {
              var t;
              supersawSample -=
                0.5 * ((t = (phase - 1) / phaseDelta) + t + t * t + 1);
            }
          phases[0] = phase;
          for (let i = 1; i < voiceCount; i++) {
            const detunedPhaseDelta = phaseDelta * unisonDetunes[i];
            let phase = (phases[i] + detunedPhaseDelta) % 1;
            if (
              ((supersawSample += phase * dynamism), !instrumentState.aliases)
            )
              if (phase < detunedPhaseDelta) {
                const t = phase / detunedPhaseDelta;
                supersawSample -= 0.5 * (t + t - t * t - 1) * dynamism;
              } else if (phase > 1 - detunedPhaseDelta) {
                const t = (phase - 1) / detunedPhaseDelta;
                supersawSample -= 0.5 * (t + t + t * t + 1) * dynamism;
              }
            phases[i] = phase;
          }
          delayLine[delayIndex & delayBufferMask] = supersawSample;
          const delaySampleTime = delayIndex - delayLength,
            lowerIndex = 0 | delaySampleTime,
            upperIndex = lowerIndex + 1,
            delayRatio = delaySampleTime - lowerIndex,
            prevDelaySample = delayLine[lowerIndex & delayBufferMask],
            nextDelaySample = delayLine[upperIndex & delayBufferMask],
            delaySample =
              prevDelaySample +
              (nextDelaySample - prevDelaySample) * delayRatio;
          delayIndex++;
          const inputSample = supersawSample - delaySample * shape,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phaseDelta *= phaseDeltaScale),
            (dynamism += dynamismDelta),
            (shape += shapeDelta),
            (delayLength += delayLengthDelta);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phaseDeltas[0] = phaseDelta),
          (tone.expression = expression),
          (tone.supersawDynamism = dynamism),
          (tone.supersawShape = shape),
          (tone.supersawDelayLength = delayLength),
          (tone.supersawDelayIndex = delayIndex),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static noiseSynth(synth, bufferIndex, runLength, tone, instrumentState) {
        const data = synth.tempMonoInstrumentSampleBuffer,
          wave = instrumentState.wave,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = tone.phaseDeltas[0],
          phaseDeltaB = tone.phaseDeltas[1];
        const phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let phaseA = (tone.phases[0] % 1) * Config.chipNoiseLength,
          phaseB = (tone.phases[1] % 1) * Config.chipNoiseLength;
        0 == tone.phases[0] &&
          ((phaseA = Math.random() * Config.chipNoiseLength),
          1 != instrumentState.unisonVoices ||
            0 != instrumentState.unisonSpread ||
            instrumentState.chord.customInterval ||
            (phaseB = phaseA)),
          0 != tone.phases[1] ||
            (1 == instrumentState.unisonVoices &&
              0 == instrumentState.unisonSpread &&
              !instrumentState.chord.customInterval) ||
            (phaseB = Math.random() * Config.chipNoiseLength);
        const phaseMask = Config.chipNoiseLength - 1;
        let noiseSampleA = +tone.noiseSampleA,
          noiseSampleB = +tone.noiseSampleB;
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters,
          pitchRelativefilterA = Math.min(
            1,
            phaseDeltaA * instrumentState.noisePitchFilterMult
          ),
          pitchRelativefilterB = Math.min(
            1,
            phaseDeltaB * instrumentState.noisePitchFilterMult
          ),
          stopIndex = bufferIndex + runLength;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          const waveSampleA = wave[phaseA & phaseMask],
            waveSampleB = wave[phaseB & phaseMask];
          (noiseSampleA += (waveSampleA - noiseSampleA) * pitchRelativefilterA),
            (noiseSampleB +=
              (waveSampleB - noiseSampleB) * pitchRelativefilterB);
          const inputSample = noiseSampleA + noiseSampleB * unisonSign,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phaseA += phaseDeltaA),
            (phaseB += phaseDeltaB),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA / Config.chipNoiseLength),
          (tone.phases[1] = phaseB / Config.chipNoiseLength),
          (tone.phaseDeltas[0] = phaseDeltaA),
          (tone.phaseDeltas[1] = phaseDeltaB),
          (tone.expression = expression),
          (tone.noiseSampleA = noiseSampleA),
          (tone.noiseSampleB = noiseSampleB),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static spectrumSynth(
        synth,
        bufferIndex,
        runLength,
        tone,
        instrumentState
      ) {
        const data = synth.tempMonoInstrumentSampleBuffer,
          wave = instrumentState.wave,
          samplesInPeriod = 128,
          unisonSign =
            tone.specialIntervalExpressionMult * instrumentState.unisonSign;
        1 != instrumentState.unisonVoices ||
          0 != instrumentState.unisonSpread ||
          instrumentState.chord.customInterval ||
          (tone.phases[1] = tone.phases[0]);
        let phaseDeltaA = 128 * tone.phaseDeltas[0],
          phaseDeltaB = 128 * tone.phaseDeltas[1];
        const phaseDeltaScaleA = +tone.phaseDeltaScales[0],
          phaseDeltaScaleB = +tone.phaseDeltaScales[1];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta;
        let noiseSampleA = +tone.noiseSampleA,
          noiseSampleB = +tone.noiseSampleB;
        const filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters;
        let phaseA = (tone.phases[0] % 1) * Config.spectrumNoiseLength,
          phaseB = (tone.phases[1] % 1) * Config.spectrumNoiseLength;
        0 == tone.phases[0] &&
          ((phaseA =
            Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) +
            phaseDeltaA),
          1 != instrumentState.unisonVoices ||
            0 != instrumentState.unisonSpread ||
            instrumentState.chord.customInterval ||
            (phaseB = phaseA)),
          0 != tone.phases[1] ||
            (1 == instrumentState.unisonVoices &&
              0 == instrumentState.unisonSpread &&
              !instrumentState.chord.customInterval) ||
            (phaseB =
              Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) +
              phaseDeltaB);
        const phaseMask = Config.spectrumNoiseLength - 1,
          pitchRelativefilterA = Math.min(1, phaseDeltaA),
          pitchRelativefilterB = Math.min(1, phaseDeltaB),
          stopIndex = bufferIndex + runLength;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          const phaseAInt = 0 | phaseA,
            phaseBInt = 0 | phaseB,
            indexA = phaseAInt & phaseMask,
            indexB = phaseBInt & phaseMask;
          let waveSampleA = wave[indexA],
            waveSampleB = wave[indexB];
          const phaseRatioA = phaseA - phaseAInt,
            phaseRatioB = phaseB - phaseBInt;
          (waveSampleA += (wave[indexA + 1] - waveSampleA) * phaseRatioA),
            (waveSampleB += (wave[indexB + 1] - waveSampleB) * phaseRatioB),
            (noiseSampleA +=
              (waveSampleA - noiseSampleA) * pitchRelativefilterA),
            (noiseSampleB +=
              (waveSampleB - noiseSampleB) * pitchRelativefilterB);
          const inputSample = noiseSampleA + noiseSampleB * unisonSign,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phaseA += phaseDeltaA),
            (phaseB += phaseDeltaB),
            (phaseDeltaA *= phaseDeltaScaleA),
            (phaseDeltaB *= phaseDeltaScaleB);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phaseA / Config.spectrumNoiseLength),
          (tone.phases[1] = phaseB / Config.spectrumNoiseLength),
          (tone.phaseDeltas[0] = phaseDeltaA / 128),
          (tone.phaseDeltas[1] = phaseDeltaB / 128),
          (tone.expression = expression),
          (tone.noiseSampleA = noiseSampleA),
          (tone.noiseSampleB = noiseSampleB),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static drumsetSynth(
        synth,
        bufferIndex,
        runLength,
        tone,
        instrumentState
      ) {
        const data = synth.tempMonoInstrumentSampleBuffer;
        let wave = instrumentState.getDrumsetWave(tone.drumsetPitch);
        const referenceDelta = InstrumentState.drumsetIndexReferenceDelta(
          tone.drumsetPitch
        );
        let phaseDelta = tone.phaseDeltas[0] / referenceDelta;
        const phaseDeltaScale = +tone.phaseDeltaScales[0];
        let expression = +tone.expression;
        const expressionDelta = +tone.expressionDelta,
          filters = tone.noteFilters,
          filterCount = 0 | tone.noteFilterCount;
        let initialFilterInput1 = +tone.initialNoteFilterInput1,
          initialFilterInput2 = +tone.initialNoteFilterInput2;
        const applyFilters = Synth.applyFilters;
        let phase = (tone.phases[0] % 1) * Config.spectrumNoiseLength;
        0 == tone.phases[0] &&
          (phase =
            Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) +
            phaseDelta);
        const phaseMask = Config.spectrumNoiseLength - 1,
          stopIndex = bufferIndex + runLength;
        for (
          let sampleIndex = bufferIndex;
          sampleIndex < stopIndex;
          sampleIndex++
        ) {
          const phaseInt = 0 | phase,
            index = phaseInt & phaseMask;
          let noiseSample = wave[index];
          const phaseRatio = phase - phaseInt;
          noiseSample += (wave[index + 1] - noiseSample) * phaseRatio;
          const inputSample = noiseSample,
            sample = applyFilters(
              inputSample,
              initialFilterInput1,
              initialFilterInput2,
              filterCount,
              filters
            );
          (initialFilterInput2 = initialFilterInput1),
            (initialFilterInput1 = inputSample),
            (phase += phaseDelta),
            (phaseDelta *= phaseDeltaScale);
          const output = sample * expression;
          (expression += expressionDelta), (data[sampleIndex] += output);
        }
        (tone.phases[0] = phase / Config.spectrumNoiseLength),
          (tone.phaseDeltas[0] = phaseDelta * referenceDelta),
          (tone.expression = expression),
          synth.sanitizeFilters(filters),
          (tone.initialNoteFilterInput1 = initialFilterInput1),
          (tone.initialNoteFilterInput2 = initialFilterInput2);
      }
      static modSynth(
        synth,
        stereoBufferIndex,
        roundedSamplesPerTick,
        tone,
        instrument
      ) {
        if (!synth.song) return;
        let mod = Config.modCount - 1 - tone.pitches[0];
        if (instrument.invalidModulators[mod]) return;
        let setting = instrument.modulators[mod],
          usedInstruments = [];
        if (Config.modulators[instrument.modulators[mod]].forSong)
          usedInstruments.push(0);
        else if (
          instrument.modInstruments[mod] ==
          synth.song.channels[instrument.modChannels[mod]].instruments.length
        )
          for (
            let i = 0;
            i <
            synth.song.channels[instrument.modChannels[mod]].instruments.length;
            i++
          )
            usedInstruments.push(i);
        else
          instrument.modInstruments[mod] >
          synth.song.channels[instrument.modChannels[mod]].instruments.length
            ? null !=
                synth.song.getPattern(instrument.modChannels[mod], synth.bar) &&
              (usedInstruments = synth.song.getPattern(
                instrument.modChannels[mod],
                synth.bar
              ).instruments)
            : usedInstruments.push(instrument.modInstruments[mod]);
        for (
          let instrumentIndex = 0;
          instrumentIndex < usedInstruments.length;
          instrumentIndex++
        ) {
          synth.setModValue(
            tone.expression,
            tone.expression + tone.expressionDelta,
            instrument.modChannels[mod],
            usedInstruments[instrumentIndex],
            setting
          );
          for (let i = 0; i < synth.heldMods.length; i++)
            Config.modulators[instrument.modulators[mod]].forSong
              ? synth.heldMods[i].setting == setting &&
                synth.setModValue(
                  synth.heldMods[i].volume,
                  synth.heldMods[i].volume,
                  instrument.modChannels[mod],
                  usedInstruments[instrumentIndex],
                  setting
                )
              : synth.heldMods[i].channelIndex == instrument.modChannels[mod] &&
                synth.heldMods[i].instrumentIndex ==
                  usedInstruments[instrumentIndex] &&
                synth.heldMods[i].setting == setting &&
                synth.setModValue(
                  synth.heldMods[i].volume,
                  synth.heldMods[i].volume,
                  instrument.modChannels[mod],
                  usedInstruments[instrumentIndex],
                  setting
                );
          if (
            setting == Config.modulators.dictionary["reset arp"].index &&
            0 == synth.tick &&
            tone.noteStartPart == synth.beat * Config.partsPerBeat + synth.part
          )
            synth.channels[instrument.modChannels[mod]].instruments[
              usedInstruments[instrumentIndex]
            ].arpTime = 0;
          else if (setting == Config.modulators.dictionary["next bar"].index)
            synth.wantToSkip = !0;
          else if (setting == Config.modulators.dictionary["eq filter"].index) {
            const tgtInstrument =
              synth.song.channels[instrument.modChannels[mod]].instruments[
                usedInstruments[instrumentIndex]
              ];
            if (!tgtInstrument.eqFilterType) {
              let dotTarget = 0 | instrument.modFilterTypes[mod];
              if (0 == dotTarget) {
                let pinIdx = 0;
                const currentPart =
                  synth.getTicksIntoBar() / Config.ticksPerPart;
                for (
                  ;
                  tone.note.start + tone.note.pins[pinIdx].time <= currentPart;

                )
                  pinIdx++;
                let lerpEndRatio =
                  (currentPart -
                    tone.note.start +
                    (roundedSamplesPerTick /
                      (synth.getSamplesPerTick() * Config.ticksPerPart)) *
                      Config.ticksPerPart -
                    tone.note.pins[pinIdx - 1].time) /
                  (tone.note.pins[pinIdx].time -
                    tone.note.pins[pinIdx - 1].time);
                null !=
                  tgtInstrument.eqSubFilters[tone.note.pins[pinIdx - 1].size] ||
                null != tgtInstrument.eqSubFilters[tone.note.pins[pinIdx].size]
                  ? (tgtInstrument.tmpEqFilterEnd = FilterSettings.lerpFilters(
                      tgtInstrument.eqSubFilters[
                        tone.note.pins[pinIdx - 1].size
                      ],
                      tgtInstrument.eqSubFilters[tone.note.pins[pinIdx].size],
                      lerpEndRatio
                    ))
                  : (tgtInstrument.tmpEqFilterEnd = tgtInstrument.eqFilter);
              } else {
                for (let i = 0; i < Config.filterMorphCount; i++)
                  tgtInstrument.tmpEqFilterEnd ==
                    tgtInstrument.eqSubFilters[i] &&
                    null != tgtInstrument.tmpEqFilterEnd &&
                    ((tgtInstrument.tmpEqFilterEnd = new FilterSettings()),
                    tgtInstrument.tmpEqFilterEnd.fromJsonObject(
                      tgtInstrument.eqSubFilters[i].toJsonObject()
                    ));
                null == tgtInstrument.tmpEqFilterEnd &&
                  ((tgtInstrument.tmpEqFilterEnd = new FilterSettings()),
                  tgtInstrument.tmpEqFilterEnd.fromJsonObject(
                    tgtInstrument.eqFilter.toJsonObject()
                  )),
                  tgtInstrument.tmpEqFilterEnd.controlPointCount >
                    Math.floor((dotTarget - 1) / 2) &&
                    (dotTarget % 2
                      ? (tgtInstrument.tmpEqFilterEnd.controlPoints[
                          Math.floor((dotTarget - 1) / 2)
                        ].freq = tone.expression + tone.expressionDelta)
                      : (tgtInstrument.tmpEqFilterEnd.controlPoints[
                          Math.floor((dotTarget - 1) / 2)
                        ].gain = tone.expression + tone.expressionDelta));
              }
            }
          } else if (
            setting == Config.modulators.dictionary["note filter"].index
          ) {
            const tgtInstrument =
              synth.song.channels[instrument.modChannels[mod]].instruments[
                usedInstruments[instrumentIndex]
              ];
            if (!tgtInstrument.noteFilterType) {
              let dotTarget = 0 | instrument.modFilterTypes[mod];
              if (0 == dotTarget) {
                let pinIdx = 0;
                const currentPart =
                  synth.getTicksIntoBar() / Config.ticksPerPart;
                for (
                  ;
                  tone.note.start + tone.note.pins[pinIdx].time <= currentPart;

                )
                  pinIdx++;
                let lerpEndRatio =
                  (currentPart -
                    tone.note.start +
                    (roundedSamplesPerTick /
                      (synth.getSamplesPerTick() * Config.ticksPerPart)) *
                      Config.ticksPerPart -
                    tone.note.pins[pinIdx - 1].time) /
                  (tone.note.pins[pinIdx].time -
                    tone.note.pins[pinIdx - 1].time);
                null !=
                  tgtInstrument.noteSubFilters[
                    tone.note.pins[pinIdx - 1].size
                  ] ||
                null !=
                  tgtInstrument.noteSubFilters[tone.note.pins[pinIdx].size]
                  ? (tgtInstrument.tmpNoteFilterEnd =
                      FilterSettings.lerpFilters(
                        tgtInstrument.noteSubFilters[
                          tone.note.pins[pinIdx - 1].size
                        ],
                        tgtInstrument.noteSubFilters[
                          tone.note.pins[pinIdx].size
                        ],
                        lerpEndRatio
                      ))
                  : (tgtInstrument.tmpNoteFilterEnd = tgtInstrument.noteFilter);
              } else {
                for (let i = 0; i < Config.filterMorphCount; i++)
                  tgtInstrument.tmpNoteFilterEnd ==
                    tgtInstrument.noteSubFilters[i] &&
                    null != tgtInstrument.tmpNoteFilterEnd &&
                    ((tgtInstrument.tmpNoteFilterEnd = new FilterSettings()),
                    tgtInstrument.tmpNoteFilterEnd.fromJsonObject(
                      tgtInstrument.noteSubFilters[i].toJsonObject()
                    ));
                null == tgtInstrument.tmpNoteFilterEnd &&
                  ((tgtInstrument.tmpNoteFilterEnd = new FilterSettings()),
                  tgtInstrument.tmpNoteFilterEnd.fromJsonObject(
                    tgtInstrument.noteFilter.toJsonObject()
                  )),
                  tgtInstrument.tmpNoteFilterEnd.controlPointCount >
                    Math.floor((dotTarget - 1) / 2) &&
                    (dotTarget % 2
                      ? (tgtInstrument.tmpNoteFilterEnd.controlPoints[
                          Math.floor((dotTarget - 1) / 2)
                        ].freq = tone.expression + tone.expressionDelta)
                      : (tgtInstrument.tmpNoteFilterEnd.controlPoints[
                          Math.floor((dotTarget - 1) / 2)
                        ].gain = tone.expression + tone.expressionDelta));
              }
            }
          }
        }
      }
      static findRandomZeroCrossing(wave, waveLength) {
        let phase = Math.random() * waveLength;
        const phaseMask = waveLength - 1;
        let indexPrev = phase & phaseMask,
          wavePrev = wave[indexPrev];
        const stride = 16;
        for (
          let attemptsRemaining = 128;
          attemptsRemaining > 0;
          attemptsRemaining--
        ) {
          const indexNext = (indexPrev + 16) & phaseMask,
            waveNext = wave[indexNext];
          if (wavePrev * waveNext <= 0) {
            for (let i = 0; i < 16; i++) {
              const innerIndexNext = (indexPrev + 1) & phaseMask,
                innerWaveNext = wave[innerIndexNext];
              if (wavePrev * innerWaveNext <= 0) {
                const slope = innerWaveNext - wavePrev;
                (phase = indexPrev),
                  Math.abs(slope) > 1e-8 && (phase += -wavePrev / slope),
                  (phase = Math.max(0, phase) % waveLength);
                break;
              }
              (indexPrev = innerIndexNext), (wavePrev = innerWaveNext);
            }
            break;
          }
          (indexPrev = indexNext), (wavePrev = waveNext);
        }
        return phase;
      }
      static instrumentVolumeToVolumeMult(instrumentVolume) {
        return instrumentVolume == -Config.volumeRange / 2
          ? 0
          : Math.pow(2, Config.volumeLogScale * instrumentVolume);
      }
      static volumeMultToInstrumentVolume(volumeMult) {
        return volumeMult <= 0
          ? -Config.volumeRange / 2
          : Math.min(
              Config.volumeRange,
              Math.log(volumeMult) / Math.LN2 / Config.volumeLogScale
            );
      }
      static noteSizeToVolumeMult(size) {
        return Math.pow(Math.max(0, size) / Config.noteSizeMax, 1.5);
      }
      static volumeMultToNoteSize(volumeMult) {
        return Math.pow(Math.max(0, volumeMult), 1 / 1.5) * Config.noteSizeMax;
      }
      static fadeInSettingToSeconds(setting) {
        return 0.0125 * (0.95 * setting + 0.05 * setting * setting);
      }
      static secondsToFadeInSetting(seconds) {
        return clamp(
          0,
          Config.fadeInRange,
          Math.round(
            (-0.95 + Math.sqrt(0.9025 + (0.2 * seconds) / 0.0125)) / 0.1
          )
        );
      }
      static fadeOutSettingToTicks(setting) {
        return Config.fadeOutTicks[setting];
      }
      static ticksToFadeOutSetting(ticks) {
        let lower = Config.fadeOutTicks[0];
        if (ticks <= lower) return 0;
        for (let i = 1; i < Config.fadeOutTicks.length; i++) {
          let upper = Config.fadeOutTicks[i];
          if (ticks <= upper) return ticks < (lower + upper) / 2 ? i - 1 : i;
          lower = upper;
        }
        return Config.fadeOutTicks.length - 1;
      }
      static detuneToCents(detune) {
        return detune - Config.detuneCenter;
      }
      static centsToDetune(cents) {
        return cents + Config.detuneCenter;
      }
      static getOperatorWave(waveform, pulseWidth) {
        return 2 != waveform
          ? Config.operatorWaves[waveform]
          : Config.pwmOperatorWaves[pulseWidth];
      }
      getSamplesPerTick() {
        if (null == this.song) return 0;
        let beatsPerMinute = this.song.getBeatsPerMinute();
        return (
          this.isModActive(Config.modulators.dictionary.tempo.index) &&
            (beatsPerMinute = this.getModValue(
              Config.modulators.dictionary.tempo.index
            )),
          this.getSamplesPerTickSpecificBPM(beatsPerMinute)
        );
      }
      getSamplesPerTickSpecificBPM(beatsPerMinute) {
        const beatsPerSecond = beatsPerMinute / 60,
          partsPerSecond = Config.partsPerBeat * beatsPerSecond,
          tickPerSecond = Config.ticksPerPart * partsPerSecond;
        return this.samplesPerSecond / tickPerSecond;
      }
      static fittingPowerOfTwo(x) {
        return 1 << (32 - Math.clz32(Math.ceil(x) - 1));
      }
      sanitizeFilters(filters) {
        let reset = !1;
        for (const filter of filters) {
          const output1 = Math.abs(filter.output1),
            output2 = Math.abs(filter.output2);
          if (!(output1 < 100 && output2 < 100)) {
            reset = !0;
            break;
          }
          output1 < 1e-24 && (filter.output1 = 0),
            output2 < 1e-24 && (filter.output2 = 0);
        }
        if (reset)
          for (const filter of filters)
            (filter.output1 = 0), (filter.output2 = 0);
      }
      static sanitizeDelayLine(delayLine, lastIndex, mask) {
        for (;;) {
          const index = --lastIndex & mask,
            sample = Math.abs(delayLine[index]);
          if (Number.isFinite(sample) && (0 == sample || sample >= 1e-24))
            break;
          delayLine[index] = 0;
        }
      }
      static applyFilters(sample, input1, input2, filterCount, filters) {
        for (let i = 0; i < filterCount; i++) {
          const filter = filters[i],
            output1 = filter.output1,
            output2 = filter.output2,
            a1 = filter.a1,
            a2 = filter.a2,
            b0 = filter.b0,
            b1 = filter.b1,
            b2 = filter.b2;
          (sample =
            b0 * sample +
            b1 * input1 +
            b2 * input2 -
            a1 * output1 -
            a2 * output2),
            (filter.a1 = a1 + filter.a1Delta),
            (filter.a2 = a2 + filter.a2Delta),
            filter.useMultiplicativeInputCoefficients
              ? ((filter.b0 = b0 * filter.b0Delta),
                (filter.b1 = b1 * filter.b1Delta),
                (filter.b2 = b2 * filter.b2Delta))
              : ((filter.b0 = b0 + filter.b0Delta),
                (filter.b1 = b1 + filter.b1Delta),
                (filter.b2 = b2 + filter.b2Delta)),
            (filter.output2 = output1),
            (filter.output1 = sample),
            (input2 = output2),
            (input1 = output1);
        }
        return sample;
      }
    }
    return (
      (Synth.tempFilterStartCoefficients = new FilterCoefficients()),
      (Synth.tempFilterEndCoefficients = new FilterCoefficients()),
      (Synth.fmSynthFunctionCache = {}),
      (Synth.fm6SynthFunctionCache = {}),
      (Synth.effectsFunctionCache = Array(128).fill(void 0)),
      (Synth.pickedStringFunctionCache = Array(3).fill(void 0)),
      (Synth.fmSourceTemplate = (
        "\n\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\tconst sineWave = Config.sineWave;\n\t\t\t\n\t\t// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.\n\t\tlet operator#Phase       = +((tone.phases[#] % 1) + 1000) * " +
        Config.sineWaveLength +
        ";\n\t\tlet operator#PhaseDelta  = +tone.phaseDeltas[#] * " +
        Config.sineWaveLength +
        ";\n\t\tlet operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];\n\t\tlet operator#OutputMult  = +tone.operatorExpressions[#];\n\t\tconst operator#OutputDelta = +tone.operatorExpressionDeltas[#];\n\t\tlet operator#Output      = +tone.feedbackOutputs[#];\n        const operator#Wave      = tone.operatorWaves[#].samples;\n\t\tlet feedbackMult         = +tone.feedbackMult;\n\t\tconst feedbackDelta        = +tone.feedbackDelta;\n        let expression = +tone.expression;\n\t\tconst expressionDelta = +tone.expressionDelta;\n\t\t\n\t\tconst filters = tone.noteFilters;\n\t\tconst filterCount = tone.noteFilterCount|0;\n\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\tconst applyFilters = Synth.applyFilters;\n\t\t\n\t\tconst stopIndex = bufferIndex + roundedSamplesPerTick;\n\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t// INSERT OPERATOR COMPUTATION HERE\n\t\t\t\tconst fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS\n\t\t\t\t\n\t\t\tconst inputSample = fmOutput;\n\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\t\n\t\t\t\tfeedbackMult += feedbackDelta;\n\t\t\t\toperator#OutputMult += operator#OutputDelta;\n\t\t\t\toperator#Phase += operator#PhaseDelta;\n\t\t\toperator#PhaseDelta *= operator#PhaseDeltaScale;\n\t\t\t\n\t\t\tconst output = sample * expression;\n\t\t\texpression += expressionDelta;\n\n\t\t\tdata[sampleIndex] += output;\n\t\t\t}\n\t\t\t\n\t\t\ttone.phases[#] = operator#Phase / " +
        Config.sineWaveLength +
        ";\n\t\t\ttone.phaseDeltas[#] = operator#PhaseDelta / " +
        Config.sineWaveLength +
        ";\n\t\t\ttone.operatorExpressions[#] = operator#OutputMult;\n\t\t    tone.feedbackOutputs[#] = operator#Output;\n\t\t    tone.feedbackMult = feedbackMult;\n\t\t    tone.expression = expression;\n\t\t\t\n\t\tsynth.sanitizeFilters(filters);\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\n\t\t"
      ).split("\n")),
      (Synth.operatorSourceTemplate = (
        "\n\t\t\t\tconst operator#PhaseMix = operator#Phase/* + operator@Scaled*/;\n\t\t\t\tconst operator#PhaseInt = operator#PhaseMix|0;\n\t\t\t\tconst operator#Index    = operator#PhaseInt & " +
        Config.sineWaveMask +
        ";\n                const operator#Sample   = operator#Wave[operator#Index];\n                operator#Output         = operator#Sample + (operator#Wave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);\n\t\t\t\tconst operator#Scaled   = operator#OutputMult * operator#Output;\n\t\t"
      ).split("\n")),
      (exports.Channel = Channel),
      (exports.Config = Config),
      (exports.CustomAlgorithm = CustomAlgorithm),
      (exports.CustomFeedBack = CustomFeedBack),
      (exports.EnvelopeSettings = EnvelopeSettings),
      (exports.FilterControlPoint = FilterControlPoint),
      (exports.FilterSettings = FilterSettings),
      (exports.HarmonicsWave = HarmonicsWave),
      (exports.Instrument = Instrument),
      (exports.Note = Note),
      (exports.Operator = Operator),
      (exports.Pattern = Pattern),
      (exports.Song = Song),
      (exports.SpectrumWave = SpectrumWave),
      (exports.Synth = Synth),
      (exports.clamp = clamp),
      (exports.makeNotePin = makeNotePin),
      (exports.parseFloatWithDefault = parseFloatWithDefault),
      (exports.parseIntWithDefault = parseIntWithDefault),
      Object.defineProperty(exports, "__esModule", { value: !0 }),
      exports
    );
  })({});

  const ubIcon =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsEAAA7BAbiRa+0AACNDSURBVHhe7Z0JfFTV2cbfmYQkJCBLXJAlYSkuhF1WreD2LUqrWHfrWrGtv36l2lrFhUWoCrQK2Kqt2n7WpYpgxbq2VQSsO4iyqp8Ju2gBRYGQbTLf+5x73+TMnZnMPrk3cx5+L+fOnTt3Oef5nzWZkJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFR25HPTo3coXjKI2inRmmQ306Nsqzf+/8U/LTduuCn/jODD/pKYWqUBQBAGinwnjOMjLyl+/0PBrcUbAsGi4IcdcFg/sXBYF5ZcJu/IviArw9AaKdFgbadz5FnhxMIIyN36/f+hzTjS1Sz+S/i6MlRwTEwuJVBeNACoYMdJXa05yjiECgECB0GowRlMi3DgvFPz/8vKvP3tPfoOkhUfxWnr3N0Unss+YhRob8Hq+nq4KZS3gEgGjkCdqoH3kNAztQohgwAGVLLxhdFA0AkIBxgEDb34B0NHIBAUh0IAUECMiDEkAEgzYrP+KIaBuAHnEYDQOSj7QzCyxYIvXhHPQcgkIgEAmRAiCEDQJqEwe2E/NOplx8VdbyKFwBRCAi9eUcdh8AgLYNpERKQASBFJWP8Rvbh5sA2+lfgTSoMPkRjfDupzOdLoDAsEF7iMcIPg5vKeYcOgmkREpABIElZxv9vNn48XR1Ljfxvc2A7LQ+8Q+81fsx76qgLraA82k8VviCD0EC9fAE1rROfQkAwLUISMgAkKBj/DDZ+fH18S5bxt9GKwHv0buNG9bqOqmkrfUzFtJb6Uwm1pyJl/AoGYDSDUJY8CKZFSEAGgDiV2ODWEoy+iY3/Ohv/vcaP2IkBdmU1bWLjL6Nn7aMsfYd60lHUlTEoVJP7AxmAUUmAoE2fmhYhDhkAYig54wfZ+FvY+CtpJXd16tl3MP5mNv5rtvH70zAaxP9K6AP6kP6P1mBKlAUQ+nPHCC0CVroGJNkiaCCYFqEFGQCiKBnjB/lfVWArd3XepfcbP2HXifE/YeMvUcf0pyFs+5F0JJWxyfOpE73Cx31J2+gAraTPaR3tU8fpIGDZ91gbhHJO4y+0kHUE0yJEkAHAoVSMv5yNv5qNjxq/lg29RRnfqvGPYuMPVMbvxZ2c9vx+Le2h7dSR3qFuXAyFbPMa/tx2BmAVg7DWAUKx3SIcwwBgsJwoCNr0qWkRNBkAbCUznQnjb2LjL1M1/sfspEa29X5V40sf/ygaysYf0WT8Orb5F7SD1rPNN3CdDw2nztwhOoK6Uwe2eR53hiwQ3ucj19A36hgdBIwR0CKMtbtGSYJgWgRWzgOQyjz+ssA7tIqNH+A9dVzjb6KP2Ph/U8fEY3yn4gFhAvXgc5cyCIVqTIAxQrIgmFmjHAYg9Xn8j/hVMMz46OMPplHcrekZYvwNbOP19J46JpaOYxCGOkDYwSBgjCBdI4BwNIPQ3gYB06dmHSFx5RwA6ZrHx+C2KobxP2fbbqTVbPx31TGJygLhcAahowbCfsZoZ9NgORIIZh0hfuUMAJmax+/Pth9Mox3G324bP74aP5YAwhAGoQeDgFUCDJbRIrznmDUy6wiJq80DkLl5/ME0iGt8q49fxE6pU8bf0EIfP1VZYwQLhAK2eS3f1za7axRp+tSsI8RWmwUg8/P4zcb/go2/jo2/MUPGd2o4dWIQujEIHeICwawjRFebAyBb8/gyuM2m8Z0axiAM10Aw6wiJq80A0Jrz+K0ts46QvDwPgJvm8aG8vDwKBOCFcPn9fmpshDeiK55jfD4fBdmITpl1hMTlWQDcPI8/f/4DdOaZ/8FbQWXoLZu30hknXchX+qxFg8t7JWzhF5c9SeW9yxRM2L979156etHzNHvuVPvo6CCYdYT45TkAvDCPv3HjRjrmmGPsV5beeftdOnXs2QqClgTzv/rWMzR6zCh7T7Pq6hpo3dqP6KmFz9CcX0+z98YCwawjtCTPAOClefz169fTgAED7FfNWrH8dRp/0jj7VWQtX7aCxo0/0X4VWQLCQgZhbggI7KQIVjLrCNHlegC8OI8fDYAtW7ZQ797wRXRt3ryZystRicYWQFi7diO3CEtCQFClGsFKZh0hXK4FwMvz+NEAqKqqon79+tmvIquyspL69u1rv2rW3r371TigX78eqsujS4GwZiMtempJSNcomsw6QrNcB0BbmMfPBACVlTvo3nv/TiNGlNPxxw/gVqJbRBDWMAhPL3o2ZLAcTWYdwUUAtKV5/EwAsGnTTrrvvpcpL8+nZoUGDuzRIghoERYvZhDm6CDguHAv5fI6QqsD4LZ5/HQoEwBs3ryT7r//H1RYmKcGuvX1bDwuvUGDerYMAg+WFy9aEgJCtFmjXFxHaDUA3DyPn6oy0wXaRgvmP0ddS7uwefnJ2UA6CIMH96SxYwdQWVk3biHCQVDTpxgjmHWEEGUdAC/M46eqTACwYcN6qqg4mS65+Crq2etbVFhU3AQCBJPD0IMH92IQjmUQjlBdJV1NIJh1hCZlDQAvzeOnqswAsIEBqFDbAwccT0OHjaOePQFCe2VeMXBtbYNqAYYM6UVjxrQMgllHyAIAXpzHT1WZBkA08FgGYXg4CDAxTJ6X51djhDFjjuExwpERu0ZtaB1Bv+MIdx9ZGQPAy/P4qSpbAIgAwrDh46lHz34RQcjPx6yRBULv3keqLo8uBYKb1xF4nHd1Y9isUSQQkEICQEwQ0g7A2b4Lg/fkzaWeeb3iPrsY32s/jx9N2QZAFB2EIJs8oECoqGh5+nSNG9cRAn4GrJHKaH1/fgUIBAQEIIgFQlSlHYBhh8wM3t15Ko34mqgDvu0PV4hyFRi/Lfw8vlOtBYBo0IAT1Bihe8++VKQGy80gYNbIE+sI6C/B3nj3cvb3FdU065UdNO32hsG8s4YDENRy6CBEGiNAUUGIYs3k5e80I9jYYzpdxrdzaTXRaH7+jpyqB7Kv5vZ5/FTV2gCILBBOZBD6MQglDED49Knr1hFAB6wtxr8cJuLWpLiGbptZSzOmB/CTgqhaAQHSSCAgBAQoewB0YgB6dJ/OjSDRl/YzfJ9vcyxahJpG2tS4XRnfzfP4qcotAIgAwhAGwRosN0+f6iC4YR1hVDDApR6gdqg9r2Tjj+RjS+Bt3I+PbrutmmbMCEzkF6hSYX5JETgQUAACfXyAG5QIU0YA6M4AQDi5gPAjvp3BO16h9/e/xn3BAr7Lg1TFvXc3zuOnKrcBIIoGAgSTw9Ctso7gK6X8YCH16NtAF036ig77KWpLVOyW8UU2AJN484Ad+7VtAQIg4MORIAhTugHwMQCNAoCuXRy7P3uQxnz9AdcL+2g5PapQPVoNbp3Gb915/FTlVgBEblhH2M7efZVLepvqGvno7lN60E9O3UsFg9jT38WfRw63pg3Ajbwp5keAJIS8lhbB2RJAYXcX+mQZ1GEcA/nh9/O9vM3DXNxdPzqFxtNEHt3348f101aqpKXcIiymBzxrfi9o3YY36bHHZ9Pzf/sTVX66lupqa5TJUZMXFuZTfn4erV69lR544J9s8mW0adNn1NjY7J2CgnwaftxAmvWrm2jlyjV0wy9nqv1N5nd4dxXtpT/RJ/QCl+8m3uYrUTlDcdPIPnTXGYV8RJA6H7adCtqzfwMYBLRYL3flwN9ORmC7M8chHKAGf0wcJ5Q/JI4TSURU1gAQ4YIl6t6AZRfuEx5gHD5X8/yL6Q+uH+C2Ja3b2AxC1afrmkBACwAQsJD2wQdb6aGHXmEQXlMg6F0dgHDccYMsEN5bQzfaIETubBCP4vbSHxmE+7nzO+y83XTNhZ/S6H7osdjwRPmcQzA7/qSmHtiHv6ZfzCEAgCTYrUWPpxOAFrGNJPyoA1qEd7hBxOyOUesIIDz6+J1RQUAqIDzxxFL1k6lhIIwYRDMZhPcYhCk3zLLfiaxd9BV3raqIig5QQDon8asjh9P82AcA9BZAAGixFUgnAEkJN2D9ebhw+bkGiq6EeTOKIQHhhef+V4FQW3vQBsHfBMKaNdtU1ygaCCMYhNtmTVEtwpQbm0HIz7dafZH6Yoz4anyniuyA2VHjI7At5i/gwMV0AKIq3QCkzZXI7EauHi679Eo6//wf0sknX0innXYxjTvxe3RIe3T9kss9o9hau+ENBcKLzz3MIKy1QchTIMDk6BqtWbOd/vCHf7TYItw2k0FYuZau//nN1NCA8WhaBJPrAIj5sQ/ml/6/DCYkoDB/phuAtAhfLoVB1+T/uY5+/Zu5bPyJNHbsBDrhhAk0/qSzaeTY/7SPNMqkLBBmKxAqP11jd40Ago9NnqcGywLCk09aIDgHy8fxYPniS86196RFMDYMjoDZJWRfXF0fkSsBwJdBXTv5FzRj5jQ6/PBDqa6unmsYHjFwu4kCKGqP7p5RtgQQMFhG1ygSCO3a5dGHH25TIGCw7AQh1jfdJSgdAIlIAAgEUFQIXAkAdMmlF1GXLp256bRWKnXpza1R9iQgPP8cpk8FBGv6FLU9QMBgWUDYuXO3/cm0Smp1Mbke8p4eIn27SfiQOxXxdo3coGjrCKipZB3hjTcqGYAv7U+kVbq5Ebrx9W2Rvh0m9wJg5Ho51xEa6utUa4AWu6goT32DRYYlF0Cqb8ctA4BRypLp04MH9ysAsqRIF9L3xXUjBgAjLypho0eTAcAop2UAMMppGQCMcloGAKOclgHAKKdlADDKaRkAjHJaBgCjnJYBwCinZQAwymkZAIxyWgYAo5QlP/924EBdyC/CeEEGAKOUZH0rHL60agZdcsnJ1L59Ozp4sN4zIBgAjJKWZf4g3XrrrXT99b+kceOG0zXXnEETJgyl4uICT0BgADBKSvgNMDH/lClT2PD4ggaizp070EknDaPrrjuTunXDt3e4WwYAo4QF8+MX3cX8JSXhX1JQWtqJjjzyULWdxV+SSVgGAKOEZH1ljWX+m266KaL5de37Zh89vdj681ZulAHAKG7B/PjKGme3J5pg/jtun0N33Dkrxrf8tZ4MAEZxCd0e3fzx1Py3s/lnz71dTZPiW/7cKAOAUUzF0+fXJeafw+bHb+y6+WucDABGLQoD2ET7/Lr53f4VrgYAo6jS5/kT6fN7xfyQAcAoopzz/PHU/DC/9Pm98uXdBgCjMCXT528yPzvKzX1+pwwARiFKZp4/xPzunOyJKgOAUZOSnef3qvkhA4CRUqrz/F40P2QAMGLzW92e6dOn0803x+72fGOb3wvz/LFkADBi8wdo8uRrVbRrV0S1tXVNgb/Oo2v//gM0c8btyvxemu2JJgOAkVJl5U56+OF/0G9/+yzde+9zKn73OyuqqnbYR7U9GQCMVP//hRcW0mOPPaz+rNFXXx2kPXsO0JdfHqBdu/bx/uXqj2RDHTqU0LQZt9CNN9xidX3QCnhYBgAj1f+Hk1evfon+9a/nqKGhlrtC1p9Dxd/9qqlpoEceWdYEwSGHdKRbbrlRQYAukOoKeVQGACNbQTayj9566zlavvzZpj+SDeXn+/l1KAQdbQim2C0BpkG9KAOAUZPwow8CwYoV8UFws0DAjYgXITAAGIUIEKA79OabVktQU9O2ITAAGEWQBYG0BJEgePTRFiDw0JjAAGAURYCAokKAgTEgqKqKAIHFjydkADCKqWhjAkDw2GPhLYHMDnkBAgOAURyKPjCWlsA5O+QVCAwARnHIcrIMjCNBEGmK1AvrBAYAoziV2jqB+VoUI88r2XWCm2+aar4WxahtKJ51Amt2yPoBOkBwzrkT1bYbZQAwSkIWBNGmSKur6+nFF1dSQ0NA7bOgcacMAEZJyjI1IHj9dUBQrbpHkN/va9p2uwwARikL3aENG95j0zfbySP+NwAYpUcNDaG/OeYVGQCM0iKvdHmcMgAY5bQMAEY5LQOAUU7LAGCU0zIAGOW0DABGOS0DgFFOywBglNMyABjltAwARjktTwGAH6utrw/Ql3uq7T3eXYJvC9LzHmWCsnHzjz5HkicAQJ7iFy0aG4M0ZEhPWnDPFLr2Z7fa71kZbjjIniSvJe9RFigTlA3KCGXlFQ48AkCQhg0ro0mTTqPzzhtPo0YNodlzptHbb71PP5ssIKiES8dOjdKvJuNbKfIeZYCyQJmgbFBGKCuvtASeAGDixLF08cWnUJ8+3Zua3cLCdjR6zDCaM3cavcWFcK0Ngv17GkaZkJ23yGvkOfIeZYCygFA2KCOUFcrMC3I9APn5edSz5+FNv3LnFDJ/DBfCnXOm0ltvMgh218go/ULeIo+R18hzMb5TKCuUGcrO7fJECxCPiooKaMxYBmE2g8C103XXTrXfEZm+UfwKzSvkJfIUeYs8Rl63FbkWgGg1fiwpELh2uuNOq5n+eRMIVvttZo2iqzlvrLxC3iEPkZfI02SNn2xZZkOuvbO/PLaYVq1aR3V1DfaexCQg3M6F9/bbq+m6sFkjA4JI8kLyBnmFPEPepWJ8lB3KEGXpVrkSgPz8fPrN3XfQiBGDaPq02bRq5dqUQBg9eijdwc03CjV8+jR3QXAaH3mDPEJeIc9SMj6XGcoOZYiyRJm6US4AIMAN7pf2NuSjhoZms8/mAdeIkYNp+tTZtDINIKAfi0Junj4VEFSSE5JnlWdX05mcJ8ibVI2PMkJZocxQdiK9TCE1PHZBnrcqAD7OhmBhD2rX/VZq32GyvdcqFGfuzJ47lUZypk679c60tAiYwsu5dYQm41upzOOr6cw01PgoG5QRyqpF9T+KVvlOo0BDL8rzt26GtwIAMK71tXnV7Qqpruwqyu8ynsp73kVlZW9RSclP1HthINjJnF9PU7XLVICwKnkQcnIdwX62aPP4iUoZn8sAZYEyQdkoRfN0RX+i8ycQnX48TaI+9OMt36Y3th2m3vK3Ur5nD4BdnC9fN1DQV06Fh3FG+brRv+sfp807ptC+b97gAwLUseMY6tVrng3CT63PSanZiTTfcwHCCAuE91MYLOfSOkK88/ixhLxGnivjcxmgLKCmbqTTzGL8U08gKutOPjRBW7fTQ8++Qzcu+Tcf0I4+LRpLBxvKiBqtr1PMlqKxmoxwLl+nTjMC3btPb97zOSfcxQ/8OEjBb31E+df34vzpQPV9P6Ov971Iu3ZdrQ5t3/5KOvTQq9j4Iygvr5ACgXqqrl5Fe/Y8QQcO3KOOsU5o5S4GcNKHhW785Uw6/4KzaeCgY6igIPkBV01NHX3wwXp6auEzNG/+LHsv1HztWFq/fj0NGDDAftWsqqoq6tevn/0qsiorK6lv3772q2Zt2LCBKioq7FexFHqvmMdH3gwdWpF0NweC8det/UjlTVNtz3KWRZMGsvEHHEXUjWv5Ar5ubS3RTjb8mo1En2y2jjl5DOX1K6dAfke6xF9HV53/IY0cv5ZK+J9Tt91WTTNmBP7Jm6DkIAd+KnIvBwaRIAnBVa2KfRzfcNTZga+nRoTcKHIqXcK5LAB6MABi/MvZVN/nuxlLVM/P1OFjjmeYeXQT+THq+nxGe/e/SLubQPgBg/ADBwjvMwiPMwi/VcfoCgPhhll0/vkT0wbCIi7suzUQoha2ptYCwHlvmMc/L53Gf2oJd5ua+/epGp/6lnMT3JFPxIPiEfsoMG47UXklXZb3FV3JrcJIfkPHwBsA+GcEejROp8BlfIeXEu0fzc9vPaMK3EEe/1fyCYPwVwbhdt7Bj1FXvoP2Vr+kgXAVg3AFFRePpPx8AWE1g/Aog/A7dYwlnNX63nq9MKbcOIvOPW8iDUoDCB9+uIEWPvE0zVvwK3svX7UFELINgPNeMI9/wUXn0JAhA1I2/lo2/uJFS0JmdKI+O7o6A9n4RziMz+egjzdZx8D4fdj4RWwK7oD7h++nduO3Ul7v9fzia8qjQnau9SMUV3BcxgeN5jIu5u2ZDMB0CwD0d2s4AMBXdrgDgEOG3xboctc02jeCn7+DvVO9HSoFAt9KCVoEgDCPd+zmOy3bQV/XvES7/v0jdZQFwuXcIozSWgSA8GcG4T6cypYFQnNqSYFw7lk0aPCxaQHhSQZhfgwQsgWA89ro41+YLuNzbb148bMhxnfmbZMGfIto0NEtG/8UNn5vu8bnYvAPs43fZx2fFj4t5Gj+2SEMTvdbmwxCI0eQ/jmrjm6fFhQA0AIgdAC+4GAXtSIAxadPCRTfP5Vr9GJ1tVgXEBA6cF6VoGuEyn0n5yGD8E3NywzCJHWc1TW6IgyE3bv/zGkkEEI1hbtG55x3Fg1OEwhP/OVpWnCPDgJf1b5spgHQrwVhOvOii9Nj/DVs/KcXsfFjTWVCMP5ANr7q6vCAupZ9FmZ87vv25sEtjM+H+IfuY+Nv04xfxBFtLgbuqONq/lAeNB/B3aO1S3kHuj8CQLQuECDAyQFBdgHgAMb5XRcsrfZ/ZzQPdovVHce6UAgISziv0N1nEOp6c4tQ/XcG4Sp1nDVYvpJBGM0gFDAIDQzAKgbhkbhAwGD5PB4jpNoi1NbW0wer19ETT/w1BAQoWy2AMv5F36OhwwYmPaMDSY2/CH18bXAbVdGMr/fxxfgFbHxm0j+MjX8iG79vPMZHuXErQqUU2NqNGl7Oo8CPPnjNfgPmd7YAOgB6C9BqACDaI0oXLN3hSxQE/g+D5ZJnGYS7eAe6Rn0YhP3cIuySFuEKBgGzRmgRAILMGj3GXaN71TGWbBDsRHSDmjXCGCF1EFYzCAsZhPk2CJkGAPP4F7Dxh6XD+Gs30lMLlzRNZSo58qpJ6ONXyOC2BeP3YeO3s2v849j4397ONT76+KisYxkfXu3Mxu8uxl9mvyEhAKD2jzQGAAAIHQB8dzvsJ+doUiw/JiKcCyEA4EkBQWdE6fzX3vR9d1TyIMBbB/hp1PQpjxFCQJjkmDUCCH+JMmvEOaBlAUC4IF3Tp6vX0x8fepSu+8XVDMCx9jvNSg2AjTTvrgfpqkmXco2fnlmdhQufCTG+M2+alKjx0ccfYdf4vfkYP/wZ2scPFS4Kj3Zi4x9JDS+1o8CPV8P4kNyR1N44UABgR4QBsMcOmB/DCACAkM+HPGEsHyYinAsBvOEkPDEg6MQBCLgjR4eVznvtYd9ZI6m+T0lCIKhZI3SN0DXlx7dAcN86QnV1DeXn+amgMNygqQBQx6ZrCDRScTGyNDmJ8dM9j6+mM9HV4ZL3j0zE+ChduOAQq6vzIpfbNe87jY8UgQPxAQAAQ+sAoAskXR+YH69hfgSOR2QFAEhaAAHgEDtKOQCBShmE6UmD4IF1hEhKBYBU1GT8DM7jqxofg9vyDfwCXZ14jM81/rYjqOGFFo2PkA8gpEaH+WFwaQEEAHmN9xHSYmQVALQCqAKRC5xDKrpwdNUCUHQqnbd0sm8id416JwGCB9YRdGUbAKuPn915/NjGhxe7svEPtY0f1tURk+JgCVgDH4SZMTpGSA0Ps4M46frgJvBaZonwOYScM0TpBADC+WB+AQAjNCzmdeCQrhBAQCgAOLDGUVw6/9Uf+s4awyAkNmvklXUEKFsAKONzbd2a8/ihQmnBu6Vs/MO4q4M+vhrcQnJDSCV044v5UevjJDL7A/Ojnw+zI6Tml+lPLJQh8FmcA+cLe/hYPktUOB8CAMD8cAwGwjA5WgHpDsH4SLEPgCDUoLnrglev9n+XQeiTxPSpy9cRMg0AjO/GeXz0fANbD+fBbX5LxhfTI3Tjw/Q4idT8qNUBgAxyUeNL4IawD10fHIvPybnkOiHKFAAIuARVgowFAAFaAgSMLyEAqJaAQx3fdcHSSW1tHSFTAEiN7/J5/ERrfBhf7/JIzS+DX+kCSY0vQMhx8nmcD+eG5NpNiuWrZCQAwPwItAToDqkangMmF9PrIQCo9QMOBULpgqVXt5V1hC1btlDv3r3tV5G1efNmKi/nrkYcsvr4npjHh+SOkCLE9Ain8aXGRwozoysj5hcABALZlvcEGJwLgfPr1w5RLD8lIzkncgmhtwQCgrQIOhACgB54H8cWls5/bZLX1xFWLH+dxp80zn4VWcuXraBx40+0X0UWjO/BeXykEtGMjxADi+mdxtdThLwvn5Pz4LxifokwZRIApAhpCeAOhICgangOMbkYPhIECKtFmPfa1V5cR3jn7Xfp1LFnc8l9Zu+JrBLqTq++9QyNHjPK3tMsMb5H5/FxsITT+NFqfN38TsPLMbrx8Xk5L64j15Z7CVMs/yQrOS9SBFoC5KK0COgWSdcIOYwQo0eCQALvWS3CPG4RXLiOYA2Wv8Pn6EyNjY18jjzasnkrnXHShcr8+I4c7I8keQ8QvLjsSSrnPnggEFD7d+/ey4Pb50MGt2kxfvbm8eVDYlCpqcXALZkeNb68h+MQuvERcl65llwbkjRMsXyTiuTcSBHSJRIYooEgrYKA4ARC3lPHls7jMYIL1xEiqSXzi+I5Juq13D2Prxs/0RpfN758NpLxsS3X1+8nqmL5JR2SayBFAACkyGUJwAAIAIOAIEZ3AqAH3rPHCK9yi+CGdYRWkDfm8cWwMC+iJdNHqvF14+N8CJxbroWQ60OStqhYPkmX5DpIJZwgAAJpFZJuEdy6jpAReW8eH6mYOpr5IxkfIQDJefXryT3o9xSXYvkj3ZLr6SlyX0JAQJpSi+DWdYS0yJvz+C2ZPpkaX64L6feUkGL5IhPSr4ltCZQG0rS2CK5ZR0iHvD+PH8n8kYyPEIDkvPr15B7kniB9O27F8kOmJdfXU2kNEGlrEdyyjpCU2s48vkSr1fhOtTYAkH4P2JbITIvgknWEuNR25/GdxkcIQHJe/XpyD3JPkL6dtGKVf7Yl96OnmWkRXLKOEFG5MY/fKjW+U7HKvTWk3xO2JTLUIrT2OoKm3JnHb7Ua36lY5d3akvvT08y0CK25jjCAjT8ohvHb/jy+XBfS7ymjcjsAkH6P2JbISIuQtXWEBgYh+D7tGHofBbrxCQr4Ns08vtwTpG9nTLHK122S+9XTjLQIGV9HaD+GfJ3aUeUJ06iusZLoMx6wmnl8SbMmrwEA6feMbQm4AWlaW4SMrSMUXE1dys6hLyoeocDHS4k++lztN/P42VWs8nS75P71VFoDRNpahEytI1jis6GPb+bxs65Y5egF6c+AbYnMtAjpWkfowyDUvUR7jn6KGvt04jvi4Ds28/jZVazy85rkefQ0My1CqusIN/O+0gaqOmcG1RXs4K7OQTOP3wpqawBA+jNhWyJDLUJy6wgdGIT2z9fQ9kNvouC45ZTfu4rv0MzjZ1uxysvrkufT08y0CEmsI/jYV410EW/xICGm8eE1M4+fbrV1ACD9GbEtkZEWIbF1hIN8jACAUzkFP8F3Zh4/U2q5fNqe5Hn1NCMtQnzrCADgYk55dKw+LoJ34Fczj59p5RoAkP7M2JbISIvQ8jqCEwD4B76L+P34ImwjxIgIp/HFvEjF1NHMH8n4CAFIzqtfT+7BeV+eU2h55J7k+fU0Iy1C5HUEHQBcJmQeH38RRZduumjGR5gaPwHlOgCQngfYlshMi6CtIzSy1wJ0Ae9+ho1fIfP4r/AO/Z6gWMY3NX6ScmZ0rkvyQ08z0iIcOn/FpJoJR1C9bzI1vLKNa/wNL/B+/Vq6YDapjXXjI0yNn4IMAOHS8wTbEjAl0rS2CBz4LELOJaBBuJ6YMZLxTY2fopDBRtEl+aOnei2djhZBBwGfl/PhWggxpdTUYvyWTG9q/DglBWsUXXoeiSkR6WoR5H05Xs6D80MwJYwK44qJxfxSw+vmj2R8U+NHkV64RrEl+aWn6WoRAAICn0EIYDAsAsZ3ml/C1PhJygCQuPQ8w7aEGDaRFkFgkG28J+DoAMC8AoAYXSCIZHxT48cpZLBR8pL801NpDRCxWgQYXgAQMBIBwGl8U+MnKANA6tLzENsSYuBYLYK0CghsCwByDgFADC6Gl21T46cgZLJR+iT5qafSGiAitQg6DLJPAEDA0AgxubQEuvFNjZ+kpKCM0ic9T8XEiGgtgrQKAoO8J5+DiaVWl1peQkxvavwkhQw2ypwkf/XU2SI4gZD9OBYhphaj6ylCNz1SSMxuTB9DUjBGmZOex2JqhLQIYng9RUB4X4wtoZteAsdIiIz54xAy2Ch7kvzWU4QOg+yDkOrm1s0u25AzNYpLRP8PCByBQBb5r88AAAAASUVORK5CYII=";
  let songs = []; // use to track currently playing songs for playback control by name

  const makeLabel = (text) => ({
    blockType: "label",
    text: text,
  });
  class Ultrawarp {
    getInfo() {
      return {
        id: "clayultrawarp",
        name: "UltraWarp",
        menuIconURI: ubIcon,
        blockIconURI: ubIcon,
        color1: "#000000",
        color2: "#000000",
        color3: "#808080",
        blocks: [
          {
            opcode: "definedSongs",
            blockType: Scratch.BlockType.REPORTER,
            text: "defined songs",
          },
          {
            opcode: "isPlaying",
            blockType: Scratch.BlockType.REPORTER,
            text: "song [SONGNAME] is playing?",
            arguments: {
              SONGNAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "My Song",
              },
            },
          },
          {
            opcode: "createSong",
            blockType: Scratch.BlockType.COMMAND,
            text: "create song with name [SONGNAME] from data [SONGDATA]",
            arguments: {
              SONGNAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "My Song",
              },
              SONGDATA: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "u5N08demosong100s1...",
              },
            },
          },
          {
            opcode: "destroySong",
            blockType: Scratch.BlockType.COMMAND,
            text: "destroy song [SONGNAME]",
            arguments: {
              SONGNAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "My Song",
              },
            },
          },
          {
            opcode: "playSong",
            blockType: Scratch.BlockType.COMMAND,
            text: "play song [SONGNAME]",
            arguments: {
              SONGNAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "My Song",
              },
            },
          },
          {
            opcode: "pauseSong",
            blockType: Scratch.BlockType.COMMAND,
            text: "pause song [SONGNAME]",
            arguments: {
              SONGNAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "My Song",
              },
            },
          },
          {
            opcode: "jsonToData",
            blockType: Scratch.BlockType.REPORTER,
            text: "convert json [JSONDATA] to song data",
            arguments: {
              JSONDATA: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "[...]",
              },
            },
          },
        ],
      };
    }
    jsonToData(args) {
      try {
        return new beepbox.Song(args.JSONDATA).toBase64String();
      } catch (error) {
        console.error("Failed to convert JSON to data:", error);
        return null; // Or handle the error as appropriate for your application
      }
    }

    createSong(args) {
      try {
        let song = new beepbox.Song(args.SONGDATA);
        if (!songs.find((s) => s.name === args.SONGNAME)) {
          songs.push({
            name: args.SONGNAME,
            song: new beepbox.Synth(song),
          });
        }
      } catch (error) {
        console.error("Failed to create song:", error);
      }
    }

    destroySong(args) {
      try {
        let song = songs.find((s) => s.name === args.SONGNAME);
        if (song) {
          if (song.song.playing) {
            song.song.pause();
          }
          songs = songs.filter((s) => s.name !== args.SONGNAME);
        }
      } catch (error) {
        console.error("Failed to destroy song:", error);
      }
    }

    playSong(args) {
      try {
        let song = songs.find((s) => s.name === args.SONGNAME);
        if (song) {
          let synth = song.song;
          synth.play();
        }
      } catch (error) {
        console.error("Failed to play song:", error);
      }
    }

    pauseSong(args) {
      try {
        let song = songs.find((s) => s.name === args.SONGNAME);
        if (song) {
          let synth = song.song;
          synth.pause();
        }
      } catch (error) {
        console.error("Failed to pause song:", error);
      }
    }

    definedSongs() {
      try {
        return JSON.stringify(songs.map((s) => s.name));
      } catch (error) {
        console.error("Failed to list defined songs:", error);
        return "[]"; // Return an empty array as a string
      }
    }

    isPlaying(args) {
      try {
        let song = songs.find((s) => s.name === args.SONGNAME);
        if (song) {
          return song.song.playing;
        } else {
          return false;
        }
      } catch (error) {
        console.error("Failed to check if song is playing:", error);
        return false;
      }
    }
  }
  Scratch.extensions.register(new Ultrawarp());
})(Scratch);
