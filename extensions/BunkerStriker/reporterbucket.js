/*!
 * Copyright 2023 BunkerStriker
 * Contains code snippets generated by OpenAI's ChatGPT AI model
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function(Scratch) {
  'use strict';
  const menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNDYuNTg0NjQiIGhlaWdodD0iMTQ2LjU4NDY0IiB2aWV3Qm94PSIwLDAsMTQ2LjU4NDY0LDE0Ni41ODQ2NCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE2NC44MDMzNCwtMTA0LjExNjM5KSI+PGcgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aXNQYWludGluZ0xheWVyJnF1b3Q7OnRydWV9IiBmaWxsPSIjYWRkZDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0iI2FkZGQwMCIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBmb250LWZhbWlseT0iJnF1b3Q7TWljcm9zb2Z0IFlhSGVpJnF1b3Q7LCAmcXVvdDvlvq7ova/pm4Xpu5EmcXVvdDssIFNUWGloZWksICZxdW90O+WNjuaWh+e7hum7kSZxdW90OyIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9InN0YXJ0IiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTkyLjQxOTgyLDI0Mi45OTQxKSByb3RhdGUoLTQ1KSBzY2FsZSgwLjkwODI3LDAuOTA4MjcpIiBmb250LXNpemU9IjQwIiB4bWw6c3BhY2U9InByZXNlcnZlIiBmaWxsPSIjYWRkZDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0iI2FkZGQwMCIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBmb250LWZhbWlseT0iJnF1b3Q7TWljcm9zb2Z0IFlhSGVpJnF1b3Q7LCAmcXVvdDvlvq7ova/pm4Xpu5EmcXVvdDssIFNUWGloZWksICZxdW90O+WNjuaWh+e7hum7kSZxdW90OyIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgdGV4dC1hbmNob3I9InN0YXJ0IiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHRzcGFuIHg9IjAiIGR5PSIwIj7Cr1xfKOODhClfL8KvPC90c3Bhbj48L3RleHQ+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NzUuMTk2NjYzMjI0OTAyNjE6NzUuODgzNjA4NjYwODQ5NDYtLT4=';
  const vm = Scratch.vm;
  function isValidList(str) {
    try {
      const parsedList = JSON.parse(str);
      return true;
    } catch (error) {
      return false;
    }
  }
  class ReporterBucketExtension {
    getInfo() {
      return {
        id: 'reportersbucket',
        name: 'Reporter Bucket Extension',
        color1: '#addd00',
        color2: '#8ccc00',
        color3: '#7bbb00',
        menuIconURI: menuIconURI,
        blocks: [
          {
            opcode: 'maxBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'max [ONE] [TWO]',
            arguments: {
              ONE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 1
              },
              TWO: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 2
              }
            }
          },
          {
            opcode: 'minBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'min [ONE] [TWO]',
            arguments: {
              ONE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 1
              },
              TWO: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 2
              }
            }
          },
          '---',
          {
            opcode: 'addStringBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'add [ADDSTRING] to [OGSTRING] at [INDEX] buffer [BUFFER]',
            arguments: {
              ADDSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              },
              OGSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "banana"
              },
              INDEX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
              BUFFER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "#"
              }
            }
          },
          {
            opcode: 'removeBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'remove from [INDEXSTART] to [INDEXEND] in [TEXT]',
            arguments: {
              INDEXSTART: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
              INDEXEND: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              }
            }
          },
          {
            opcode: 'replaceBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'replace [STRING] at [INDEX] in [TEXT] buffer [BUFFER]',
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "scratchers!"
              },
              INDEX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 7
              },
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello World!"
              },
              BUFFER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "#"
              }
            }
          },
          '---',
          {
            opcode: 'prngBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'PRNG [SEED1] [SEED2] [SEED3] [SEED4]',
            arguments: {
              SEED1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 123
              },
              SEED2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              },
              SEED3: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "thing"
              },
              SEED4: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "RBE extension"
              }
            }
          },
          {
            opcode: 'mapBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'map [NUMBER] from [INPUT_MIN] to [INPUT_MAX] -> [OUTPUT_MIN] [OUTPUT_MAX]',
            arguments: {
              NUMBER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 5
              },
              INPUT_MIN: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              INPUT_MAX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 10
              },
              OUTPUT_MIN: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              OUTPUT_MAX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 50
              }
            }
          },
          {
            opcode: 'probabilityBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'probability to get [NUMBER] from [LOWER] to [UPPER] with [ATTEMPT] attempts',
            arguments: {
              NUMBER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 5
              },
              LOWER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              UPPER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 10
              },
              ATTEMPT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 10
              }
            }
          },
          {
            opcode: 'gaussianBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'gaussian probability [N] mean: [MEAN] sd: [SD]',
            arguments: {
              N: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
              MEAN: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              SD: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              }
            }
          },
          {
            opcode: 'gaussianAreaBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'estimate gaussian area from [LOWER] to [UPPER] mean: [MEAN] sd: [SD] quality: [QUALITY]',
            arguments: {
              LOWER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: -1
              },
              UPPER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
              MEAN: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              SD: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
              QUALITY: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1000
              },
            }
          },
          {
            opcode: 'clampBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'clamp [NUMBER] to [LOWER] & [UPPER]',
            arguments: {
              NUMBER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
              LOWER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 5
              },
              UPPER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 10
              }
            }
          },
          '---',
          {
            opcode: 'mathMenuBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: '[MENU]',
            arguments: {
              MENU: {
                type: Scratch.ArgumentType.STRING,
                menu: 'MATHCONSTANTMENU'
              }
            }
          },
          {
            opcode: 'mathReporterBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: '[NUM1] [MENU] [NUM2] [MENU2] [NUM3]',
            arguments: {
              NUM1: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
              MENU: {
                type: Scratch.ArgumentType.STRING,
                menu: 'MATHREPORTERMENU'
              },
              NUM2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
              MENU2: {
                type: Scratch.ArgumentType.STRING,
                menu: 'MATHREPORTERMENU'
              },
              NUM3: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
            }
          },
          {
            opcode: 'ifElseBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'if [BOOL] then [NUM1] else [NUM2]',
            arguments: {
              BOOL: {
                type: Scratch.ArgumentType.BOOLEAN,
              },
              NUM1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              },
              NUM2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "banana"
              }
            }
          },
          {
            opcode: 'tripleJoinBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'join [NUM1] [NUM2] [NUM3]',
            arguments: {
              NUM1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              },
              NUM2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "banana"
              },
              NUM3: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "reporter bucket extension"
              }
            }
          },
          {
            opcode: 'boolBlock',
            blockType: Scratch.BlockType.BOOLEAN,
            text: '[INPUT]',
            arguments: {
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "1"
              }
            }
          },
          {
            opcode: 'reporterBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: '[INPUT]',
            arguments: {
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "thing"
              }
            }
          },
          '---',
          {
            opcode: 'directionBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'direction from [X] [Y] to [X2] [Y2]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              X2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
              Y2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
            }
          },
          {
            opcode: 'distanceBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'distance from [X] [Y] to [X2] [Y2]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 0
              },
              X2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
              Y2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              }
            }
          },
          '---',
          {
            opcode: 'splitBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'split [NUM1] by [NUM2]',
            arguments: {
              NUM1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello scratchers!"
              },
              NUM2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ' '
              },
            }
          },
          {
            opcode: 'joinListBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'join [LIST] with [JOINER]',
            arguments: {
              LIST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["Hello","scratchers!"]'
              },
              JOINER: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ' '
              },
            }
          },
          {
            opcode: 'getItemListBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'get [SPLICER] from [LIST]',
            arguments: {
              LIST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["Hello","world!"]'
              },
              SPLICER: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
            }
          },
          {
            opcode: 'removeListBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'remove [REMOVE] from [LIST]',
            arguments: {
              REMOVE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 1
              },
              LIST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["Hello","world!"]'
              },
            }
          },
          {
            opcode: 'indexOfListBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'index of [INPUT] in [LIST]',
            arguments: {
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello"
              },
              LIST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["Hello","turbowarpers!"]'
              },
            }
          },
          {
            opcode: 'addListBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'add [ADD] in [LIST] at [INDEX]',
            arguments: {
              ADD: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "reporter bucket"
              },
              LIST: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["Hello","extension","users!"]'
              },
              INDEX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
            }
          },
          {
            opcode: 'chunkSplitBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'split [NUM1] in [NUM2]',
            arguments: {
              NUM1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello turbowarpers!"
              },
              NUM2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
            }
          },
          {
            opcode: 'listOrderBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'sort [INPUT] by [MENU]',
            arguments: {
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["orange", "apple", "banana"]'
              },
              MENU: {
                type: Scratch.ArgumentType.STRING,
                menu: 'SORTMENU'
              },
            }
          },
          '---',
          {
            opcode: 'matrixBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'matrix [MATRIX]',
            arguments: {
              MATRIX: {
                type: Scratch.ArgumentType.MATRIX,
                defaultValue: "1000111011101011000110001"
              },
            }
          },
          {
            opcode: 'matrixXYBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'matrix [MATRIX] at [X] [Y]',
            arguments: {
              MATRIX: {
                type: Scratch.ArgumentType.MATRIX,
                defaultValue: "1000111011101011000110001"
              },
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2
              },
            }
          },
          {
            opcode: 'convertBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'convert [INPUT] [DIRECTION] [MENU]',
            arguments: {
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "10"
              },
              MENU: {
                type: Scratch.ArgumentType.STRING,
                menu: 'CONVERTMENU'
              },
              DIRECTION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'CONVERTMENU2'
              },
            }
          },
          {
            opcode: 'waitBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'wait [TIME]s then [INPUT]',
            arguments: {
              TIME: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              },
              INPUT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple"
              },
            }
          },
          {
            opcode: 'colorBlock',
            blockType: Scratch.BlockType.REPORTER,
            text: 'color [COLOR]',
            arguments: {
              COLOR: {
                type: Scratch.ArgumentType.COLOR,
                defaultValue: "#00bfff"
              },
            }
          },
        ],
        menus: {
          MATHCONSTANTMENU: {
            acceptReporters: true,
            items: ['true', 'false', '∞', '−∞', 'NaN', '𝜋', 'φ', 'e', '\\n']
          },
          MATHREPORTERMENU: {
            acceptReporters: true,
            items: ['+', '-','*', '/', '^', '=', '≈', '≠', '<', '≤', '>', '≥']
          },
          CONVERTMENU: {
            acceptReporters: true,
            items: ["base64", "binary", "hexadecimal", "string", "number"]
          },
          CONVERTMENU2: {
            acceptReporters: true,
            items: ["to", "from"]
          },
          SORTMENU: {
            acceptReporters: true,
            items: ['ascending', 'descending', 'reverse']
          },
        }
      };
    }
    maxBlock(args) {
      var oneVar = args.ONE;
      var twoVar = args.TWO;
      if (typeof args.ONE === 'string') {
        oneVar = args.ONE.length;
      }
      if (typeof args.TWO === 'string') {
        twoVar = args.TWO.length;
      }
      if (oneVar > twoVar) {
        return args.ONE;
      } else {
        return args.TWO;
      }
    }
    minBlock(args) {
      var oneVar = args.ONE;
      var twoVar = args.TWO;
      if (typeof args.ONE === 'string') {
        oneVar = args.ONE.length;
      }
      if (typeof args.TWO === 'string') {
        twoVar = args.TWO.length;
      }
      if (oneVar < twoVar) {
        return args.ONE;
      } else {
        return args.TWO;
      }
    }
    addStringBlock(args) {
      let buffer = "";
      if (args.INDEX > args.OGSTRING.length) {
        args.OGSTRING += args.BUFFER.toString().repeat(args.INDEX - args.OGSTRING.length);
      } else if (args.INDEX < 0) {
        buffer = args.BUFFER.toString().repeat(args.INDEX * -1);
        args.OGSTRING = buffer + args.OGSTRING;
        args.INDEX = 0;
      }
      return args.OGSTRING.substring(0, args.INDEX) + args.ADDSTRING + args.OGSTRING.substring(args.INDEX);
    }
    removeBlock(args) {
      if ((args.INDEXSTART - 1) < 0) {
        args.INDEXSTART = 0;
      }
      if ((args.INDEXEND - 1) >= args.TEXT.length) {
        args.INDEXEND = args.TEXT.length - 1;
      }
      if ((args.INDEXSTART - 1) > (args.INDEXEND - 1)) {
        return args.TEXT;
      }
      return args.TEXT.substring(0, (args.INDEXSTART - 1)) + args.TEXT.substring((args.INDEXEND - 1) + 1);
    }
    replaceBlock(args) {
      var index = Math.max(args.INDEX - 1, 0);
      if (index > args.TEXT.length) {
        index = args.TEXT.length;
      }
      return args.TEXT.substring(0, index) + args.BUFFER.repeat(Math.max((args.INDEX - 1 - args.TEXT.length), 0)) + args.STRING + args.BUFFER.repeat(Math.max(((args.INDEX - 1 + args.STRING.length) * -1), 0)) + args.TEXT.substring(args.INDEX - 1 + args.STRING.length);
    }
    prngBlock(args) {
      let seed1 = args.SEED1;
      let seed2 = args.SEED2;
      let seed3 = args.SEED3;
      let seed4 = args.SEED4;
      const hash = (s) => {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = Math.imul(31, h) + s.charCodeAt(i) | 0;
        }
        return h;
      };
      let x = hash(seed1.toString()) ^ hash(seed2.toString()) ^ hash(seed3.toString()) ^ hash(seed4.toString());
      x ^= x << 13;
      x ^= x >> 17;
      x ^= x << 5;
      return hash((x >>> 0).toString()) / 0x100000000 + 0.5;
    }
    mapBlock(args) {
      if (args.NUMBER < args.INPUT_MIN || args.NUMBER > args.INPUT_MAX) {
        return null;
      }
      return (args.NUMBER - args.INPUT_MIN) / (args.INPUT_MAX - args.INPUT_MIN) * (args.OUTPUT_MAX - args.OUTPUT_MIN) + args.OUTPUT_MIN;
    }
    probabilityBlock(args) {
      return 1 - (((args.UPPER - args.LOWER) / (args.UPPER - args.LOWER + 1)) ** args.ATTEMPT);
    }
    gaussianBlock(args) {
      return Math.exp(-((args.N - args.MEAN) ** 2) / (2 * args.SD ** 2)) / (args.SD * Math.sqrt(2 * Math.PI));
    }
    gaussianAreaBlock(args) {
      const gauss = (n) => {
        return Math.exp(-((n - args.MEAN) ** 2) / (2 * args.SD ** 2)) / (args.SD * Math.sqrt(2 * Math.PI));
      };
      let o = 0;
      for (let i = 0; i < args.QUALITY; i++) {
        o += gauss(args.LOWER + ((i + 0.5) / args.QUALITY  * (args.UPPER - args.LOWER)));
      }
      return o * ((args.UPPER - args.LOWER) / args.QUALITY);
    }
    clampBlock(args) {
      return Math.min(Math.max(args.NUMBER, args.LOWER), args.UPPER);
    }
    mathMenuBlock({MENU}) {
      switch (MENU) {
      case '∞': return Infinity;
      case '−∞': return -Infinity;
      case '𝜋': return Math.PI;
      case 'φ': return (1 + Math.sqrt(5)) / 2;
      case 'e': return Math.E;
      case '\\n': return '\n';
      }
      return MENU;
    }
    mathReporterBlock({ NUM1, MENU, NUM2, MENU2, NUM3 }) {
      let result = 0;
      result = {
        '+': NUM1 + NUM2,
        '-': NUM1 - NUM2,
        '*': NUM1 * NUM2,
        '/': NUM1 / NUM2,
        '^': NUM1 ** NUM2,
        '=': NUM1 === NUM2,
        '≈': Math.abs(NUM1 - NUM2) < 1,
        '≠': NUM1 !== NUM2,
        '<': NUM1 < NUM2,
        '≤': NUM1 <= NUM2,
        '>': NUM1 > NUM2,
        '≥': NUM1 >= NUM2
      }[MENU];
      result = {
        '+': result + NUM3,
        '-': result - NUM3,
        '*': result * NUM3,
        '/': result / NUM3,
        '^': result ** NUM3,
        '=': result === NUM3,
        '≈': Math.abs(result - NUM3) < 1,
        '≠': result !== NUM3,
        '<': result < NUM3,
        '≤': result <= NUM3,
        '>': result > NUM3,
        '≥': result >= NUM3
      }[MENU2];
      return result;
    }
    ifElseBlock({BOOL, NUM1, NUM2}) {
      if (BOOL) {
        return NUM1;
      } else {
        return NUM2;
      }
    }
    tripleJoinBlock({NUM1, NUM2, NUM3}) {
      return Scratch.Cast.toString(NUM1) + Scratch.Cast.toString(NUM2) + Scratch.Cast.toString(NUM3);
    }
    boolBlock({INPUT}) {
      return INPUT;
    }
    reporterBlock({INPUT}) {
      return INPUT;
    }
    directionBlock({X, Y, X2, Y2}) {
      return (((Math.atan2(X2 - X, Y2 - Y) * 180) / Math.PI) + 180) % 360 - 180;
    }
    waitBlock({INPUT, TIME }) {
      const wait = (args) => {
        return new Promise((resolve, reject) => {
          const timeInMilliseconds = TIME * 1000;
          setTimeout(() => {
            resolve();
          }, timeInMilliseconds);
        });
      };
      return wait({ TIME: 5 }).then(() => {
        return INPUT;
      });
    }
    splitBlock({NUM1, NUM2}) {
      if (typeof NUM1 === "number") {
        return null;
      }
      return JSON.stringify(NUM1.split(NUM2));
    }
    joinListBlock({LIST, JOINER}) {
      if (!isValidList(LIST)) {
        return null;
      }
      return JSON.parse(LIST).join(JOINER);
    }
    getItemListBlock({LIST, SPLICER}) {
      if (!isValidList(LIST)) {
        return null;
      }
      SPLICER -= 1;
      return JSON.parse(LIST).splice(SPLICER, 1)[0];
    }
    removeListBlock({LIST, REMOVE}) {
      if (!isValidList(LIST)) {
        return null;
      }
      const list = JSON.parse(LIST);
      if (typeof REMOVE === "number") {
        REMOVE -= 1;
        list.splice(REMOVE, 1);
        return JSON.stringify(list);
      }
      return JSON.stringify(list.filter((item) => item !== REMOVE));
    }
    indexOfListBlock({LIST, INPUT}) {
      if (!isValidList(LIST)) {
        return null;
      }
      const list = JSON.parse(LIST);
      return list.indexOf(INPUT) + 1;
    }
    addListBlock({LIST, ADD, INDEX}) {
      if (!isValidList(LIST)) {
        return null;
      }
      const list = JSON.parse(LIST);
      INDEX -= 1;
      list.splice(INDEX, 0, ADD);
      return JSON.stringify(list);
    }
    chunkSplitBlock({NUM1, NUM2}) {
      return JSON.stringify(String(NUM1).match(new RegExp(`.{1,${NUM2}}`, 'g')));
    }
    matrixBlock({MATRIX}) {
      return MATRIX;
    }
    colorBlock({COLOR}) {
      return COLOR;
    }
    pixelFontBlock(...args) {
      return JSON.stringify(Object.values(args[0]));
    }
    distanceBlock({X,X2,Y,Y2}) {
      return Math.sqrt(((X - X2) ** 2) + ((Y - Y2) ** 2));
    }
    matrixXYBlock({MATRIX,X,Y}) {
      return MATRIX.charAt((X - 1) + ((Y - 1) * 5));
    }
    convertBlock({INPUT, MENU, DIRECTION}) {
      if (DIRECTION === "to") {
        if (MENU === "base64") {
          return btoa(INPUT.toString());
        }
        if (MENU === "binary") {
          if (!isNaN(INPUT)) {
            return Number(INPUT).toString(2);
          }
          return INPUT.split('').map((char) => char.charCodeAt(0).toString(2)).join(' ');
        }
        if (MENU === "hexadecimal") {
          if (!isNaN(INPUT)) {
            return Number(INPUT).toString(16);
          }
        }
      } else if (DIRECTION === "from") {
        if (MENU === "base64") {
          return atob(INPUT);
        }
        if (MENU === "binary") {
          if (!String(INPUT).includes(' ')) {
            return String(parseInt(String(INPUT), 2));
          }
          return String.fromCharCode.apply(null, (String(INPUT).split(' ').map((binary) => parseInt(binary, 2))));
        }
        if (MENU === "hexadecimal") {
          const hexRegex = /^[0-9A-Fa-f]+$/;
          if (hexRegex.test(INPUT)) {
            return parseInt(INPUT, 16).toString();
          }
        }
      }
      return INPUT;
    }
    listOrderBlock({INPUT, MENU}) {
      if (!isValidList(INPUT)) {
        return null;
      }
      switch (MENU) {
      case 'ascending': return JSON.stringify(JSON.parse(INPUT).sort());
      case 'descending': return JSON.stringify(JSON.parse(INPUT).sort().reverse());
      case 'reverse': return JSON.stringify(JSON.parse(INPUT).reverse());
      }
      return INPUT;
    }
  }
  Scratch.extensions.register(new ReporterBucketExtension());
})(Scratch);